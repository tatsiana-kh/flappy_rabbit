This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
debugger-awaiter.html
demo/dear-project/assets/bunny.png
demo/dear-project/assets/l18n/en.l.json
demo/dear-project/assets/l18n/ru.l.json
demo/dear-project/assets/main.s.json
demo/dear-project/assets/src/custom/bunny.c.ts
demo/dear-project/assets/src/index.ts
demo/dear-project/thing-project.json
demo/example-lib/assets/flag.png
demo/example-lib/assets/lib1/l18n/en.l.json
demo/example-lib/assets/lib1/l18n/ru.l.json
demo/example-lib/thing-lib.json
demo/example-project/assets/bunny.png
demo/example-project/assets/l18n/en.l.json
demo/example-project/assets/l18n/ru.l.json
demo/example-project/assets/main.s.json
demo/example-project/assets/src/custom/bunny.c.ts
demo/example-project/assets/src/index.ts
demo/example-project/assets/symbols/fuel0000.png
demo/example-project/assets/symbols/fuel0001.png
demo/example-project/assets/symbols/fuel0002.png
demo/example-project/assets/symbols/fuel0003.png
demo/example-project/assets/symbols/fuel0004.png
demo/example-project/assets/symbols/fuel0005.png
demo/example-project/assets/symbols/fuel0006.png
demo/example-project/assets/symbols/fuel0007.png
demo/example-project/assets/symbols/fuel0008.png
demo/example-project/assets/symbols/fuel0009.png
demo/example-project/assets/symbols/fuel0010.png
demo/example-project/assets/symbols/fuel0011.png
demo/example-project/assets/symbols/fuel0012.png
demo/example-project/assets/symbols/fuel0013.png
demo/example-project/assets/symbols/fuel0014.png
demo/example-project/thing-project.json
demo/install.js
electron-main/build-config.js
electron-main/build-sounds.js
electron-main/build.js
electron-main/editor-server-utils.js
electron-main/enum-projects.js
electron-main/index.js
electron-main/launch-if-stopped.js
electron-main/package.json
electron-main/pixi-typings-patch.js
electron-main/preload.js
electron-main/resolver/package.json
electron-main/resolver/resolver.js
electron-main/server-fs.js
electron-main/static-server.js
electron-main/thing-editor-window.js
electron-main/vite-plugin-ifdef/if-def-loader.js
electron-main/vite-plugin-ifdef/package.json
electron-main/watch.js
img/accept.png
img/asset-class.png
img/asset-image.png
img/asset-prefab.png
img/asset-resource.png
img/asset-scene.png
img/asset-sound.png
img/bring-down.png
img/bring-up.png
img/broken-image.png
img/caret-open.png
img/caret.png
img/check-box-check.png
img/check-box.png
img/child-last.jpg
img/child.jpg
img/clone.png
img/copy.png
img/cut.png
img/delete.png
img/EMPTY.png
img/error-icon.png
img/error.png
img/exit-isolation.png
img/export-selected.png
img/eyedropper.png
img/favicon.ico
img/info.png
img/isolate-selected.png
img/lib0.png
img/lib1.png
img/lib2.png
img/lib3.png
img/lib4.png
img/lib5.png
img/lib6.png
img/move-down.png
img/move-up.png
img/open.png
img/orientation-toggle.png
img/paste-wrap.png
img/paste.png
img/pause.png
img/pivot/left-top.png
img/pivot/middle.png
img/play.png
img/recompile.png
img/reject.png
img/sound-mute.png
img/stop.png
img/timeline.jpg
img/timeline/default.png
img/timeline/disable.png
img/timeline/enable.png
img/timeline/remove.png
img/timeline/sound.png
img/timeline/speed-set.png
img/timeline/stop.png
img/tree/achive.png
img/tree/bitmap-text.png
img/tree/button.png
img/tree/click-outside.png
img/tree/container.png
img/tree/desc.png
img/tree/dsprite.png
img/tree/fill.png
img/tree/fly-text.png
img/tree/game.png
img/tree/html.png
img/tree/is-mobile.png
img/tree/label.png
img/tree/mask.png
img/tree/masked.png
img/tree/mixed-type.png
img/tree/movie-custom.png
img/tree/movie.png
img/tree/multiline-text.png
img/tree/music.png
img/tree/number-input.png
img/tree/orientation-trigger.png
img/tree/particle-container.png
img/tree/perspective.png
img/tree/progress.png
img/tree/promise.png
img/tree/resizer.png
img/tree/scene.png
img/tree/scissor.png
img/tree/scroll.png
img/tree/select.png
img/tree/shape.png
img/tree/slice9.png
img/tree/spawner-ring.png
img/tree/spawner.png
img/tree/spine.png
img/tree/sprite.png
img/tree/static-trigger.png
img/tree/text-input.png
img/tree/text.png
img/tree/tileGrid.png
img/tree/timer.png
img/tree/trigger.png
img/tree/unknown-class.png
img/unwrap.png
img/warn-icon.png
img/WHITE.jpg
img/wrong-texture.png
index.html
src/editor/classes-loader.ts
src/editor/current-classes-typings.ts
src/editor/current-scene-typings.ts
src/editor/editor-env.ts
src/editor/editor.ts
src/editor/empty-script.ts
src/editor/fs.ts
src/editor/localization-typings.ts
src/editor/preact-fabrics.ts
src/editor/prefabs-typing.ts
src/editor/project-desc.ts
src/editor/props-editor/editable.ts
src/editor/schema-thing-project.json
src/editor/style-spine-sequence.css
src/editor/style-timeline.css
src/editor/style.css
src/editor/templates/basic-game-object.tst
src/editor/templates/basic-scene.tst
src/editor/templates/full-game-object.tst
src/editor/templates/full-scene.tst
src/editor/ui/assets-view/asset-preview.ts
src/editor/ui/assets-view/asset-view-class.ts
src/editor/ui/assets-view/asset-view-image.ts
src/editor/ui/assets-view/asset-view-scene.ts
src/editor/ui/assets-view/asset-view-sound.ts
src/editor/ui/assets-view/assets-view-font.ts
src/editor/ui/assets-view/assets-view-l10n.ts
src/editor/ui/assets-view/assets-view-prefab.ts
src/editor/ui/assets-view/assets-view-resource.ts
src/editor/ui/assets-view/assets-view.ts
src/editor/ui/choose-list.ts
src/editor/ui/choose-project.ts
src/editor/ui/component-debounced.ts
src/editor/ui/context-menu.ts
src/editor/ui/editor-button.ts
src/editor/ui/editor-overlay.ts
src/editor/ui/editor-window.ts
src/editor/ui/filter-list.ts
src/editor/ui/group.ts
src/editor/ui/help.ts
src/editor/ui/isolation.ts
src/editor/ui/labels-logger.ts
src/editor/ui/language-view.ts
src/editor/ui/local-store-view.ts
src/editor/ui/main-menu.ts
src/editor/ui/modal.ts
src/editor/ui/modal/prompt.ts
src/editor/ui/props-editor/get-property-definition-url.ts
src/editor/ui/props-editor/props-editor.ts
src/editor/ui/props-editor/props-editors/array-editable-property.ts
src/editor/ui/props-editor/props-editors/boolean-editor.ts
src/editor/ui/props-editor/props-editors/btn-editor.ts
src/editor/ui/props-editor/props-editors/call-back-editor.ts
src/editor/ui/props-editor/props-editors/color-editor.ts
src/editor/ui/props-editor/props-editors/color-slider.ts
src/editor/ui/props-editor/props-editors/data-path-editor.ts
src/editor/ui/props-editor/props-editors/image-editor.ts
src/editor/ui/props-editor/props-editors/l10n-editor.ts
src/editor/ui/props-editor/props-editors/number-editor.ts
src/editor/ui/props-editor/props-editors/pow-damp-preset-selector.ts
src/editor/ui/props-editor/props-editors/prefab-property-editor.ts
src/editor/ui/props-editor/props-editors/rect-editor.ts
src/editor/ui/props-editor/props-editors/refs-editor.ts
src/editor/ui/props-editor/props-editors/resource-editor.ts
src/editor/ui/props-editor/props-editors/select-editor.ts
src/editor/ui/props-editor/props-editors/sound-editor.ts
src/editor/ui/props-editor/props-editors/spine-sequences/spine-sequences-editor.ts
src/editor/ui/props-editor/props-editors/spine-sequences/spine-sequences.ts
src/editor/ui/props-editor/props-editors/string-editor.ts
src/editor/ui/props-editor/props-editors/timeline/get-keyframe-types-for-field.ts
src/editor/ui/props-editor/props-editors/timeline/keyframe-property-editor.ts
src/editor/ui/props-editor/props-editors/timeline/objects-timeline.ts
src/editor/ui/props-editor/props-editors/timeline/time-marker.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-editor.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-field-controls.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-field.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-keyframe-view.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-label-view.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-line-view.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-loop-point.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-select-frame.ts
src/editor/ui/props-editor/props-editors/timeline/timeline-selectable.ts
src/editor/ui/props-editor/props-editors/timeline/timeline.ts
src/editor/ui/props-editor/props-field-wrapper.ts
src/editor/ui/sound-profiler.ts
src/editor/ui/status-bar.ts
src/editor/ui/status-clearing-condition.ts
src/editor/ui/status.ts
src/editor/ui/tip.ts
src/editor/ui/tree-view/tree-node-context-menu.ts
src/editor/ui/tree-view/tree-node.ts
src/editor/ui/tree-view/tree-view.ts
src/editor/ui/ui.ts
src/editor/ui/viewport.ts
src/editor/ui/window-menu.ts
src/editor/utils/build.ts
src/editor/utils/button-only-selectable-property.ts
src/editor/utils/copy-text-by-click.ts
src/editor/utils/data-access-debugger.ts
src/editor/utils/data-path-fixer.ts
src/editor/utils/debounced-call.ts
src/editor/utils/editor-events.ts
src/editor/utils/editor-utils.ts
src/editor/utils/enum-assets-recursive.ts
src/editor/utils/export-as-png.ts
src/editor/utils/find-file-in-assets.ts
src/editor/utils/flags.ts
src/editor/utils/generate-editor-typings.ts
src/editor/utils/get-hashed-asset-name.ts
src/editor/utils/get-parent-with-hidden-children.ts
src/editor/utils/get-prefab-defaults.ts
src/editor/utils/goto-label-consumer.ts
src/editor/utils/highlight-object.ts
src/editor/utils/history.ts
src/editor/utils/hotkey.ts
src/editor/utils/increase-number-in-name.ts
src/editor/utils/is-event-focus-on-input-element.ts
src/editor/utils/lib-info.ts
src/editor/utils/load-safe-instance-by-class-name.ts
src/editor/utils/merge-project-desc.ts
src/editor/utils/movie-clip-keyframe-select-path.ts
src/editor/utils/new-component-wizard.ts
src/editor/utils/number-checker.ts
src/editor/utils/old-references-detect.ts
src/editor/utils/prefab-editor.ts
src/editor/utils/prefab-selector.ts
src/editor/utils/protect-access-to-node.ts
src/editor/utils/refresh-prefabs.ts
src/editor/utils/round-up-point.ts
src/editor/utils/scene-all-validator.ts
src/editor/utils/scene-utils.ts
src/editor/utils/scroll-in-view.ts
src/editor/utils/search-by-regexp-or-text.ts
src/editor/utils/selection.ts
src/editor/utils/shake-element.ts
src/editor/utils/stack-utils.ts
src/editor/utils/stop-propagation.ts
src/editor/utils/unknown-class.ts
src/editor/utils/validate-serialized-data.ts
src/editor/warnings-filter.ts
src/engine/basic-preact-fabrics.ts
src/engine/debug/assert.ts
src/engine/game.ts
src/engine/HowlSound.ts
src/engine/lib.ts
src/engine/lib/~snd-convert-cache.json
src/engine/lib/assets/___default_content/progressbar.p.json
src/engine/lib/assets/___system/backdrop.p.json
src/engine/lib/assets/___system/delay.c.ts
src/engine/lib/assets/___system/gizmo.p.json
src/engine/lib/assets/___system/guide.p.json
src/engine/lib/assets/___system/rect-guide.p.json
src/engine/lib/assets/___system/ruler.p.json
src/engine/lib/assets/___system/scene-linked-promise.c.ts
src/engine/lib/assets/___system/unknown-prefab.p.json
src/engine/lib/assets/click.aac
src/engine/lib/assets/click.ogg
src/engine/lib/assets/click.wav
src/engine/lib/assets/fader/default.p.json
src/engine/lib/assets/final-fader.p.json
src/engine/lib/assets/index.html
src/engine/lib/assets/over.aac
src/engine/lib/assets/over.ogg
src/engine/lib/assets/over.wav
src/engine/lib/assets/particle-green.p.json
src/engine/lib/assets/preloader.s.json
src/engine/lib/assets/src/___system/___rect-guide.c.ts
src/engine/lib/assets/src/___system/backdrop.c.ts
src/engine/lib/assets/src/___system/gizmo-arrow.c.ts
src/engine/lib/assets/src/___system/gizmo.c.ts
src/engine/lib/assets/src/___system/guide.c.ts
src/engine/lib/assets/src/___system/ruler.c.ts
src/engine/lib/assets/src/basic/b-g-music.c.ts
src/engine/lib/assets/src/basic/b-g-music/music-fragment.ts
src/engine/lib/assets/src/basic/back-drop.c.ts
src/engine/lib/assets/src/basic/bitmap-text.c.ts
src/engine/lib/assets/src/basic/button.c.ts
src/engine/lib/assets/src/basic/click-outside-trigger.c.ts
src/engine/lib/assets/src/basic/container.c.ts
src/engine/lib/assets/src/basic/d-sprite.c.ts
src/engine/lib/assets/src/basic/fill.c.ts
src/engine/lib/assets/src/basic/fly-text.c.ts
src/engine/lib/assets/src/basic/movie-clip.c.ts
src/engine/lib/assets/src/basic/movie-clip/field-player.ts
src/engine/lib/assets/src/basic/multiline-text.c.ts
src/engine/lib/assets/src/basic/nine-slice-plane.c.ts
src/engine/lib/assets/src/basic/particle-container.c.ts
src/engine/lib/assets/src/basic/scene.c.ts
src/engine/lib/assets/src/basic/spawner-ring.c.ts
src/engine/lib/assets/src/basic/spawner.c.ts
src/engine/lib/assets/src/basic/sprite.c.ts
src/engine/lib/assets/src/basic/static-trigger.c.ts
src/engine/lib/assets/src/basic/text.c.ts
src/engine/lib/assets/src/common/ui/orientation-parent-resizer.c.ts
src/engine/lib/assets/src/common/ui/parent-resizer.c.ts
src/engine/lib/assets/src/custom/particle-short.c.ts
src/engine/lib/assets/src/extended/html-overlay.c.ts
src/engine/lib/assets/src/extended/is-mobile-trigger.c.ts
src/engine/lib/assets/src/extended/label.c.ts
src/engine/lib/assets/src/extended/layered-container.c.ts
src/engine/lib/assets/src/extended/layered-contaiter-portal.c.ts
src/engine/lib/assets/src/extended/mask.c.ts
src/engine/lib/assets/src/extended/progress-bar.c.ts
src/engine/lib/assets/src/extended/resizer.c.ts
src/engine/lib/assets/src/extended/scroll-layer.c.ts
src/engine/lib/assets/src/extended/shape.c.ts
src/engine/lib/assets/src/extended/spine.c.ts
src/engine/lib/assets/src/extended/trigger.c.ts
src/engine/lib/assets/src/extended/unpausable-container.c.ts
src/engine/lib/assets/src/mobile/orientation-trigger.c.ts
src/engine/lib/assets/src/utils/format-money.ts
src/engine/lib/assets/src/utils/wait-for-condition.ts
src/engine/lib/assets/ui/sure-question.p.json
src/engine/lib/schema-thing-project.json
src/engine/lib/thing-lib.json
src/engine/utils/call-by-path.ts
src/engine/utils/deep-freeze.ts
src/engine/utils/full-screen.ts
src/engine/utils/game-interaction.ts
src/engine/utils/get-value-by-path.ts
src/engine/utils/html-error.html
src/engine/utils/indexed-db-utils.ts
src/engine/utils/keys.ts
src/engine/utils/l.ts
src/engine/utils/load-dynamic-textures.ts
src/engine/utils/pool.ts
src/engine/utils/re-apply-textures.ts
src/engine/utils/remove-holder.ts
src/engine/utils/scene-linked-request.ts
src/engine/utils/settings.ts
src/engine/utils/sound-debug-panel.css
src/engine/utils/sound.ts
src/engine/utils/sure-question.ts
src/engine/utils/utils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="debugger-awaiter.html">
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="./src/editor/style.css" />
    <meta charset="UTF-8" />
    <!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    />
    <title>Thing-Editor 2.0</title>
  </head>

  <body>
    debugger await...
    <script type="module">
      window.a = 0;
      window.setInterval(() => {
        window.a++; // do the work to debugger can attach to js engine
      }, 10);
    </script>
  </body>
</html>
</file>

<file path="demo/dear-project/assets/l18n/en.l.json">
{
	"example_title": "Flappy dear"
}
</file>

<file path="demo/dear-project/assets/l18n/ru.l.json">
{
	"example_title": "Летающий олень"
}
</file>

<file path="demo/dear-project/assets/main.s.json">
{
	"c": "Scene",
	"p": {
		"name": "main",
		"__description": "",
		"backgroundColor": 276
	},
	":": [
		{
			"c": "Text",
			"p": {
				"x": 30,
				"y": 98,
				"text": "",
				"translatableText": "example_title",
				"style.align": "left",
				"verticalAlign": "top",
				"style.fill": "#9fafc1"
			}
		},
		{
			"c": "MovieClip",
			"p": {
				"x": 442,
				"y": 577,
				"image": "symbols/fuel0000.png",
				"timeline": {
					"l": {},
					"p": 0.02,
					"d": 0.85,
					"f": [
						{
							"n": "image",
							"t": [
								{
									"v": "symbols/fuel0000.png",
									"t": 0,
									"m": 2
								},
								{
									"v": "symbols/fuel0001.png",
									"t": 2,
									"m": 2
								},
								{
									"v": "symbols/fuel0002.png",
									"t": 4,
									"m": 2
								},
								{
									"v": "symbols/fuel0003.png",
									"t": 6,
									"m": 2
								},
								{
									"v": "symbols/fuel0004.png",
									"t": 8,
									"m": 2
								},
								{
									"v": "symbols/fuel0005.png",
									"t": 10,
									"m": 2
								},
								{
									"v": "symbols/fuel0006.png",
									"t": 12,
									"m": 2
								},
								{
									"v": "symbols/fuel0007.png",
									"t": 14,
									"m": 2
								},
								{
									"v": "symbols/fuel0008.png",
									"t": 16,
									"m": 2
								},
								{
									"v": "symbols/fuel0009.png",
									"t": 18,
									"m": 2
								},
								{
									"v": "symbols/fuel0010.png",
									"t": 20,
									"m": 2
								},
								{
									"v": "symbols/fuel0011.png",
									"t": 22,
									"m": 2
								},
								{
									"v": "symbols/fuel0012.png",
									"t": 24,
									"m": 2
								},
								{
									"v": "symbols/fuel0013.png",
									"t": 26,
									"m": 2
								},
								{
									"v": "symbols/fuel0014.png",
									"t": 28,
									"m": 2
								},
								{
									"v": "symbols/fuel0013.png",
									"t": 30,
									"m": 2
								},
								{
									"v": "symbols/fuel0012.png",
									"t": 32,
									"m": 2
								},
								{
									"v": "symbols/fuel0011.png",
									"t": 34,
									"m": 2
								},
								{
									"v": "symbols/fuel0010.png",
									"t": 36,
									"m": 2
								},
								{
									"v": "symbols/fuel0009.png",
									"t": 38,
									"m": 2
								},
								{
									"v": "symbols/fuel0008.png",
									"t": 40,
									"m": 2
								},
								{
									"v": "symbols/fuel0007.png",
									"t": 42,
									"m": 2
								},
								{
									"v": "symbols/fuel0006.png",
									"t": 44,
									"m": 2
								},
								{
									"v": "symbols/fuel0005.png",
									"t": 46,
									"m": 2
								},
								{
									"v": "symbols/fuel0004.png",
									"t": 48,
									"m": 2
								},
								{
									"v": "symbols/fuel0003.png",
									"t": 50,
									"m": 2
								},
								{
									"v": "symbols/fuel0002.png",
									"t": 52,
									"m": 2
								},
								{
									"v": "symbols/fuel0001.png",
									"t": 54,
									"m": 2
								},
								{
									"v": "symbols/fuel0000.png",
									"t": 56,
									"m": 2,
									"j": 0
								}
							]
						},
						{
							"n": "x",
							"t": [
								{
									"v": 442,
									"t": 0
								},
								{
									"v": 714,
									"t": 179,
									"r": -418
								},
								{
									"v": 1273,
									"t": 293,
									"j": 0,
									"r": -418
								}
							]
						},
						{
							"n": "y",
							"t": [
								{
									"v": 577,
									"t": 0
								},
								{
									"v": 359,
									"t": 105,
									"r": -418
								},
								{
									"v": 807,
									"t": 221,
									"j": 0,
									"r": -418
								}
							]
						}
					]
				}
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1038,
				"y": 288,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 890,
				"y": 438,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1296,
				"y": 473,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 670,
				"y": 738,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1238,
				"y": 842,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1424,
				"y": 997,
				"image": "bunny.png"
			}
		}
	]
}
</file>

<file path="demo/dear-project/assets/src/custom/bunny.c.ts">
// import editable from 'thing-editor/src/editor/props-editor/editable';
// import game from 'thing-editor/src/engine/game';
// import DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';

// let FLOOR_Y = 0;

// export default class Bunny extends DSprite {

// 	@editable()
// 	gravity = 2;

// 	init() {
// 		super.init();
// 		this.xSpeed = (Math.random() - 0.5) * 40;
// 		this.ySpeed = (Math.random() - 0.5) * 40;
// 		FLOOR_Y = game.H - 25;
// 	}
// 	_onRenderResize() {
// 		FLOOR_Y = game.H - 25;
// 	}

// 	update() {
// 		if (this.y >= FLOOR_Y) {
// 			this.ySpeed *= -1;
// 		} else {
// 			this.ySpeed += Math.min(this.gravity, FLOOR_Y - this.y);
// 		}

// 		if (this.x < 0) {
// 			this.x = 0;
// 			this.xSpeed *= -1.0;
// 		}

// 		if (this.x > game.W) {
// 			this.x = game.W;
// 			this.xSpeed *= -1.0;
// 		}

// 		this.scale.x = this.xSpeed > 0 ? 1 : -1;
// 		super.update();
// 	}
// }

import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import { ƒ } from 'thing-editor/js/engine/utils'; // Импортируем утилиты для ƒ.delta и ƒ.clamp

// --- КОНСТАНТЫ ДЛЯ FLAPPY МЕХАНИКИ ---
const GAME_GRAVITY = 1200; // Ускорение гравитации (пикселей/сек^2). Сделаем чуть сильнее.
const JUMP_VELOCITY = -500; // Скорость прыжка (отрицательное значение - вверх)

export default class Bunny extends DSprite {

    // Добавляем наши переменные для физики и состояния
    private velocityY: number = 0;
    private isAlive: boolean = true;

    // В init() устанавливаем начальные условия и привязываем ввод
    init() {
    	super.init();

    	// Устанавливаем начальную позицию и скорость
    	this.x = game.W * 0.2; // Заяц находится слева
    	this.y = game.H / 2;
    	this.velocityY = 0;
    	this.isAlive = true;

    	// Привязываем обработчик клика/касания ко всей сцене для прыжка
    	const stage = game.getCurrentContainer();
    	if (stage) {
    		stage.interactive = true;
    		stage.on('pointerdown', this.onJump, this);
    	}
    }

    // Метод, вызываемый при клике/касании
    onJump() {
    	if (this.isAlive) {
    		this.velocityY = JUMP_VELOCITY;
    	}
    }

    // Метод для обработки проигрыша
    gameOver() {
    	if (!this.isAlive) return;
    	this.isAlive = false;
    	console.log('Заяц разбился! Game Over.');
    	// Здесь можно остановить движение препятствий
    	// game.editor.stop();
    }

    // Главный цикл логики
    update() {
    	if (!this.isAlive) {
    		return;
    	}

    	// 1. Применяем гравитацию
    	// ƒ.delta - это время, прошедшее с предыдущего кадра, в секундах.
    	this.velocityY += GAME_GRAVITY * ƒ.delta;

    	// 2. Изменяем вертикальную позицию
    	this.y += this.velocityY * ƒ.delta;

    	// 3. Добавляем поворот спрайта (Визуальный эффект)
    	// Заяц наклоняется вниз при падении
    	this.rotation = ƒ.clamp(
    		this.velocityY / 800 * (Math.PI / 2),
    		-Math.PI / 6, // Максимальный подъем
    		Math.PI / 2 // Максимальный наклон вниз
    	);

    	// 4. Проверка на Game Over (падение ниже экрана или полет выше)
    	if (this.y > game.H || this.y < 0) {
    		this.gameOver();
    	}

    	super.update(); // Вызов родительского update (важно для DSprite)
    }

    // Очистка слушателей при удалении объекта
    onRemove() {
    	const stage = game.getCurrentContainer();
    	if (stage) {
    		stage.off('pointerdown', this.onJump, this);
    	}
    	super.onRemove();
    }
}
</file>

<file path="demo/dear-project/assets/src/index.ts">
import game from 'thing-editor/src/engine/game';

game.init();
</file>

<file path="demo/dear-project/thing-project.json">
{
	"defaultFont": "Roboto, Arial",
	"version": "0.0.9",
	"__loadOnDemandTexturesFolders": {
		"ondemand": 2
	},
	"loadOnDemandTextures": {
		"ondemand/1.png": 2,
		"ondemand/2.png": 6,
		"map/map1.png": 4,
		"map/floor.png": 4,
		"blink-wave.png": 8,
		"perlin.jpg": 8
	},
	"__group": "thing-editor-demos",
	"id": "flappy-dear.pixel-cave.com",
	"title": "Flappy dear",
	"icon": "assets/bunny.png",
	"loadOnDemandSounds": {
		"mus/gs3_title": 2
	},
	"libs": [
		"example-lib"
	],
	"autoFullscreenDesktop": false,
	"autoFullscreenMobile": false
}
</file>

<file path="demo/example-lib/assets/lib1/l18n/en.l.json">
{
	"menu": "Menu",
	"click_to_continue": "Click to continue..."
}
</file>

<file path="demo/example-lib/assets/lib1/l18n/ru.l.json">
{
	"menu": "Меню",
	"click_to_continue": "Клик для продолжения..."
}
</file>

<file path="demo/example-lib/thing-lib.json">
{}
</file>

<file path="demo/example-project/assets/l18n/en.l.json">
{
	"example_title": "THING-EDITOR\nexample project"
}
</file>

<file path="demo/example-project/assets/l18n/ru.l.json">
{
	"example_title": "THING-EDITOR\nтестовый проект"
}
</file>

<file path="demo/example-project/assets/main.s.json">
{
	"c": "Scene",
	"p": {
		"name": "main",
		"__description": "",
		"backgroundColor": 276
	},
	":": [
		{
			"c": "Text",
			"p": {
				"x": 30,
				"y": 98,
				"text": "",
				"translatableText": "example_title",
				"style.align": "left",
				"verticalAlign": "top",
				"style.fill": "#9fafc1"
			}
		},
		{
			"c": "MovieClip",
			"p": {
				"x": 442,
				"y": 577,
				"image": "symbols/fuel0000.png",
				"timeline": {
					"l": {},
					"p": 0.02,
					"d": 0.85,
					"f": [
						{
							"n": "image",
							"t": [
								{
									"v": "symbols/fuel0000.png",
									"t": 0,
									"m": 2
								},
								{
									"v": "symbols/fuel0001.png",
									"t": 2,
									"m": 2
								},
								{
									"v": "symbols/fuel0002.png",
									"t": 4,
									"m": 2
								},
								{
									"v": "symbols/fuel0003.png",
									"t": 6,
									"m": 2
								},
								{
									"v": "symbols/fuel0004.png",
									"t": 8,
									"m": 2
								},
								{
									"v": "symbols/fuel0005.png",
									"t": 10,
									"m": 2
								},
								{
									"v": "symbols/fuel0006.png",
									"t": 12,
									"m": 2
								},
								{
									"v": "symbols/fuel0007.png",
									"t": 14,
									"m": 2
								},
								{
									"v": "symbols/fuel0008.png",
									"t": 16,
									"m": 2
								},
								{
									"v": "symbols/fuel0009.png",
									"t": 18,
									"m": 2
								},
								{
									"v": "symbols/fuel0010.png",
									"t": 20,
									"m": 2
								},
								{
									"v": "symbols/fuel0011.png",
									"t": 22,
									"m": 2
								},
								{
									"v": "symbols/fuel0012.png",
									"t": 24,
									"m": 2
								},
								{
									"v": "symbols/fuel0013.png",
									"t": 26,
									"m": 2
								},
								{
									"v": "symbols/fuel0014.png",
									"t": 28,
									"m": 2
								},
								{
									"v": "symbols/fuel0013.png",
									"t": 30,
									"m": 2
								},
								{
									"v": "symbols/fuel0012.png",
									"t": 32,
									"m": 2
								},
								{
									"v": "symbols/fuel0011.png",
									"t": 34,
									"m": 2
								},
								{
									"v": "symbols/fuel0010.png",
									"t": 36,
									"m": 2
								},
								{
									"v": "symbols/fuel0009.png",
									"t": 38,
									"m": 2
								},
								{
									"v": "symbols/fuel0008.png",
									"t": 40,
									"m": 2
								},
								{
									"v": "symbols/fuel0007.png",
									"t": 42,
									"m": 2
								},
								{
									"v": "symbols/fuel0006.png",
									"t": 44,
									"m": 2
								},
								{
									"v": "symbols/fuel0005.png",
									"t": 46,
									"m": 2
								},
								{
									"v": "symbols/fuel0004.png",
									"t": 48,
									"m": 2
								},
								{
									"v": "symbols/fuel0003.png",
									"t": 50,
									"m": 2
								},
								{
									"v": "symbols/fuel0002.png",
									"t": 52,
									"m": 2
								},
								{
									"v": "symbols/fuel0001.png",
									"t": 54,
									"m": 2
								},
								{
									"v": "symbols/fuel0000.png",
									"t": 56,
									"m": 2,
									"j": 0
								}
							]
						},
						{
							"n": "x",
							"t": [
								{
									"v": 442,
									"t": 0
								},
								{
									"v": 714,
									"t": 179,
									"r": -418
								},
								{
									"v": 1273,
									"t": 293,
									"j": 0,
									"r": -418
								}
							]
						},
						{
							"n": "y",
							"t": [
								{
									"v": 577,
									"t": 0
								},
								{
									"v": 359,
									"t": 105,
									"r": -418
								},
								{
									"v": 807,
									"t": 221,
									"j": 0,
									"r": -418
								}
							]
						}
					]
				}
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1038,
				"y": 288,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 890,
				"y": 438,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1296,
				"y": 473,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 670,
				"y": 738,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1238,
				"y": 842,
				"image": "bunny.png"
			}
		},
		{
			"c": "Bunny",
			"p": {
				"x": 1424,
				"y": 997,
				"image": "bunny.png"
			}
		}
	]
}
</file>

<file path="demo/example-project/assets/src/custom/bunny.c.ts">
import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';

let FLOOR_Y = 0;

export default class Bunny extends DSprite {

	@editable()
	gravity = 2;

	init() {
		super.init();
		this.xSpeed = (Math.random() - 0.5) * 40;
		this.ySpeed = (Math.random() - 0.5) * 40;
		FLOOR_Y = game.H - 25;
	}
	_onRenderResize() {
		FLOOR_Y = game.H - 25;
	}

	update() {
		if (this.y >= FLOOR_Y) {
			this.ySpeed *= -1;
		} else {
			this.ySpeed += Math.min(this.gravity, FLOOR_Y - this.y);
		}

		if (this.x < 0) {
			this.x = 0;
			this.xSpeed *= -1.0;
		}

		if (this.x > game.W) {
			this.x = game.W;
			this.xSpeed *= -1.0;
		}

		this.scale.x = this.xSpeed > 0 ? 1 : -1;
		super.update();
	}
}
</file>

<file path="demo/example-project/assets/src/index.ts">
import game from 'thing-editor/src/engine/game';

game.init();
</file>

<file path="demo/example-project/thing-project.json">
{
	"defaultFont": "Roboto, Arial",
	"version": "0.0.9",
	"__loadOnDemandTexturesFolders": {
		"ondemand": 2
	},
	"loadOnDemandTextures": {
		"ondemand/1.png": 2,
		"ondemand/2.png": 6,
		"map/map1.png": 4,
		"map/floor.png": 4,
		"blink-wave.png": 8,
		"perlin.jpg": 8
	},
	"__group": "thing-editor-demos",
	"id": "thing-project-example.pixel-cave.com",
	"title": "thing-project-example",
	"icon": "assets/bunny.png",
	"loadOnDemandSounds": {
		"mus/gs3_title": 2
	},
	"libs": [
		"example-lib"
	],
	"autoFullscreenDesktop": false,
	"autoFullscreenMobile": false
}
</file>

<file path="demo/install.js">
import fs from 'fs';
import * as patcher from '../electron-main/pixi-typings-patch.js';

patcher.default();

if (!fs.existsSync('./games')) {
	fs.mkdirSync('./games');
}
if (!fs.existsSync('./libs')) {
	fs.mkdirSync('./libs');
}

if (!fs.existsSync('./thing-editor.code-workspace')) {
	fs.copyFileSync('./thing-editor.code-workspace.template', './thing-editor.code-workspace');
}
if (!fs.existsSync('./tsconfig.json')) {
	fs.copyFileSync('./tsconfig.json.template', './tsconfig.json');
}

fs.cpSync('./thing-editor/demo/example-project', './games/example-project', {recursive: true, force: false});
fs.cpSync('./thing-editor/demo/dear-project', './games/dear-project', {recursive: true, force: false});

fs.cpSync('./thing-editor/demo/example-lib', './libs/example-lib', {recursive: true, force: false});

if (!fs.existsSync('./thing-editor/src/editor/current-classes-typings.ts')) {
	fs.writeFileSync('./thing-editor/src/editor/current-classes-typings.ts', 'export default {}');
}

if (!fs.existsSync('./thing-editor/src/editor/current-scene-typings.ts')) {
	fs.writeFileSync('./thing-editor/src/editor/current-scene-typings.ts', 'export default {}');
}

if (!fs.existsSync('./thing-editor/src/editor/localization-typings.ts')) {
	fs.writeFileSync('./thing-editor/src/editor/localization-typings.ts', 'export interface LocalizationKeys {}');
}
</file>

<file path="electron-main/build-config.js">
const ifDefPlugin = require('./vite-plugin-ifdef/if-def-loader.js');
const path = require('path');
const {ViteImageOptimizer} = require('vite-plugin-image-optimizer');

module.exports = (_root, publicDir, outDir, debug, _projectDesc) => {
	return {
		json: {
			namedExports: false
		},
		root: '.tmp',
		publicDir,
		base: './',
		esbuild: {
			target: 'ES2015'
		},
		plugins: [
			ifDefPlugin(debug),
			ViteImageOptimizer({
				logStats: false,
				test: /^((?!no-optimize).)*\.(jpe?g|png|gif|tiff|webp|svg|avif)$/i,
				jpeg: {
					quality: _projectDesc.jpgQuality,
				},
				jpg: {
					quality: _projectDesc.jpgQuality,
				}
			})
		],
		build: {
			target: 'ES2015',
			emptyOutDir: true,
			minify: !debug,
			outDir,
			rollupOptions: {
				input: ''
			},
		},
		resolve: {
			alias: {
				'games': path.resolve(__dirname, '../../games'),
				'.tmp': path.resolve(__dirname, '../../.tmp'),
				'libs': path.resolve(__dirname, '../../libs'),
				'thing-editor': path.resolve(__dirname, '../../thing-editor'),
				'pixi.js': 'https://cdn.jsdelivr.net/npm/pixi.js@7.2.4/dist/pixi.min.mjs'
			}
		}
	};
};
</file>

<file path="electron-main/build-sounds.js">
const path = require('path');
const fs = require('fs');
const md5File = require('md5-file');

const {exec} = require('child_process');
const {walkSync} = require('./editor-server-utils');

const isWin = process.platform === 'win32';

const getCommandPath = (commandName) => {
	const absPath = path.join(__dirname, './.bin/ffmpeg/' + commandName + (isWin ? '.exe' : ''));
	return fs.existsSync(absPath) ? absPath : commandName;
};

module.exports = async function (options) {

	const soundsPath = options.dir;

	let resolve;
	let retPromise = new Promise((_resolve) => {
		resolve = _resolve;
	});
	let result = {};

	function outputError(err, outError, out) {
		if (!result.errors) {
			result.errors = [];
		}
		result.errors.push({err, out, outError});
		console.error(err);
	}

	let cache;
	let cacheFn = path.join(soundsPath, '~snd-convert-cache.json');
	if (fs.existsSync(cacheFn)) {
		cache = JSON.parse(fs.readFileSync(cacheFn));
		if (cache?.fileName !== cacheFn) {
			cache = undefined;
		}
	}
	if (!cache) {
		cache = {fileName: cacheFn};
	}
	let filesToConvert = [];

	let probePath = getCommandPath('ffprobe');

	let files = walkSync(soundsPath);
	for (let fileEntry of files) {
		const fn = fileEntry.fileName;
		const mTime = fileEntry.mTime;
		if (fn.endsWith('.wav') && (fn.indexOf('/~') < 0)) {
			let bitrate = getBitrate(fn);

			let fileNameWithoutExt = fn.replace(/wav$/gmi, '');
			let allTargetFilesExists = options.formats.every((ext) => {
				return fs.existsSync(fileNameWithoutExt + ext);
			});

			let hash;
			if (cache.hasOwnProperty(fn) && (mTime !== cache[fn].mTime)) {
				hash = await md5FileSafe(fn);
				if (cache[fn].hash === hash) {
					cache[fn].mTime = mTime;
				}
			}

			if (!allTargetFilesExists || (options.noCacheSoundName === fn) || !cache.hasOwnProperty(fn) || (mTime !== cache[fn].mTime) || (bitrate !== cache[fn].bitrate) || !cache[fn].duration) {
				if (!hash) {
					hash = await md5FileSafe(fn);
				}
				cache[fn] = {
					mTime,
					bitrate,
					hash
				};
				filesToConvert.push({name: fn, cache: cache[fn]});
			}
		}
	}

	let promises = [];

	for (let fileData of filesToConvert) {
		for (let format of options.formats) {
			result.updated = true;
			promises.push(new Promise((resolve) => {
				convertFile(fileData, format, resolve);
			}));
		}
	}

	Promise.all(promises).then(() => {
		if (!result.errors && result.updated) {
			fs.writeFileSync(cacheFn, JSON.stringify(cache));
		}
		result.soundInfo = cache;
		resolve(result);
	});

	function getBitrate(fn) {
		let shortFilename = fn.replace(soundsPath, '');
		shortFilename = shortFilename.replace(/\.wav$/gmi, '');
		shortFilename = shortFilename.replace('\\', '/');
		return options.bitRates[shortFilename] || options.defaultBitrate || 96;
	}

	function convertFile(fileData, ext, cb) {
		let fn = fileData.name;
		let bitrate = getBitrate(fn);

		let fileParts = path.parse(fn);
		let resultName = fileParts.dir + '/' + fileParts.name + '.' + ext;

		if (fs.existsSync(resultName)) {
			fs.unlinkSync(resultName);
		}

		let additionalOptions = '';
		if (ext === 'webm') {
			additionalOptions = '-dash 1 ';
		}

		additionalOptions += '-b:a ' + bitrate + 'k ';

		let timoutCounter = 0;

		let errorArgs;

		function conversionAttempt() {
			timoutCounter++;
			if (timoutCounter > 5) {
				if (errorArgs) {
					outputError.apply(null, errorArgs);
				}
				cb();
				return;
			}

			try {
				fs.accessSync(fn, fs.constants.R_OK | fs.constants.W_OK);
			} catch (_er) {
				console.log('file reading blocked: ' + fn);
				setTimeout(conversionAttempt, 1000);
				return;
			}
			let ffmpegPath = getCommandPath('ffmpeg');

			exec(ffmpegPath + ' -i "' + fn + '" ' + additionalOptions + ' "' + resultName + '"', (err, out, outError) => {
				if (err) {
					errorArgs = [err, outError, out];
					console.log(err, out);
					console.error(outError);
					throw err;
				} else {
					exec(probePath + ' -show_entries format=duration -v quiet -of csv="p=0" -i "' + fn + '"', (err, out, outError) => {
						if (err) {
							errorArgs = [err, outError, out];
							console.log(err, out);
							console.error(outError);
							throw err;
						} else {
							fileData.cache.duration = parseFloat(out);
							cb();
						}
					});
				}
			});
		}
		conversionAttempt();
	}
	return retPromise;
};

function md5FileSafe(fn) {
	return new Promise((resolve) => {
		try {
			resolve(md5File.sync(fn));
		} catch (_er) {
			setInterval(() => {
				try {
					resolve(md5File.sync(fn));
				} catch (_er) { }
			}, 1000);
		}
	});
}
</file>

<file path="electron-main/build.js">
const path = require('path');
const fs = require('fs');

const {walkSync} = require('./editor-server-utils');

module.exports = {
	build: (projectDir, debug, assetsToCopy, projectDesc) => {
		const editorRoot = path.resolve(__dirname, '../..');
		const tmpDir = editorRoot + '/.tmp';
		const projectRoot = path.join('..', projectDir);
		const outDir = projectRoot + (debug ? '/debug' : '/release');
		const publicDir = tmpDir + '/public';
		const publicAssetsDir = publicDir + '/assets/';

		if (fs.existsSync(publicDir)) {
			let files = walkSync(publicDir);
			for (let fileEntry of files) {
				fs.unlinkSync(fileEntry.fileName);
			}
		}
		if (fs.existsSync(outDir)) {
			let files = walkSync(outDir);
			for (let fileEntry of files) {
				fs.unlinkSync(fileEntry.fileName);
			}
		}

		if (!fs.existsSync(publicDir)) {
			fs.mkdirSync(publicDir);
		}
		if (!fs.existsSync(publicAssetsDir)) {
			fs.mkdirSync(publicAssetsDir);
		}
		return Promise.all(assetsToCopy.map((asset) => {
			return new Promise((resolve, reject) => {
				const to = publicAssetsDir + asset.to;
				const dirName = path.dirname(to);
				if (!fs.existsSync(dirName)) {
					fs.mkdirSync(dirName, {recursive: true});
				}
				fs.copyFile(editorRoot + asset.from, to, (er) => {
					if (er) {
						debugger;
						reject(er);
					} else {
						resolve();
					}
				});
			});
		})).then(() => {
			return require('vite').build(require(path.resolve(editorRoot, debug ? projectDesc.__buildConfigDebug : projectDesc.__buildConfigRelease))(projectRoot, publicDir, outDir, debug, projectDesc)).then((res) => {
				require('./static-server.js');
				console.log('BUILD COMPLETE: ' + 'http://localhost:5174/' + projectDir);
				return res;
			}).catch((er) => {
				console.error(er.stack);
				return er;
			});
		});
	}
};
</file>

<file path="electron-main/editor-server-utils.js">
const path = require('path');
const fs = require('fs');

const walkSync = (dir, fileList = []) => {
	fs.readdirSync(dir).forEach(file => {
		if (!file.startsWith('~')) {
			let fullPath = path.join(dir, file);
			let stats = fs.statSync(fullPath);
			if (stats.isDirectory()) {
				fileList = walkSync(fullPath, fileList);
			} else if (stats.size > 0) {
				if (path.sep !== '/') {
					fullPath = fullPath.replaceAll(path.sep, '/');
				}
				fileList.push({fileName: fullPath, mTime: stats.mtimeMs});
			}
		}
	});
	return fileList;
};

module.exports = {walkSync};
</file>

<file path="electron-main/enum-projects.js">
const fs = require('fs');
const path = require('path');

const GAMES_ROOT = path.join(__dirname, '../../games');

const enumProjects = (ret = [], subDir = '') => {
	let dir = path.join(GAMES_ROOT, subDir);
	fs.readdirSync(dir).forEach(file => {
		if (file !== '.git' && file !== 'node_modules') {
			let dirName = path.join(dir, file);
			if (fs.statSync(dirName).isDirectory()) {
				let projDescFile = dirName + '/thing-project.json';
				if (fs.existsSync(projDescFile)) {
					let desc;
					try {
						desc = JSON.parse(fs.readFileSync(projDescFile, 'utf8'));
					} catch (er) {
						throw (new Error('Error in file: ' + projDescFile + '\n' + er.message));
					}
					desc.dir = subDir ? (subDir + '/' + file) : file;
					ret.push(desc);
				} else {
					enumProjects(ret, subDir ? (subDir + '/' + file) : file);
				}
			}
		}
	});
	return ret;
};

module.exports = enumProjects;
</file>

<file path="electron-main/index.js">
const {
	app,
	BrowserWindow,
	nativeTheme,
	dialog,
	globalShortcut,
	shell
} = require('electron');

console.warn('debug only configuration running. Please use "EDITOR" configuration for normal editor work.');

(() => {
	/** @type BrowserWindow */
	let mainWindow;

	if (!app.requestSingleInstanceLock()) {
		app.quit();
		return;
	}
	app.on('second-instance', () => {
		if (mainWindow) {
			if (mainWindow.isMinimized()) mainWindow.restore();
			mainWindow.focus();
		}
	});

	function isClosingBlocked() {
		if (mainWindow.__currentProgressOperation) {
			const res = dialog.showMessageBoxSync(mainWindow, {
				title: 'Are you sure?',
				message: mainWindow.__currentProgressOperation + ' in progress. ' + Math.round(mainWindow.__currentProgress * 100) + '% of 100% complete',
				buttons: [
					'Abort ' + mainWindow.__currentProgressOperation + ' and close',
					'Wait for ' + mainWindow.__currentProgressOperation + ' finish',
				],
				defaultId: 1,
				cancelId: 0
			});
			return res === 1;
		}
	}

	const originalLog = console.log.bind(console);

	console.log = (txt) => {
		try {
			originalLog(txt);
		} catch (_er) { }
	};

	const IS_DEBUG = process.argv.includes('debugger-detection-await');

	process.env['ELECTRON_DISABLE_SECURITY_WARNINGS'] = 'true';


	const path = require('path');
	const os = require('os');

	const getPositionRestoreWindow = require('./thing-editor-window.js');

	process.on('unhandledRejection', function (err) {
		console.error(err.stack || err.message || err);
		dialog.showErrorBox('Thing-editor back-end error.', err.stack || err.message || err);
	});

	process.on('uncaughtException', function (err) {
		console.error(err.stack || err.message || err);
		dialog.showErrorBox('Thing-editor back-end error.', err.stack || err.message || err);
	});

	const createWindow = () => {
		/** @type BrowserWindowConstructorOptions */
		let windowState;
		windowState = {
			webPreferences: {
				preload: path.join(__dirname, 'preload.js'),
				additionalArguments: [
					'--user-data-dir=' + path.join(os.tmpdir(), 'chrome-user-tmp-data')
					//"--wait-for-debugger"
				],
				webSecurity: false,
				backgroundThrottling: false
			},
			icon: './thing-editor/img/favicon.ico',
			//opacity: 0
		};

		mainWindow = getPositionRestoreWindow(windowState, 'main');

		mainWindow.setMenu(null);
		mainWindow.webContents.setWindowOpenHandler((event) => {
			shell.openExternal(event.url);
			return {action: 'deny'};
		});

		if (process.argv.some(a => a.startsWith('--build-and-exit'))) {
			mainWindow.webContents.addListener('console-message', (_event, _level, message, line, sourceId) =>{
				console.log('console-message:');
				console.log(message);
				console.log(sourceId);
				console.log(line);
			});
		}

		mainWindow.on('focus', () => {
			globalShortcut.register('F5', () => {
				if (!isClosingBlocked()) {
					mainWindow.reload();
				}
			});
			globalShortcut.register('CmdOrCtrl+Shift+I', () => {
				mainWindow.webContents.openDevTools();
			});
		});
		mainWindow.on('blur', () => {
			globalShortcut.unregisterAll();
		});

		mainWindow.on('close', (ev) => {
			if (isClosingBlocked()) {
				ev.preventDefault();
			}
		});

		nativeTheme.themeSource = 'dark';

		require('./server-fs.js')(mainWindow);

		const EDITOR_VITE_ROOT = 'http://localhost:5173/thing-editor/';
		const loadEditorIndexHTML = () => {
			mainWindow.setOpacity(1);
			mainWindow.loadURL(EDITOR_VITE_ROOT);
		};

		if (IS_DEBUG) {

			//let debuggerDetector = require('./debugger-detection');
			mainWindow.loadURL('http://localhost:5173/thing-editor/debugger-awaiter.html').catch((er) => {
				mainWindow.setOpacity(1);
				if (er.code === 'ERR_CONNECTION_REFUSED') {
					console.error('Could not load ' + EDITOR_VITE_ROOT + '.\nDoes vite.js server started?');
					dialog.showErrorBox('Thing-editor startup error.', 'Could not load ' + EDITOR_VITE_ROOT + '.\nDoes vite.js server started?');
				}
			});
			setTimeout(loadEditorIndexHTML, 600);
		} else {
			loadEditorIndexHTML();
		}
	};

	app.whenReady().then(() => {
		createWindow();

		app.on('activate', () => {
			if (BrowserWindow.getAllWindows().length === 0) createWindow();
		});
	});

	app.on('render-process-gone', (_event, _webContents, details) => {
		console.log('render-process-gone:');
		console.log(JSON.stringify(details));
		app.quit();
	});

	app.on('window-all-closed', () => {
		console.log('thing-editor exit');
		app.quit();
	});
})();
</file>

<file path="electron-main/launch-if-stopped.js">
const path = require('path');
const child_process = require('child_process');

const isWin = process.platform === 'win32';

let command = path.join(process.cwd(), './node_modules/.bin/electron');
if (isWin) {
	command = path.join(process.cwd(), './node_modules/electron/dist/electron.exe');
}

child_process.spawn(command,
	[
		'--remote-debugging-port=9223',
		'./thing-editor/electron-main',
		'debugger-detection-await'
	],
	{
		stdio: ['ignore', 'ignore', 'ignore'],
		detached: true,
		windowsHide: false,
		cwd: process.cwd()
	}
);
console.log('editor launched');
process.exit(0);
</file>

<file path="electron-main/package.json">
{
  "name": "vite-typescript-starter",
  "private": true,
  "version": "0.0.0"
}
</file>

<file path="electron-main/pixi-typings-patch.js">
// add vscode intellisense for injected methods

const IS_CI_RUN = process.env.IS_CI_RUN === 'true';

let patches = [];
const PATCH_BEGIN = ` // thing-editor patch begin
`;

patch(
	'node_modules/@pixi/display/lib/DisplayObject.d.ts',

	'export declare abstract class DisplayObject extends utils.EventEmitter<DisplayObjectEvents> {',
	`
    
    /** returns object rotation relative to it's scene */
    getGlobalRotation(): number;
    getScenePosition(resultPoint: Point, skipUpdate: boolean): Point;
    getRootContainer(): Container;
    detachFromParent(): void;
    /** call in only in your own init methods as super.init(); */
    init(): void;
    /** call in only in your own update methods as super.update(); */
    update(): void;
    /** remove object from scene */
    remove(): void;
    /** remove object from scene without placing empty object in place of it */
    removeWithoutHolder(): void;
    /** destructor */
    onRemove(): void;
    addFilter(filter: Filter): void;
    removeFilter(filter: Filter): void;
    gotoLabelRecursive(labelName: string): void;
    isCanBePressed: boolean;
    findParentByType<T extends Container>(classType: new () => T): T | null;
    findParentByName(name: string): Container;

    _onRenderResize?(): void;
	
	__prefabPivot?: import('thing-editor/src/editor/ui/viewport').PREFAB_PIVOT;

    /** search child recursively by it's name */
    findChildByName(name: string): Container | undefined;
    /** search all children of defined type recursively */
    findChildrenByType<T extends Container>(classType: new () => T): T[];
    /** search all children by name */
    findChildrenByName(name: string): Container[];
    forAllChildren(callback: (o: Container) => void): void;

    /** will be called when parent Trigger going to disabled state */
    _onDisableByTrigger?(): void;

    _thing_initialized: boolean;

    __beforeDeserialization?(): void;
    __beforeSerialization?(): void;
    __afterDeserialization?(): void;
   __treeInjection?(): import('preact').ComponentChild;
    __afterSerialization?(data: SerializedObject): void;
    __beforeDestroy?(): void;

    __EDITOR_onCreate?(isWrapping?: boolean): void;
	__EDITOR_filterPropsSelection(propertyName:string): boolean;
	static __EDITOR_filterPropsSelection(propertyName:string): boolean;

    __goToPreviewMode?(): void;
    __exitPreviewMode?(): void;
    __onSelect(): void;
    __onUnselect?(): void;
    __onChildSelected?(): void;
    __onIsMobileChange?(): void;
    __isAnyChildSelected(): boolean;

    __nodeExtendData: NodeExtendData;

    /** prevent object to be selected by viewport click. Editor only filed. */
    __doNotSelectByClick: boolean;

    /**hide children in editor TreeView window */
    __hideChildren?: boolean;
    __preventOverriding?: boolean;

    /** hide object in viewport during editor mode */
    __hideInEditor?: boolean;

    /** node description editable in PropertyEditor window */
    __description?: string;

    /** debug info about object (exists in editor only)*/
    ___info: string;

    /** debug uniq id of object  (exists in editor only)*/
    ___id: number;

	__shiftObject?(dX: number, dY: number): void;
	
    /** added because pixi exports classes with wrong names */
    static __className: string;

    /**
     * @deprecated name can be wrong for PIXI objects use __className instead
     */
    static name: string;
    static __sourceFileName?: string;
    static __defaultValues: KeyedObject;
    static __requiredComponents?: SourceMappedConstructor[];
    static __EDITOR_icon?: string;
    static __classAsset: import ( "thing-editor/src/editor/fs").FileDescClass;
    static __editableProps: EditablePropertyDesc[];
    static __editablePropsRaw: EditablePropertyDescRaw[];

    /** additional way to disable editable properties */
    static __isPropertyDisabled?: (p: EditablePropertyDesc) => string | undefined;
    static __EDITOR_tip?: string;
    static __isScene: boolean;
    static __sourceCode: string[];
    static __canAcceptParent?: (parent: Container) => boolean;
    static __canAcceptChild?: (Class: SourceMappedConstructor) => boolean;
    static __beforeChangeToThisType?: (o: Container) => void;
    static __validateObjectData?: (data: SerializedObjectProps) => SerializedDataValidationError;
	`);

patch(
	'node_modules/@pixi/sprite/lib/Sprite.d.ts',
	'export declare class Sprite extends Container {',
	`
	image: string;
	protected _imageID: string;

	__EDITOR_onCreate(isWrapping?: boolean): void;
	
	tintR: number;
	tintG: number;
	tintB: number;
	`);

patch(
	'node_modules/@pixi/mesh/lib/Mesh.d.ts',
	'export declare class Mesh<T extends Shader = MeshMaterial> extends Container {',
	`
	image: string;
	protected _imageID: string;

	tintR: number;
	tintG: number;
	tintB: number;

	`);

patch(
	'node_modules/@pixi/text/lib/Text.d.ts',
	'export declare class Text extends Sprite {',
	`
	setAlign(align:import('pixi.js').TextStyleAlign):void;
	translatableText: string | null;
	textTransform: number;
	maxWidth: number;
	static __touchedFonts:Map<string, number>;
	`);

patch(
	'node_modules/@pixi/display/lib/Container.d.ts',
	'replace',
	'readonly children: T[];',
	'    readonly children: Container[];',
	'getChildAt(index: number): T;',
	'    getChildAt(index: number): Container;',
	'removeChildAt(index: number): T;',
	'    removeChildAt(index: number): Container;',
);

patch(
	'node_modules/typescript/lib/typescript.js',
	'replace',
	'const isSearchPathInProjectRoot = () => containsPath(projectRootPath, searchPath, this.currentDirectory, !this.host.useCaseSensitiveFileNames);',
	'const isSearchPathInProjectRoot = () => false;',
);

function patch(fileName, ...findInserts) {
	patches.push({
		fileName,
		findInserts
	});
}


const path = require('path');
const fs = require('fs');
const {dialog} = require('electron');

function tryToPatch(folder) {
	for (let patch of patches) {
		let isReplace = false;
		var fn = path.join(folder, patch.fileName);
		if (fs.existsSync(fn)) {
			patch.done = true;
			let txt = fs.readFileSync(fn, 'utf8');
			if (txt.indexOf(PATCH_BEGIN) >= 0) {
				continue;
			}

			let findInserts = patch.findInserts;
			while (findInserts.length > 0) {

				let find = findInserts.shift();
				if (find === 'replace') {
					isReplace = true;
					find = findInserts.shift();
				}
				let insert = findInserts.shift();

				insert = (isReplace ? '' : find) + PATCH_BEGIN + insert + `
	// thing-editor patch end
`;

				if (txt.indexOf(find) >= 0) {
					txt = txt.replace(find, insert);
					fs.writeFileSync(fn, txt);
					console.log('PIXI typings patched: ' + fn);
				} else {
					console.error('PIXI typings patch "' + find + '" was not applied: ' + fn);
					if (mainWindow) {
						dialog.showMessageBoxSync(mainWindow, 'PIXI typing patch error', 'PIXI typings patch "' + find + '" was not applied: ' + fn);
					}
				}
			}
		}
	}
};
module.exports = function () {
	if (IS_CI_RUN) {
		return;
	}
	let projectRoot = path.join(__dirname, '../..');
	tryToPatch(path.join(__dirname, '..'));
	while (fs.existsSync(projectRoot)) {
		tryToPatch(projectRoot);
		let parentPath = path.join(projectRoot, '..');
		if (parentPath === projectRoot) {
			break;
		}
		projectRoot = parentPath;
	}
	for (let patch of patches) {
		if (!patch.done) {
			console.error('PIXI typings was not found: ' + patch.fileName);
			if (mainWindow) {
				dialog.showMessageBoxSync(mainWindow, 'PIXI typings was not found: ' + patch.fileName);
			}
		}
	}
};
</file>

<file path="electron-main/preload.js">
const {
	contextBridge,
	ipcRenderer
} = require('electron');

contextBridge.exposeInMainWorld(
	'electron_ThingEditorServer',
	{
		'versions': {
			platform: process.platform,
			node: process.versions.node,
			chrome: process.versions.chrome,
			electron: process.versions.electron
		},
		fs: (command, fileName, content, ...args) => {
			return ipcRenderer.sendSync('fs', command, fileName, content, ...args);
		},
		fsAsync: (command, fileName, content, ...args) => {
			return ipcRenderer.invoke('fs', command, fileName, content, ...args);
		},
		onServerMessage: (_onServerMessage) => {
			ipcRenderer.on('serverMessage', _onServerMessage);
		}
	}
);
</file>

<file path="electron-main/resolver/package.json">
{
  "name": "resolver",
  "version": "1.0.0",
  "description": "",
  "main": "resolver.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "vite-plugin",
    "resolver"
  ],
  "author": "",
  "license": "ISC"
}
</file>

<file path="electron-main/resolver/resolver.js">
const moduleImportFixer = /(^\s*import\s+[^"]*"[^"]+)(")/gm;

const IS_CI_RUN = process.env.IS_CI_RUN === 'true';

import path from 'path';

const gamesPath = path.join(__dirname, '../../../games').replaceAll('\\', '/') + '/';
const libsPath = path.join(__dirname, '../../../libs').replaceAll('\\', '/') + '/';

const queue = [];

if (IS_CI_RUN) {
	setInterval(() => {
		if (queue.length) {
			queue.shift()();
		}
	}, 50); // delay each response to prevent CI chrome crash
}

module.exports = {
	name: 'thing-editor:resolver',

	resolveId(id) {
		if (id.endsWith('thing-editor/src/editor/prefabs-typing')) {
			return 'thing-editor/src/editor/prefabs-typing';
		}
	},
	load(id) {
		if (id === 'thing-editor/src/editor/prefabs-typing') {
			return 'export default class TLib {}';
		}
	},

	configureServer(server) {
		if (IS_CI_RUN) {
			server.middlewares.use((_req, _res, next) => {
				queue.push(next);
			});
		}
	},
	transform(src, id) {
		if (id.includes('.ts?')) {
			let query = id.split('.ts?')[1];
			query = '?' + query;
			src = src.replace(moduleImportFixer, (_substr, m1, m2) => {
				if (!m1.includes('?')) {
					if (m1.includes('".')) { // relative imports treats games or libs if imported from games or libs
						if (id.startsWith(gamesPath) || id.startsWith(libsPath)) {
							return m1 + query + m2;
						}
					} else {
						if (m1.includes('"games/') || m1.includes('"libs/')) {
							return m1 + query + m2;
						}
					}
				}
				return _substr;
			});
		}

		return {
			code: src,
			map: null
		};
	}
};
</file>

<file path="electron-main/server-fs.js">
const {
	ipcMain,
	dialog,
	shell
} = require('electron');

const {
	walkSync
} = require('./editor-server-utils.js');
const {watchFolders} = require('./watch');
const fsOptions = {
	encoding: 'utf8'
};

const path = require('path');

const libsFolder = path.join( __dirname, '../../libs');

const fs = require('fs');
const enumProjects = require('./enum-projects');

const fn = (fileName) => {
	if (fileName.indexOf('..') >= 0) {
		throw new Error('Attempt to access files out of Thing-Editor root folder: ' + fileName);
	}
	return path.join(__dirname, '../..', fileName);
};

/** @param mainWindow {BrowserWindow} */
module.exports = (mainWindow) => {

	const ensureDirectoryExistence = (filePath) => {
		let dirname = path.dirname(filePath);
		if (fs.existsSync(fn(dirname))) {
			return true;
		}
		fs.mkdirSync(fn(dirname), {
			recursive: true
		});
	};

	const onFileChange = (path) => {
		mainWindow.webContents.send('serverMessage', 'fs/change', path);
	};

	const notify = (text) => {
		console.log(text);
		mainWindow.webContents.send('serverMessage', 'fs/notify', text);
	};

	ipcMain.handle('fs', async (_event, command, fileName, content, ...args) => {
		let isDebug;
		try {
			switch (command) {
			case 'fs/run':
				args[0].unshift(notify);
				const f = require(path.join('../..', fileName));
				const ret = await f.apply(null, ...args);
				return ret;
			case 'fs/build':
				isDebug = content;
				return await require('./build.js').build(fileName, isDebug, ...args);
			}
		} catch (er) {
			console.log(er.stack);
			console.error(er.stack);
			_event.returnValue = er.stack;
			return new Error(er.stack);
		}
	});

	ipcMain.on('fs', (event, command, fileName, content, ...args) => {
		let fd;
		let c;
		let success;
		let error;
		let buttons;
		let explorer;

		let ret;
		let assetsLoaderPath;

		try {
			switch (command) {
			case 'fs/delete':
				attemptFSOperation(() => {
					shell.trashItem(fn(fileName));
					return true;
				}, event);
				return;
			case 'fs/saveFile':
				attemptFSOperation(() => {
					ensureDirectoryExistence(fileName);
					const fileNameParsed = fn(fileName);
					fd = fs.openSync(fileNameParsed, 'w');
					if (content instanceof ArrayBuffer) {
						content = Buffer.from(content);
					}
					fs.writeSync(fd, content);
					fs.closeSync(fd, () => { }); // eslint-disable-line @typescript-eslint/no-empty-function
					return fs.statSync(fileNameParsed).mtimeMs;
				}, event);
				return;
			case 'fs/devTools':
				mainWindow.webContents.openDevTools();
				event.returnValue = true;
				return;
			case 'fs/log':
				console.log('FS-LOG: ' + fileName);
				event.returnValue = true;
				return;
			case 'fs/copyFile':
				attemptFSOperation(() => {
					const from = fn(fileName);
					const to = fn(content);
					ensureDirectoryExistence(content);
					fs.copyFileSync(from, to);
					return true;
				}, event);
				return;
			case 'fs/exists':
				event.returnValue = fs.existsSync(fn(fileName));
				return;
			case 'fs/readFileIfExists':
				if (fs.existsSync(fn(fileName))) {
					fd = fs.openSync(fn(fileName), 'r');
					c = fs.readFileSync(fd, fsOptions);
					fs.closeSync(fd, () => { }); // eslint-disable-line @typescript-eslint/no-empty-function
					event.returnValue = c;
				} else {
					event.returnValue = null;
				}
				return;
			case 'fs/setProgressBar':
				mainWindow.setProgressBar(fileName);
				mainWindow.__currentProgressOperation = content;
				mainWindow.__currentProgress = fileName;
				event.returnValue = null;
				return;
			case 'fs/readFile':
				fd = fs.openSync(fn(fileName), 'r');
				c = fs.readFileSync(fd, fsOptions);
				fs.closeSync(fd, () => { }); // eslint-disable-line @typescript-eslint/no-empty-function
				event.returnValue = c;
				return;
			case 'fs/readDir':
				if (!fs.existsSync(fileName)) {
					event.returnValue = [];
					return;
				}
				ret = walkSync(fileName, []);
				assetsLoaderPath = process.cwd() + '/' + fileName + 'assets-loader.cjs';
				if (fs.existsSync(assetsLoaderPath)) {
					require(assetsLoaderPath)(ret, content /* ProjectDesc */);
				}
				event.returnValue = ret;
				return;
			case 'fs/watchDirs':
				watchFolders(fileName, onFileChange);
				event.returnValue = true;
				return;
			case 'fs/isFilesEqual':
				event.returnValue = isFilesEqual(fn(fileName), fn(content));
				return;
			case 'fs/enumProjects':
				event.returnValue = enumProjects();
				return;
			case 'fs/getFileHash':
				event.returnValue = getFileHash(fn(fileName));
				return;
			case 'fs/exitWithResult':
				success = fileName;
				error = content;
				if (error) {
					console.log(error);
				} else if (success) {
					console.log(success);
				}
				//dialog.showMessageBox(mainWindow, 'process.exit', error || success);
				process.exit(error ? 1 : 0);
				return;
			case 'fs/showQuestion':
				buttons = Object.values(args).filter(b => b);
				event.returnValue = dialog.showMessageBoxSync(mainWindow, {
					title: fileName,
					message: content,
					buttons,
					defaultId: 0,
					cancelId: buttons.length - 1
				});
				return;
			case 'fs/browseDir':
				explorer;
				switch (require('os').platform()) {
				case 'win32': explorer = 'explorer'; break;
				case 'linux': explorer = 'xdg-open'; break;
				case 'darwin': explorer = 'open'; break;
				}
				require('child_process').spawn(explorer, [fn(fileName)], {detached: true}).unref();
				event.returnValue = true;
				return;
			case 'fs/showFile':
				shell.showItemInFolder(fn(fileName));
				event.returnValue = true;
				return;
			case 'fs/get-args':
				event.returnValue = process.argv;
				return;
			case 'fs/sounds-build':
				require('./build-sounds.js')(fileName).then((res) => {
					event.returnValue = res;
				});
				return;
			default:
				event.returnValue = new Error('unknown fs command: ' + command + ': ' + (fileName || ''));
				return;
			}
		} catch (er) {
			console.log('fs error: ' + er.stack);
			event.returnValue = er;
		}
	});
};


/** @param ev {Electron.IpcMainEvent} */
function attemptFSOperation(cb, ev) {
	let timeout = 20;

	const attempt = () => {
		try {
			let res = cb();
			ev.returnValue = res;
		} catch (er) {
			if (timeout-- > 0) {
				setTimeout(attempt, 1000);
			} else {
				ev.returnValue = er;
			}
		}
	};
	attempt();
}

let crypto;

const getFileHash = (fileName) => {
	if (!crypto) {
		crypto = require('crypto');
	}
	const hashSum = crypto.createHash('md5');
	const fileBuffer = fs.readFileSync(fileName);
	hashSum.update(fileBuffer);
	const ret = '' + hashSum.digest('base64');
	return ret.substring(0, 8).replaceAll('/', '_').replaceAll('+', '-').padStart('_', 8);
};

function isFilesEqual(a, b) {
	if (a === b) {
		return false; // the same file
	}

	const isSizeEqual = fs.statSync(a).size === fs.statSync(b).size;

	const checkOverridePrevention = !a.startsWith(libsFolder) && ( b.endsWith('.p.json') || b.endsWith('.s.json'));

	if (!checkOverridePrevention && !isSizeEqual) {
		return false;
	}

	const A = fs.readFileSync(a);
	const B = fs.readFileSync(b);
	if(checkOverridePrevention) {
		if(JSON.parse(B).p.__preventOverriding) {
			return 'Prohibited override.';
		}
	}
	return (isSizeEqual && A.equals(B)) ?'Override has no changes.': false;
}
</file>

<file path="electron-main/static-server.js">
var express = require('express');
var server = express();
server.use(express.static(__dirname + '/../..'));
server.listen(5174);
</file>

<file path="electron-main/thing-editor-window.js">
const { BrowserWindow } = require('electron');
const appConfig = require('electron-settings');

const IS_CI_RUN = process.env.IS_CI_RUN === 'true';

module.exports = function getPositionRestoreWindow(windowState, id) {
	const stateId = 'windowPosition-' + id;

	if (appConfig.has(stateId)) {
		windowState = Object.assign({}, appConfig.get(stateId), windowState);
	}

	const window = new BrowserWindow(windowState);

	if (IS_CI_RUN) {
		window.minimize();
	} else {
		if (windowState.isMaximized) {
			window.maximize();
		}
	}

	const saveWindowPos = () => {
		const windowState = window.getBounds();
		windowState.isMaximized = window.isMaximized();
		appConfig.set(stateId, windowState);
	};

	window.on('moved', saveWindowPos);
	window.on('maximize', saveWindowPos);
	window.on('resized', saveWindowPos);

	saveWindowPos();

	return window;
};
</file>

<file path="electron-main/vite-plugin-ifdef/if-def-loader.js">
const fileRegex = /\.(ts)$/;

const editorImportRegex = /^import.*((thing-editor\/src\/editor\/)|(from "preact"))/;

module.exports = function vitePluginIfDef(isDebug) {

	const processedFiles = [];

	return {
		name: 'vite-plugin-ifdef',
		enforce: 'pre',
		load(id) {
			if (id.indexOf('/thing-editor/src/editor/') >= 0) {
				let importPath = 'thing-editor/src/editor/' + id.split('/thing-editor/src/editor/')[1].replace(/\.ts$/, '');
				for (let a of processedFiles) {
					if (Array.isArray(a)) {
						if ((a.find(l => !l.startsWith('//') && l.indexOf(importPath) >= 0))) {
						}
					}
				}
				throw new Error('File ' + id + ' was included in to build.');
			}
			if (fileRegex.test(id)) {
				const src = require('fs').readFileSync(id, 'utf8');


				processedFiles.push(id);

				let a = src.split('\n');
				let cuttingStack = [];
				let cuttingLevel = 0;

				a = a.map((line, i) => {
					var trimmedLine = line.trim();

					if (trimmedLine.startsWith('@editable(') || (editorImportRegex.test(trimmedLine) && !trimmedLine.startsWith('import type'))) {
						return '///' + line;
					}

					if (trimmedLine.startsWith('assert(') && !isDebug) {
						return '///' + line;
					}

					if (trimmedLine === '/// #if EDITOR') {
						cuttingStack.push(trimmedLine);
						cuttingStack.push(i);
						cuttingLevel++;
					}

					if (trimmedLine === '/// #if DEBUG') {
						cuttingStack.push(trimmedLine);
						cuttingStack.push(i);
						if (!isDebug) {
							cuttingLevel++;
						}
					}

					if (trimmedLine === '/// #endif') {
						if (cuttingStack.length === 0) {
							throw new Error('/// #endif without /// #if EDITOR in file ' + id + ':' + (i + 1));
						}
						cuttingStack.pop();
						if (cuttingStack.pop() === '/// #if EDITOR' || !isDebug) {
							cuttingLevel--;
						}
					}

					if (cuttingLevel) {
						return '///' + line;
					}
					return line;
				});
				if (cuttingStack.length > 0) {
					const lineNum = cuttingStack.pop() + 1;
					throw new Error(cuttingStack.pop() + ' without /// #endif in file ' + id + ':' + lineNum);
				}

				processedFiles.push(a);

				return a.join('\n');
			}
			return null;
		}
	};
};
</file>

<file path="electron-main/vite-plugin-ifdef/package.json">
{
  "name": "vite-plugin-ifdef",
  "version": "1.0.0",
  "description": "",
  "main": "if-def-loader.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "vite-plugin",
    "ifdef-loader"
  ],
  "author": "",
  "license": "ISC"
}
</file>

<file path="electron-main/watch.js">
const currentWatchers = {};

const chokidar = require('chokidar');


function watchFolders(dirs, onEvent) {

	const _onEvent = (path) => {
		onEvent(path);
	};

	for (let dir in currentWatchers) {
		if (dirs.indexOf(dir) < 0) {
			currentWatchers[dir].close();
			delete currentWatchers[dir];
		}
	}

	for (let dir of dirs) {
		if (!currentWatchers[dir]) {
			const watcher = chokidar.watch(dir, {
				ignoreInitial: true,
				//	awaitWriteFinish: true,
				ignored: /.*___editor_backup_.*|.*(\/|^)~.*/ // ignore backups and ~ started files
			});

			watcher.on('add', _onEvent)
				.on('change', _onEvent)
				.on('unlink', _onEvent);
			currentWatchers[dir] = watcher;
		}
	}
}

module.exports = {watchFolders};
</file>

<file path="index.html">
<!DOCTYPE html>
<html>

<head><script>
	const filterDebug = (args) => {
		return args.some(a => a?.includes('[vite] '));
	};
	const originalDebug = console.debug;
	console.debug = (...args) => {
		if (!filterDebug(args)) {
			originalDebug.apply(console, args);
		}
	};
</script>
	<link rel="stylesheet" href="./src/editor/style.css">
	<link rel="stylesheet" href="./src/editor/style-timeline.css">
	<link rel="stylesheet" href="./src/editor/style-spine-sequence.css">
	<meta charset="UTF-8">
	<!--meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'"><-->
	<title>Thing Editor 2.0</title>
	<script type="module" src="./src/editor/warnings-filter.ts"></script>
	<script type="module" src="./src/editor/editor.ts"></script>
</head>

<body>
	<div id="root"></div>
	<div id="select-lists-root"></div>
	<div id="context-menu-root"></div>
</body>

</html>
</file>

<file path="src/editor/classes-loader.ts">
import wrapPropertyWithNumberChecker from 'thing-editor/src/editor/utils/number-checker';
import Lib from 'thing-editor/src/engine/lib';

import { Container, DisplayObject, Sprite, Text } from 'pixi.js';
import type { FileDescClass } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import { _editableEmbed, propertyAssert } from 'thing-editor/src/editor/props-editor/editable';
import PropsEditor from 'thing-editor/src/editor/ui/props-editor/props-editor';
import SelectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import { regenerateClassesTypings } from 'thing-editor/src/editor/utils/generate-editor-typings';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import ___GizmoArrow from 'thing-editor/src/engine/lib/assets/src/___system/gizmo-arrow.c';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import { StatusClearingCondition } from './ui/status-clearing-condition';

const EMBED_CLASSES_NAMES_FIXER: Map<any, string> = new Map();
EMBED_CLASSES_NAMES_FIXER.set(Container, 'Container');
EMBED_CLASSES_NAMES_FIXER.set(Sprite, 'Sprite');
EMBED_CLASSES_NAMES_FIXER.set(Text, 'Text');
EMBED_CLASSES_NAMES_FIXER.set(___GizmoArrow, '___GizmoArrow');

let componentsVersion = Date.now();

const NOT_SERIALIZABLE_PROPS_TYPES: Set<EditablePropertyType> = new Set();
NOT_SERIALIZABLE_PROPS_TYPES.add('btn');
NOT_SERIALIZABLE_PROPS_TYPES.add('ref');
NOT_SERIALIZABLE_PROPS_TYPES.add('splitter');


export default class ClassesLoader {

	static isClassesWaitsReloading: boolean;

	static async reloadClasses(): Promise<GameClasses | undefined> {

		componentsVersion++;
		game.editor.ui.status.clearByCondition(StatusClearingCondition.CLASSES_RELOAD);

		let files = fs.getAssetsList(AssetType.CLASS) as FileDescClass[];
		this.isClassesWaitsReloading = false;

		let oneClassNameFixed = false;

		return Promise.all(files.filter(f => f.assetName !== 'src/__beforeprojectopen').map((file): SourceMappedConstructor => {
			const onClassLoaded = (module: { default: SourceMappedConstructor }): SourceMappedConstructor => {
				const RawClass = module.default;
				if (!RawClass || !(RawClass.prototype instanceof DisplayObject)) {
					game.editor.editSource(file.fileName);
					if (!RawClass) {
						game.editor.showError('file ' + file.fileName + ' exports empty statement: ' + RawClass);
					} else {
						game.editor.showError('file ' + file.fileName + ' exports class which does not extend PIXI.Container: ' + RawClass.name);
					}
					game.editor.editSource(file.fileName);
					return null as any;
				}

				const Class: SourceMappedConstructor = RawClass;

				let instance: Container = new (Class as any)() as Container;

				let className: string = EMBED_CLASSES_NAMES_FIXER.has(Class) ? (EMBED_CLASSES_NAMES_FIXER.get(Class) as string) : Class.name;
				if (className.startsWith('_')) {
					if (
						(className.startsWith('_') && !file.fileName.includes('/_')) ||
						(className.startsWith('___') && !file.fileName.includes('/___')) ||
						(className.startsWith('__') && !file.fileName.includes('/__')) ||
						(className.startsWith('____') && !file.fileName.includes('/____'))
					) {
						oneClassNameFixed = true;
						className = className.substring(1);
					}
				}

				Class.__className = className;

				file.asset = Class;
				Class.__classAsset = file;

				Class.__sourceFileName = file.fileName;
				Class.__defaultValues = {};

				Class.__isScene = (instance instanceof Scene);

				if (!Class.hasOwnProperty('__editablePropsRaw')) {
					Class.__editablePropsRaw = [];
					assert(Class.hasOwnProperty('__editablePropsRaw'), 'Editable not own');
				}
				const editableProps: EditablePropertyDesc[] = Class.__editablePropsRaw as any;
				for (let prop of editableProps) {
					prop.class = Class;
					if (!prop.hasOwnProperty('type')) {
						let type = typeof (instance as KeyedObject)[prop.name];
						propertyAssert(prop, prop.override || type === 'string' || type === 'number' || type === 'boolean', 'can not detect type for editable property ' + prop.name);
						prop.type = type as EditablePropertyType;
					}

					if (prop.name.startsWith('___')) {
						prop.notSerializable = true;
					}

					if (!prop.noNullCheck && !prop.arrayProperty && (prop.type === 'number' || prop.type === 'color')) {
						wrapPropertyWithNumberChecker(Class, prop.name);
						prop.__nullCheckingIsApplied = true;
					}

					if (NOT_SERIALIZABLE_PROPS_TYPES.has(prop.type) || prop.name.startsWith('___')) {
						prop.notSerializable = true;
					}

					if (!prop.notSerializable) {
						if (!prop.hasOwnProperty('default')) {
							prop.default = (instance as KeyedObject)[prop.name];
							if (!prop.default) {
								prop.default = PropsEditor.getDefaultForType(prop);
							}
							if (Array.isArray(prop.default)) {
								prop.arrayProperty = true;
							}
							propertyAssert(prop, typeof prop.default !== 'undefined', 'Editable property \'' + prop.name + '\' in class \'' + Class.__className + '\' has no default value.');
						}
						Class.__defaultValues[prop.name] = prop.default;
					}

					if (prop.hasOwnProperty('min')) {
						propertyAssert(prop, prop.type === 'number', '\'min\' attribute possible for properties with \'number\' type only.');
						propertyAssert(prop, typeof prop.min === 'number', '\'min\' attribute should have number value.');
						propertyAssert(prop, prop.notSerializable || prop.default >= prop.min!, 'default value ' + prop.default + ' is less that \'min\' attribute ' + prop.min);
					}
					if (prop.hasOwnProperty('max')) {
						propertyAssert(prop, prop.type === 'number', '\'max\' attribute possible for properties with \'number\' type only.');
						propertyAssert(prop, typeof prop.max === 'number', '\'max\' attribute should have number value.');
						propertyAssert(prop, prop.notSerializable || prop.default <= prop.max!, 'default value ' + prop.default + ' is bigger that \'max\' attribute ' + prop.max);
					}
					if (prop.hasOwnProperty('step')) {
						propertyAssert(prop, prop.type === 'number', '\'step\' attribute possible for properties with \'number\' type only.');
						propertyAssert(prop, typeof prop.step === 'number', '\'step\' attribute should have number value.');
					}

					if (!prop.override) {
						if (prop.hasOwnProperty('select')) {
							prop.renderer = SelectEditor;
						} else {
							prop.renderer = PropsEditor.getRenderer(prop);
						}
					}
				}

				if ((Class.__editablePropsRaw.length < 1) || (Class.__editablePropsRaw[0].type !== 'splitter')) {
					_editableEmbed(Class, className + '-splitter', {
						type: 'splitter',
						name: className,
						title: className,
						notSerializable: true
					});
					Class.__editablePropsRaw.unshift(Class.__editablePropsRaw.pop()!);
				}

				return Class;
			};
			let moduleName = '../../..' + file.fileName.replace(/\.ts$/, '');

			const versionQuery = file.fileName.startsWith('/thing-editor/src/engine/lib/') ? undefined : ('?v=' + componentsVersion);
			if (versionQuery) {
				moduleName += '.ts' + versionQuery;
			}

			return imp(moduleName).then(onClassLoaded).catch((er:Error) => {
				game.editor.editSource(file.fileName, undefined, undefined, false, er);
				game.editor.showError(er?.stack, 30008);
			})as any;

		})).then((_classes: SourceMappedConstructor[]) => {

			let classes: GameClasses = {} as any;

			for (let c of _classes) {
				if (!c) {
					return;
				}
				const className = c.__className;

				if (classes[className]) {
					game.editor.editClassSource(c);
					game.editor.showError(R.div(null,
						'class ',
						R.b(null, className),
						'" (' + c.__sourceFileName + ') overrides existing class ',
						R.b(null, (classes[className].__sourceFileName)),
						'. Please change your class name.'), 30008);
				}
				classes[className] = c;

			}

			Lib._setClasses(classes);

			for (let c of _classes) {

				let superClass = c;

				const allProps: EditablePropertyDesc[] = [];
				while (superClass.__editablePropsRaw) {
					if (superClass.hasOwnProperty('__editablePropsRaw')) {
						allProps!.unshift.apply(allProps, superClass.__editablePropsRaw as any);
						Object.assign(c.__defaultValues, superClass.__defaultValues);
						if (allProps[0].name === '__root-splitter') {
							break;
						}
					}
					superClass = (superClass as any).__proto__;
				}

				const editableProps: EditablePropertyDesc[] = [];
				const existingProps: Set<string> = new Set();

				for (const thisProp of allProps) {
					if (existingProps.has(thisProp.name)) {
						const sameNamedPropIndex = editableProps.findIndex(p => p.name === thisProp.name);
						const existingProp = editableProps[sameNamedPropIndex];
						if (!thisProp.override) {
							game.editor.editSource(thisProp.__src);
							game.editor.ui.modal.showError('Redefinition of property "' + thisProp.name + '" at class ' + superClass.__className + '. Already defined at: ' + existingProp.__src, 40004);
						} else {

							editableProps[sameNamedPropIndex] = Object.assign({}, existingProp, thisProp);
							if (thisProp.hasOwnProperty('default')) {
								c.__defaultValues[thisProp.name] = thisProp.default;
							}
						}
					} else {
						editableProps.push(thisProp);
						existingProps.add(thisProp.name);
					}
				}

				c.__editableProps = editableProps;

				if (!c.hasOwnProperty('__EDITOR_icon')) {
					if (c.prototype instanceof MovieClip) {
						c.__EDITOR_icon = 'tree/movie-custom';
					} else {
						c.__EDITOR_icon = 'tree/game';
					}
				}
			}
			regenerateClassesTypings();
			if (!oneClassNameFixed) {
				game.editor.ui.status.warn('class name fixing and __className field is not necessary anymore.');
			}
			return classes;
		});
	}
}

// vite dynamic imports broke sourcemaps lines; Thats why import moved to the bottom of the file.
const imp = (moduleName: string) => {
	if (moduleName.includes('?')) {
		return import(/* @vite-ignore */ `${moduleName}`);
	} else {
		return import(/* @vite-ignore */ `${moduleName}.ts`);
	}
};
</file>

<file path="src/editor/current-classes-typings.ts">
// thing-editor auto generated file.
import type PipeSpawner from 'games/dear-project/assets/src/custom/pipe-spawner.c';
import type PipesContainer from 'games/dear-project/assets/src/custom/pipes-contaner.c';
import type BunnyGameSceneLogic from 'games/dear-project/assets/src/custom/bunny-game-scene-logic.c';
import type DynamicFill from 'games/dear-project/assets/src/custom/dynamic-fill.c';
import type DynamicText from 'games/dear-project/assets/src/custom/dynamic-text.c';
import type Bunny from 'games/dear-project/assets/src/custom/bunny.c';
import type MyNewScene from 'libs/example-lib/assets/src/custom/my-new-scene.c';
import type Dear_game from 'libs/example-lib/assets/src/dear_game.c';
import type BgMusic from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music.c';
import type BackDrop from 'thing-editor/src/engine/lib/assets/src/basic/back-drop.c';
import type BitmapText from 'thing-editor/src/engine/lib/assets/src/basic/bitmap-text.c';
import type Button from 'thing-editor/src/engine/lib/assets/src/basic/button.c';
import type ClickOutsideTrigger from 'thing-editor/src/engine/lib/assets/src/basic/click-outside-trigger.c';
import type Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';
import type DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import type Fill from 'thing-editor/src/engine/lib/assets/src/basic/fill.c';
import type FlyText from 'thing-editor/src/engine/lib/assets/src/basic/fly-text.c';
import type MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type MultilineText from 'thing-editor/src/engine/lib/assets/src/basic/multiline-text.c';
import type NineSlicePlane from 'thing-editor/src/engine/lib/assets/src/basic/nine-slice-plane.c';
import type ParticleContainer from 'thing-editor/src/engine/lib/assets/src/basic/particle-container.c';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import type SpawnerRing from 'thing-editor/src/engine/lib/assets/src/basic/spawner-ring.c';
import type Spawner from 'thing-editor/src/engine/lib/assets/src/basic/spawner.c';
import type Sprite from 'thing-editor/src/engine/lib/assets/src/basic/sprite.c';
import type StaticTrigger from 'thing-editor/src/engine/lib/assets/src/basic/static-trigger.c';
import type Text from 'thing-editor/src/engine/lib/assets/src/basic/text.c';
import type OrientationParentResizer from 'thing-editor/src/engine/lib/assets/src/common/ui/orientation-parent-resizer.c';
import type ParentResizer from 'thing-editor/src/engine/lib/assets/src/common/ui/parent-resizer.c';
import type ParticleShort from 'thing-editor/src/engine/lib/assets/src/custom/particle-short.c';
import type HTMLOverlay from 'thing-editor/src/engine/lib/assets/src/extended/html-overlay.c';
import type IsMobileTrigger from 'thing-editor/src/engine/lib/assets/src/extended/is-mobile-trigger.c';
import type Label from 'thing-editor/src/engine/lib/assets/src/extended/label.c';
import type LayeredContainer from 'thing-editor/src/engine/lib/assets/src/extended/layered-container.c';
import type LayeredContainerPortal from 'thing-editor/src/engine/lib/assets/src/extended/layered-contaiter-portal.c';
import type Mask from 'thing-editor/src/engine/lib/assets/src/extended/mask.c';
import type ProgressBar from 'thing-editor/src/engine/lib/assets/src/extended/progress-bar.c';
import type Resizer from 'thing-editor/src/engine/lib/assets/src/extended/resizer.c';
import type ScrollLayer from 'thing-editor/src/engine/lib/assets/src/extended/scroll-layer.c';
import type Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';
import type Spine from 'thing-editor/src/engine/lib/assets/src/extended/spine.c';
import type Trigger from 'thing-editor/src/engine/lib/assets/src/extended/trigger.c';
import type UnPausableContainer from 'thing-editor/src/engine/lib/assets/src/extended/unpausable-container.c';
import type OrientationTrigger from 'thing-editor/src/engine/lib/assets/src/mobile/orientation-trigger.c';
import type __SystemBackDrop from 'thing-editor/src/engine/lib/assets/src/___system/backdrop.c';
import type _Delay from 'thing-editor/src/engine/lib/assets/___system/delay.c';
import type _SceneLinkedPromise from 'thing-editor/src/engine/lib/assets/___system/scene-linked-promise.c';

declare global {

export interface GameClasses {
[key: string]: SourceMappedConstructor;
'PipeSpawner': typeof PipeSpawner;
'PipesContainer': typeof PipesContainer;
'BunnyGameSceneLogic': typeof BunnyGameSceneLogic;
'DynamicFill': typeof DynamicFill;
'DynamicText': typeof DynamicText;
'Bunny': typeof Bunny;
'MyNewScene': typeof MyNewScene;
'Dear_game': typeof Dear_game;
'BgMusic': typeof BgMusic;
'BackDrop': typeof BackDrop;
'BitmapText': typeof BitmapText;
'Button': typeof Button;
'ClickOutsideTrigger': typeof ClickOutsideTrigger;
'Container': typeof Container;
'DSprite': typeof DSprite;
'Fill': typeof Fill;
'FlyText': typeof FlyText;
'MovieClip': typeof MovieClip;
'MultilineText': typeof MultilineText;
'NineSlicePlane': typeof NineSlicePlane;
'ParticleContainer': typeof ParticleContainer;
'Scene': typeof Scene;
'SpawnerRing': typeof SpawnerRing;
'Spawner': typeof Spawner;
'Sprite': typeof Sprite;
'StaticTrigger': typeof StaticTrigger;
'Text': typeof Text;
'OrientationParentResizer': typeof OrientationParentResizer;
'ParentResizer': typeof ParentResizer;
'ParticleShort': typeof ParticleShort;
'HTMLOverlay': typeof HTMLOverlay;
'IsMobileTrigger': typeof IsMobileTrigger;
'Label': typeof Label;
'LayeredContainer': typeof LayeredContainer;
'LayeredContainerPortal': typeof LayeredContainerPortal;
'Mask': typeof Mask;
'ProgressBar': typeof ProgressBar;
'Resizer': typeof Resizer;
'ScrollLayer': typeof ScrollLayer;
'Shape': typeof Shape;
'Spine': typeof Spine;
'Trigger': typeof Trigger;
'UnPausableContainer': typeof UnPausableContainer;
'OrientationTrigger': typeof OrientationTrigger;
'__SystemBackDrop': typeof __SystemBackDrop;
'_Delay': typeof _Delay;
'_SceneLinkedPromise': typeof _SceneLinkedPromise;
}
}
</file>

<file path="src/editor/current-scene-typings.ts">
// thing-editor auto generated file.

import type { Container } from 'pixi.js';
import type BunnyGameSceneLogic from 'games/dear-project/assets/src/custom/bunny-game-scene-logic.c';
import type OrientationTrigger from 'thing-editor/src/engine/lib/assets/src/mobile/orientation-trigger.c';
import type Fill from 'thing-editor/src/engine/lib/assets/src/basic/fill.c';
import type PipeSpawner from 'games/dear-project/assets/src/custom/pipe-spawner.c';
import type Text from 'thing-editor/src/engine/lib/assets/src/basic/text.c';

declare global {
type CurrentSceneType = BunnyGameSceneLogic;

interface ThingSceneAllMap {
	[key: string]: Container;
'backgroundTrigger': OrientationTrigger;
'backgroundFill': Fill;
'pipesTrigger': OrientationTrigger;
'pipes': PipeSpawner;
'counterLabelTrigger': OrientationTrigger;
'counterLabel': Text;
'counterTextTrigger': OrientationTrigger;
'counterText': Text;
'gameOverTextTrigger': OrientationTrigger;
'GameOverText': Text;
}
}
</file>

<file path="src/editor/editor-env.ts">
/* eslint-disable @typescript-eslint/consistent-type-imports */
/// <reference types="vite/client" />

import { ComponentChild } from 'preact';

declare global {
	type CallBackPath = string;
	type ValuePath = string;
	type CallBackParsedData = {
		/** callback path names*/
		p: (string | { c: string /** child name to getChildByName */})[];
		/** callback parameter */
		v?: any[];
	};

	interface EditableRect {
		x: number;
		y: number;
		w: number;
		h: number;
	}

	type EditablePropertyType = keyof IEditablePropertyType;


	type SerializedDataValidationError = undefined | {
		message: string;
		findObjectCallback: ((o: import('pixi.js').Container) => boolean | undefined);
		fieldName?: string;
		errorCode?: number;
	};

	type SerializedObjectProps = KeyedObject;

	interface EditablePropertyDesc<T extends import('pixi.js').Container = import('pixi.js').Container> extends EditablePropertyDescRaw<T> {
		class: SourceMappedConstructor;
		type: EditablePropertyType;
		default: any;
		name: string;
		__src: string;
		__nullCheckingIsApplied?: true;
		renderer?: any;
	}

	interface EditablePropertyDescRaw<T extends import('pixi.js').DisplayObject = import('pixi.js').DisplayObject> {
		min?: number;
		max?: number;
		step?: number;
		type?: EditablePropertyType;
		name?: string;
		basis?: number;
		default?: any;
		canBeEmpty?: false;
		visible?: (o: T) => boolean;
		helpUrl?: string;
		/** field changes pass vale through this function  */
		parser?: (val: any) => any;
		disabled?: (o: T) => string | undefined | boolean | null;
		beforeEdited?: (val: any) => void | true | string;
		onBlur?: () => void;
		onClick?: (ev: any) => void;
		className?: string;
		hotkey?: import('./utils/hotkey').Hotkey;

		/** filter assets for selector */
		filterAssets?: (file: import('./fs').FileDesc) => boolean;

		/** splitter header */
		title?: string;
		animate?: true;
		select?: import('./ui/props-editor/props-editors/select-editor').SelectEditorItem[] | (() => import('./ui/props-editor/props-editors/select-editor').SelectEditorItem[]);
		noNullCheck?: true;
		important?: boolean;
		tip?: string | (() => string | undefined);
		afterEdited?: (val: any) => void;
		multiline?: boolean;
		notSerializable?: true;
		override?: true;
		filterName?: string;
		arrayProperty?: true;
		defaultArrayItemValue?: any;
		separator?: true;

		guideColor?: number;

		rectScaleIgnore?: true;

		rect_minX?: number;
		rect_maxX?: number;
		rect_minY?: number;
		rect_maxY?: number;
		rect_minW?: number;
		rect_maxW?: number;
		rect_minH?: number;
		rect_maxH?: number;

		/** call-back and data-path properties validator */
		isValueValid?: (val: any) => boolean;
	}

	type SourceMappedConstructor = typeof import('pixi.js').DisplayObject;

	type KeyedObject = { [key: string]: any };

	interface NodeExtendData {
		hidden?: true;

		childrenExpanded?: boolean;

		deepness?: number;
		isSelected?: boolean;

		treeNodeView?: import('./ui/tree-view/tree-node').default;

		/** defined in editor time only */
		isPrefabReference?: string;

		constructorCalled?: boolean;

		/** unknown constructor's name */
		unknownConstructor?: string;
		unknownConstructorProps?: SerializedObjectProps;

		/** unknown prefabs's name */
		unknownPrefab?: string;
		unknownPrefabProps?: SerializedObjectProps;

		__deserializedFromPrefab?: string;

		component_in_previewMode?: boolean;

		noSerialize?: boolean;

		/** hide this object because of isolation mode */
		isolate?: boolean;

		serializationCache?: SerializedObject;

		isFaderShootCalledForThisFader?: boolean;

		hidePropsEditor?: {
			title: string;
			visibleFields: KeyedMap<true>;
		};

		tmpGlobalPos?: import('pixi.js').Point;

		statusWarnOwnerId?: number;

		objectDeleted?: string;

		__allRefsDeletionValidator?: number;

		__isJustCloned?: boolean;

		__isPreviewMode?: boolean;

		__pathBreakpoint?: any;

		isTypeChanging?: boolean;

		eatenRotation?: number;
	}

	type SerializedObject = {
		/** constructor class name */
		c?: string;

		/** prefab reference name */
		r?: string;

		__lastTouch?: number;

		p: SerializedObjectProps;
		':'?: SerializedObject[] | undefined;
	};

	type KeyedMap<T> = {
		[key: string]: T;
	};

	/** signals for DataPathChooser and CallbackPathChooser */
	interface SelectableProperty extends AnyType {
		___EDITOR_isHiddenForChooser?: true;
		___EDITOR_rejectionReason?: string;
		___EDITOR_isHiddenForCallbackChooser?: true;
		___EDITOR_isHiddenForDataChooser?: true;
		___EDITOR_isGoodForChooser?: true;
		___EDITOR_isGoodForCallbackChooser?: true;
		___EDITOR_ChooserOrder?: number;
		___EDITOR_actionIcon?: ComponentChild;
		___EDITOR_callbackParameterChooserFunction?: (owner: any) => Promise<any[] | any>;
		___EDITOR_argumentsTip?: string[];
	}
}

export type FSCallback = Uint8Array | undefined | import('./fs').FileDesc[] | ProjectDesc[] | number | boolean;


export interface ClipboardAsset {
	name: string;
	type: import ('./fs').AssetType;
	l10n?: L10nEntryAsset;
	files: string[];
}

export type L10nEntryAsset = [key: string, text: KeyedMap<string>, projectPrefix?: string];

export interface IEditablePropertyType {
	'data-path': true;
	'splitter': true;
	'rect': true;
	'callback': true;
	'l10n': true;
	'timeline': true;
	'ref': true;
	'btn': true;
	'color': true;
	'boolean': true;
	'string': true;
	'prefab': true;
	'pow-damp-preset': true;
	'spine-sequence': true;
	'number': true;
	'image': true;
	'sound': true;
	'resource': true;
}

export interface IGoToLabelConsumer {
	gotoLabel(label: string): void;
	gotoLabelRecursive(label: string): void;
	__getLabels():undefined | string[];
}

export type AnyType = any;

/** sound name, duration */
export type SoundAssetEntry = [soundName: string, duration: number];

export interface AssetsDescriptor {
	scenes: KeyedMap<SerializedObject>;
	prefabs: KeyedMap<SerializedObject>;
	images: string[];
	resources?: string[];
	xmls?: string[];
	fonts?: string[];
	sounds: SoundAssetEntry[];
	text?: KeyedObject;
	projectDesc?: ProjectDesc;
}
</file>

<file path="src/editor/editor.ts">
import R from './preact-fabrics';

import game, { loadFonts } from '../engine/game';

import type { Component, ComponentChild } from 'preact';
import { h, render } from 'preact';
import type { FileDesc, FileDescClass, LibInfo } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import UI from 'thing-editor/src/editor/ui/ui';
import historyInstance from 'thing-editor/src/editor/utils/history';
import protectAccessToSceneNode from 'thing-editor/src/editor/utils/protect-access-to-node';
import type { SelectionData } from 'thing-editor/src/editor/utils/selection';
import Selection from 'thing-editor/src/editor/utils/selection';
import Lib from 'thing-editor/src/engine/lib';
import Settings from 'thing-editor/src/engine/utils/settings';
import ClassesLoader from './classes-loader';

import LanguageView from 'thing-editor/src/editor/ui/language-view';

import type { Point } from 'pixi.js';
import { Container, Texture } from 'pixi.js';

import AssetsView from 'thing-editor/src/editor/ui/assets-view/assets-view';
import type { ChooseListItem } from 'thing-editor/src/editor/ui/choose-list';
import LocalStoreView from 'thing-editor/src/editor/ui/local-store-view';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import 'thing-editor/src/editor/ui/sound-profiler';
import debouncedCall from 'thing-editor/src/editor/utils/debounced-call';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import EDITOR_FLAGS, { EDITOR_BACKUP_PREFIX } from 'thing-editor/src/editor/utils/flags';
import regenerateCurrentSceneMapTypings, { regeneratePrefabsTypings } from 'thing-editor/src/editor/utils/generate-editor-typings';
import { libIcon } from 'thing-editor/src/editor/utils/lib-info';
import mergeProjectDesc, { isProjectDescValueKeyedMap } from 'thing-editor/src/editor/utils/merge-project-desc';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import { __UnknownClass } from 'thing-editor/src/editor/utils/unknown-class';
import validateObjectDataRecursive from 'thing-editor/src/editor/utils/validate-serialized-data';
import type HowlSound from 'thing-editor/src/engine/HowlSound';
import assert from 'thing-editor/src/engine/debug/assert';
import { __UnknownClassScene } from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import waitForCondition from 'thing-editor/src/engine/lib/assets/src/utils/wait-for-condition';
import Pool from 'thing-editor/src/engine/utils/pool';
import Sound from 'thing-editor/src/engine/utils/sound';
import type WebFont from 'webfontloader';
import Build from './utils/build';

import { rootAudioContext } from 'thing-editor/src/engine/HowlSound';
import Spine from '../engine/lib/assets/src/extended/spine.c';
import './../engine/lib/assets/src/basic/container.c'; // import to patch prototypes before NaN checking applied.
import './../engine/lib/assets/src/basic/sprite.c'; // import to patch prototypes before NaN checking applied.
import './../engine/lib/assets/src/basic/text.c'; // import to patch prototypes before NaN checking applied.
import type { ContextMenuItem } from './ui/context-menu';
import MainMenu from './ui/main-menu';
import { StatusClearingCondition } from './ui/status-clearing-condition';
import roundUpPoint from './utils/round-up-point';

const LAST_SCENE_NAME = '__EDITOR_last_scene_name';

const editorMuteSoundNode = rootAudioContext.createGain();
Sound.addMasterNode(editorMuteSoundNode);
const applySoundMuting = () => {
	editorMuteSoundNode.gain.setValueAtTime(game.editor.settings.getItem('sound-muted') ? 0 : 1, rootAudioContext.currentTime);
};

const parseLibName = (name: string): LibInfo => {
	let dir;
	if (name.startsWith('.')) {
		dir = new URL(name, window.location.origin + '/' + game.editor.currentProjectDir).pathname.substring(1);
	} else {
		dir = 'libs/' + name;
	}
	return {
		libNum: 0,
		name,
		dir,
		assetsDir: dir + '/assets/'
	};
};

import.meta.hot?.on('vite:beforeFullReload', (ev: any) => { //disable vite.hmr full reload
	ev.path = 'vite please, do not reload anything.html';
});

let previewedSound: HowlSound | null;

interface RecentProject {
	dir: string;
	icon: string;
	title: string;
}

class Editor {

	LanguageView = LanguageView;
	LocalStoreView = LocalStoreView;

	currentProjectDir = '';
	currentProjectAssetsDir = '';
	currentProjectAssetsDirRooted = '';
	assetsFolders!: string[];
	assetsFoldersReversed!: string[];
	libsDescriptors: KeyedMap<ProjectDesc> = {};
	libsDescriptorsRaw: KeyedMap<string> = {};

	editorArguments: KeyedMap<true | string> = {};
	projectDesc!: ProjectDesc;
	projectDescRaw!: string;

	selection = new Selection();

	settings: Settings = new Settings('editor');
	settingsLocal!: Settings;

	showGizmo: boolean = this.settings.getItem('show-gizmo', true);

	isSafeAreaVisible = true;

	disableFieldsCache = false;

	history = historyInstance;

	_lastChangedFiledName: string | null = null;

	savedBackupName?: string | null;
	savedBackupSelectionData?: SelectionData;

	/** editor space mouse coord X */
	mouseX = 0;
	/** editor space mouse coord Y */
	mouseY = 0;

	ui!: UI;

	/** true when editor blocked fatally with un-closable error */
	__FatalError = false;

	restartInProgress = false;

	isProjectOpen = false;

	currentPathChoosingField?: EditablePropertyDesc;

	currentProjectLibs!: LibInfo[];

	get makeVisibleAll() { /// 99999
		return game.keys.altKey;
	}

	// set or delete properties to override them in game.projectDesc embedded in to build.
	forceProjectDescPropsInBuild = {} as Partial<ProjectDesc>;

	constructor() {
		const args = fs.getArgs();
		for (let arg of args) {
			if (arg.startsWith('--') && arg.indexOf('=') > 0) {
				const a = arg.split('=');
				this.editorArguments[a[0].substring(2)] = a[1];
			} else {
				this.editorArguments[arg] = true;
			}
		}

		this.onUIMounted = this.onUIMounted.bind(this);
		game.editor = this;
		fs.setProgressBar(-1);
		if (this.buildProjectAndExit) {
			this.editorArguments['no-vscode-integration'] = true;
			window.addEventListener('error', (er) => {
				fs.log('unhandled error:');
				fs.exitWithResult(undefined, er.error.stack);
			});
			window.addEventListener('unhandledrejection', (er) => {
				fs.log('unhandled rejection:');
				fs.exitWithResult(undefined, er.reason.stack);
			});

			setInterval(() => {
				if (document.querySelector('vite-error-overlay')) {
					fs.log('VITE OVERLAY:');
					fs.log(document.querySelector('vite-error-overlay')!.textContent!);
					fs.exitWithResult(undefined, 'vite-error-overlay show');
				}
			}, 1000);
			R.icon = (() => {}) as any;
			R.imageIcon = (() => {}) as any;
			R.img = (() => {}) as any;
			game.editor.settings.setItem('sound-muted', true);
		}

		this.setIsMobileAny(game.editor.settings.getItem('isMobile.any', false));

		game.__EDITOR_mode = true;
		render(h(UI, { onUIMounted: this.onUIMounted }), document.getElementById('root') as HTMLElement);

		this.__saveProjectDescriptorInner = this.__saveProjectDescriptorInner.bind(this);
		this.editProperty = this.editProperty.bind(this);
		this.reloadClasses = this.reloadClasses.bind(this);
	}

	onUIMounted(ui: UI) {
		this.ui = ui;
		// load built in components

		fs.log('buildProjectAndExit: ' + this.buildProjectAndExit);

		if (this.buildProjectAndExit) {
			this.settings.setItem('last-opened-project', this.buildProjectAndExit);
		}

		if (this.settings.getItem('last-opened-project')) {
			this.loadProject(this.settings.getItem('last-opened-project'));
		} else {
			this.chooseProject(true);
		}

		window.onbeforeunload = (e) => {
			if (!this.restartInProgress && !this.__FatalError) {
				if (this.askSceneToSaveIfNeed() === false) {
					e.returnValue = false;
				}
			}
		};

		window.setInterval(() => { //keep props editor and tree actual during scene is launched
			if (EDITOR_FLAGS.updateInProgress) {
				EDITOR_FLAGS.updateInProgress = false;
				editor.ui.modal.showFatalError(R.fragment('Exception during update().'), 99999);
			}
			if (!game.__EDITOR_mode && !game.__paused) {
				this.refreshTreeViewAndPropertyEditor();
			}
		}, 300);
	}

	get isCurrentSceneModified() {
		assert(game.__EDITOR_mode, 'access to isCurrentSceneModified in running mode.');
		return this.isCurrentContainerModified;
	}

	get isCurrentContainerModified() {
		return this.history.isStateModified;
	}

	async reloadClasses() {
		this.ui.modal.showSpinner();
		let restorePrefabName = PrefabEditor.currentPrefabName;
		let needRestoring = !restorePrefabName && game.__EDITOR_mode && game.editor.isCurrentContainerModified;
		if (needRestoring) {
			this.saveBackup();
		}
		this.ui.viewport.stopExecution();
		editorEvents.emit('willClassesReload');
		EDITOR_FLAGS.__classesReloadingTime = true;
		(editorEvents as any).__removeUserHandlers();
		await ClassesLoader.reloadClasses();
		EDITOR_FLAGS.__classesReloadingTime = false;
		if (restorePrefabName) {
			PrefabEditor.editPrefab(restorePrefabName);
		}
		if (needRestoring) {
			this.restoreBackup();
		}
		editor.ui.refresh();
		editorEvents.emit('didClassesReloaded');
		this.ui.modal.hideSpinner();
	}

	onEditorRenderResize() {
		this.refreshTreeViewAndPropertyEditor();
		this.ui.viewport.forceUpdate();
	}

	saveBackup() {
		if (!this.isCurrentSceneModified) {
			return;
		}
		this.saveCurrentScene(this.currentSceneBackupName);
	}

	restoreBackup() {
		const backupName = this.currentSceneBackupName;
		if (Lib.hasScene(backupName)) {
			this.openScene(backupName);
			this.removeBackup();
			this.history.setCurrentStateModified();
		} else {
			this.openScene(this.currentSceneName);
		}
	}

	removeBackup() {
		if (Lib.hasScene(this.currentSceneBackupName)) {
			Lib.__deleteScene(this.currentSceneBackupName);
		}
	}

	editProperty(field: EditablePropertyDesc | string, val: any, delta?: boolean) {
		if (this.selection.length > 0) {

			if (typeof field === 'string') {
				field = this.getObjectField(this.selection[0], field);
			}

			assert(this.ui.propsEditor.editableProps[field.name], 'Property is disabled.');

			const blocked = field.beforeEdited && field.beforeEdited(val);
			if (blocked) {
				if (typeof blocked === 'string') {
					editor.ui.modal.notify(blocked);
				}
				return;
			}

			for (let o of this.selection) {
				this.onObjectsPropertyChanged(o, field, val, delta);
			}
			if (field.afterEdited) {
				field.afterEdited(val);
			}
		}
	}

	getObjectField(o: Container, name: string): EditablePropertyDesc {
		const ret = (o.constructor as SourceMappedConstructor).__editableProps.find((f) => {
			return f.name === name;
		}) as EditablePropertyDesc;
		assert(ret, 'Unknown editable propery name: ' + name);
		return ret;
	}

	chooseProject(notSkipable = false) {
		import('thing-editor/src/editor/ui/choose-project').then((ProjectsList) => {
			ProjectsList.default.__chooseProject(notSkipable).then((dir: string) => {
				if (dir) {
					this.openProject(dir);
				}
			});
		});
	}

	openProject(dir:string) {
		if (this.askSceneToSaveIfNeed()) {
			this.settings.setItem('last-opened-project', dir);
			this.restartInProgress = true;
			window.document.location.reload();
		}
	}

	pauseGame() {
		if (!game.__paused && !game.__EDITOR_mode) {
			game.__paused = true;
			this.ui.viewport.refresh();
		}
	}

	get buildProjectAndExit(): string | undefined {
		return this.editorArguments['build-and-exit'] as string;
	}

	async loadProject(dir?: string) {

		const spineLoading = Spine._loadSpineRuntime();

		this.ui.viewport.stopExecution();

		if (!dir) {
			this.chooseProject(true);
			return;
		}
		const newProjectDir = 'games/' + dir + '/';

		if (newProjectDir !== this.currentProjectDir) {
			this.currentProjectDir = newProjectDir;
			this.currentProjectAssetsDir = this.currentProjectDir + 'assets/';
			this.currentProjectAssetsDirRooted = '/' + this.currentProjectAssetsDir;

			this.ui.modal.showSpinner();
			this.settings.removeItem('last-opened-project');

			const projectDesc = fs.readJSONFile(this.currentProjectDir + 'thing-project.json') as ProjectDesc;
			this.projectDescRaw = JSON.stringify(projectDesc);

			if (!projectDesc) {
				this.ui.modal.showError('Can\'t open project ' + dir).then(() => { this.chooseProject(true); });
				return;
			}
			projectDesc.dir = this.currentProjectDir;
			if (!projectDesc.libs) {
				projectDesc.libs = [];
			}

			this.settingsLocal = new Settings('__EDITOR_project_' + projectDesc.id);

			const libsProjectDescMerged = {} as ProjectDesc;

			this.currentProjectLibs = projectDesc.libs.map(parseLibName);
			this.currentProjectLibs.unshift({
				name: 'thing-editor-embed',
				libNum: 0,
				dir: 'thing-editor/src/engine/lib',
				assetsDir: 'thing-editor/src/engine/lib/assets/',
				isEmbed: true
			});
			this.assetsFolders = [];

			const schemas: any[] = [];

			let libNum = 0;
			for (let lib of this.currentProjectLibs) {
				lib.libNum = libNum++;
				this.assetsFolders.push(lib.assetsDir);
				const libFileName = lib.dir + '/thing-lib.json';
				try {
					this.libsDescriptors[lib.name] = fs.readJSONFile(libFileName);
					this.libsDescriptorsRaw[lib.name] = JSON.stringify(this.libsDescriptors[lib.name]);
				} catch (er: any) {
					editor.ui.modal.showFatalError('Library loading error. Is "libs" option in "thing-projects.json" correct?', 99999, er.message);
					return;
				}
				mergeProjectDesc(libsProjectDescMerged, this.libsDescriptors[lib.name]);
				if (!this.buildProjectAndExit) {
					const libSchema = fs.readJSONFileIfExists(lib.dir + '/schema-thing-project.json');
					if (libSchema) {
						schemas.push(libSchema);
					}
				}
			}
			if (!this.buildProjectAndExit) {
				const libSchema = fs.readJSONFileIfExists(this.currentProjectDir + '/schema-thing-project.json');
				if (libSchema) {
					schemas.push(libSchema);
				}
			}

			if (schemas.length) {
				const mergedSchema = schemas[0];
				for (const schema of schemas) {
					if (schema !== mergedSchema) {
						Object.assign(mergedSchema.properties, schema.properties);
					}
				}
				fs.writeFile('thing-editor/src/editor/schema-thing-project.json', mergedSchema);
			}

			this.assetsFolders.push(this.currentProjectAssetsDir);
			this.assetsFoldersReversed = game.editor.assetsFolders.slice().reverse();

			this.settings.setItem(dir + '_EDITOR_lastOpenTime', Date.now());

			this.projectDesc = {} as ProjectDesc;
			mergeProjectDesc(this.projectDesc, libsProjectDescMerged);
			mergeProjectDesc(this.projectDesc, projectDesc);
			setTimeout(excludeOtherProjects, 1);

			game.applyProjectDesc(this.projectDesc);

			editorEvents.emit('gameWillBeInitialized');

			game.init(window.document.getElementById('viewport-root') || undefined, 'editor.' + this.projectDesc.id);

			game.stage.interactiveChildren = false;
			protectAccessToSceneNode(game.stage, 'game stage');
			protectAccessToSceneNode(game.stage.parent, 'PIXI stage');

			await spineLoading;

			await Texture.fromURL('/thing-editor/img/wrong-texture.png').then((t) => {
				Lib.REMOVED_TEXTURE = t;
				return this.reloadAssetsAndClasses();
			});

			if (this.settingsLocal.getItem(LAST_SCENE_NAME) && !Lib.hasScene(this.settingsLocal.getItem(LAST_SCENE_NAME))) {
				this.saveLastSceneOpenName('');
			}
			this.settingsLocal.setItem(LAST_SCENE_NAME, this.settingsLocal.getItem(LAST_SCENE_NAME) || (Lib.hasScene(this.projectDesc.mainScene) ? this.projectDesc.mainScene : Object.keys(Lib.scenes)[0]));

			loadFonts();
			await waitForCondition(() => {
				return game.loadingProgress === 100;
			});

			editorEvents.emit('firstSceneWillOpen');
			this.restoreBackup();

			regeneratePrefabsTypings();
			if (!this.buildProjectAndExit) {
				fs.watchDirs(this.assetsFolders.slice(1)); //slice - exclude watching embed library.
			}
			this.ui.modal.hideSpinner();
			this.isProjectOpen = true;

			applySoundMuting();

			game.onResize();

			this.settings.setItem('last-opened-project', dir);

			this.validateResources();

			editorEvents.emit('projectDidOpen');
			game.editor.saveProjectDesc();
			this.setIsMobileAny(game.editor.settings.getItem('isMobile.any', false));
			this.isSafeAreaVisible = game.editor.settings.getItem('safe-area-frame', true) && game.projectDesc.dynamicStageSize;

			if (this.buildProjectAndExit) {
				await waitForCondition(() => !game.editor.ui.modal.isSpinnerShown());
				await Build.build(false);
				await Build.build(true);
				fs.exitWithResult('build finished');
			}

			const recentProjects = this.getRecentProjects().filter(p => p.dir !== projectDesc.dir);
			recentProjects.unshift({icon: projectDesc.icon, title: projectDesc.title, dir: projectDesc.dir});
			if (recentProjects.length > 10) {
				recentProjects.pop();
			}
			this.settings.setItem('recent-projects', recentProjects);
			const recentProjectsMenu = recentProjects.map((project) => {
				return {
					name: R.span(null, project.icon ? R.img({src: '/' + project.dir + project.icon, onError: (er:ErrorEvent) => {
						((er.target as HTMLImageElement).closest('.context-menu-item') as HTMLDivElement).style.display = 'none';
					}
					 }) : undefined, project.title),
					disabled: () => {
						return project.dir === game.editor.currentProjectDir;
					},
					onClick: () => {
						game.editor.openProject(project.dir.substring(6, project.dir.length - 1));
					}
				}as ContextMenuItem;
			});
			recentProjectsMenu.unshift(null);
			MainMenu.injectMenu('file', recentProjectsMenu, 'recent-projects', 1);
		}
	}

	getRecentProjects():RecentProject[] {
		return this.settings.getItem('recent-projects', []);
	}

	toggleScreenOrientation() {
		game.__enforcedOrientation = (game.__enforcedOrientation === 'portrait') ? 'landscape' : 'portrait';
		game.onResize();
	}

	toggleIsMobileAny() {
		this.setIsMobileAny(!game.isMobile.any);
	}

	setIsMobileAny(val: boolean) {
		const isMobileAny = game.___enforcedOrientation === 'portrait' || val;
		if (game.isPortrait) {
			this.toggleScreenOrientation();
		}
		if (isMobileAny != game.isMobile.any) {
			game.isMobile.any = isMobileAny;
			game.editor.settings.setItem('isMobile.any', val);
			this._processIsMobileHandlers();
		}
	}

	_processIsMobileHandlers() {
		if (game.pixiApp) {
			game.forAllChildrenEverywhere((o: any) => {
				if (o.__onIsMobileChange) {
					o.__onIsMobileChange();
				}
			});
			this.ui.propsEditor.refresh();
		}
	}

	toggleSafeAreaFrame() {
		game.editor.settings.setItem('safe-area-frame', !game.editor.settings.getItem('safe-area-frame', true));
		this.isSafeAreaVisible = game.editor.settings.getItem('safe-area-frame') && game.projectDesc.dynamicStageSize;
	}

	toggleHideHelpers() {
		game.editor.settings.setItem('show-gizmo', !game.editor.settings.getItem('show-gizmo', true));
		this.showGizmo = game.editor.settings.getItem('show-gizmo');
	}

	get isGizmoVisible() {
		return this.showGizmo && !document.fullscreenElement;
	}

	toggleSoundMute() {
		game.editor.settings.setItem('sound-muted', !game.editor.settings.getItem('sound-muted'));
		applySoundMuting();
	}

	toggleVSCodeExcluding() {
		game.editor.settings.setItem('vs-code-excluding', !game.editor.settings.getItem('vs-code-excluding'));
		excludeOtherProjects(true);
	}

	toggleShowSystemAssets() {
		game.editor.settings.setItem('show-system-assets', !game.editor.settings.getItem('show-system-assets'));
		this.ui.refresh();
	}

	scrollAssetInToView(assetName: string) {
		AssetsView.scrollAssetInToView(assetName);
	}

	warnEqualFiles(warning:string, file: FileDesc, existingFile: FileDesc) {
		this.ui.status.warn(warning + ' ' + file.fileName + ' => ' + existingFile.fileName, 99999, (ev?: PointerEvent) => {
			let preview = AssetsView.renderAssetItem(file);
			if (ev && (ev.ctrlKey || ev.metaKey)) {
				fs.deleteAsset(file.assetName, file.assetType);
				game.editor.ui.status.clearLastClickedItem();
			}
			editor.ui.modal.showEditorQuestion('A you sure you want to remove wrong overriding?', R.div(null, R.div(null, file.fileName), preview), () => {
				fs.deleteAsset(file.assetName, file.assetType);
				game.editor.ui.status.clearLastClickedItem();
			}, R.span({ className: 'danger' }, R.img({ src: 'img/delete.png' }), 'Delete wrong overriding'));
		}, undefined, undefined, undefined, StatusClearingCondition.ASSETS_REFRESH);
	}

	saveProjectDesc() {
		debouncedCall(this.__saveProjectDescriptorInner);
	}

	openScene(name: string) {
		if (this.askSceneToSaveIfNeed()) {

			Pool.__resetIdCounter();

			while (game.editor.ui.modal.state.modals.length) {
				game.editor.ui.modal.hideModal();
			}

			assert(name, 'name should be defined');

			game.showScene(name);

			game.currentContainer.__nodeExtendData.childrenExpanded = true;


			document.title = '(' + this.projectDesc.title + ') - - (' + game.currentScene.name + ')';
			this.saveLastSceneOpenName(game.currentScene.name as string);
			if (game.currentScene) {
				this.selection.loadCurrentSelection();
			}
			this.history.setCurrentStateUnmodified();
			this.ui.refresh();
			regenerateCurrentSceneMapTypings();
		}
	}

	classesUpdatedExternally() {
		ClassesLoader.isClassesWaitsReloading = true;
		this.ui.viewport.refresh();
	}

	/** if returns false - cancel operation */
	askSceneToSaveIfNeed(): boolean {
		this.ui.viewport.stopExecution();
		if (PrefabEditor.acceptPrefabEdition() === false) {
			return false;
		}
		if (this.isCurrentSceneModified) {
			let ansver = fs.showQuestion(
				'Unsaved changes.',
				'Do you want to save changes in \'' + this.currentSceneName + '\' scene?',
				'Save',
				'Discard',
				'Cancel'
			);
			if (ansver === 0) {
				this.saveCurrentScene();
			} else if (ansver === 2) {
				return false;
			}
		} else {
			if (game.currentScene) {
				this.selection.saveCurrentSelection();
			}
		}
		return true;
	}

	addTo(parent: Container, child: Container) {
		parent.addChild(child);
		let p = parent;
		while (p) {
			p.__hideChildren = false;
			p = p.parent;
		}
		Lib.__callInitIfGameRuns(child);
		this.selection.select(child, true);
		Lib.__invalidateSerializationCache(child);
		this.sceneModified();
	}

	isCanBeAddedAsChild(Class: SourceMappedConstructor, parent?: Container): boolean {
		const parents = parent ? [parent] : this.selection;
		if (parents.length < 1) {
			return false;
		}
		for (let o of parents) {

			if (Class.__canAcceptParent) {
				if (!Class.__canAcceptParent(o)) {
					return false;
				}
			}

			if ((o.constructor as SourceMappedConstructor).__canAcceptChild) {
				if (!(o.constructor as SourceMappedConstructor).__canAcceptChild!(Class)) {
					return false;
				}
			}
		}
		return true;
	}

	_getProjectViewportSize(forceLandscape = true) {
		if (game.projectDesc.screenOrientation === 'auto') {
			if (forceLandscape) {
				game.___enforcedOrientation = 'landscape';
			}
			if (forceLandscape || !game.isPortrait) {
				return {
					w: game.projectDesc.width,
					h: game.projectDesc.height
				};
			} else {
				return {
					w: game.projectDesc.portraitWidth,
					h: game.projectDesc.portraitHeight
				};
			}
		} else if (game.projectDesc.screenOrientation === 'portrait') {
			return {
				w: game.projectDesc.portraitWidth,
				h: game.projectDesc.portraitHeight
			};
		} else {
			return {
				w: game.projectDesc.width,
				h: game.projectDesc.height
			};
		}
	}

	_callInPortraitMode(callback: () => void) {
		let tmpOrientation = game.___enforcedOrientation;
		let tmpIsMobile = game.isMobile.any;
		game.isMobile.any = false;
		let size = this._getProjectViewportSize();
		game.__enforcedW = size.w;
		game.__enforcedH = size.h;

		game.onResize();
		callback();
		game.___enforcedOrientation = tmpOrientation;
		delete game.__enforcedW;
		delete game.__enforcedH;
		game.isMobile.any = tmpIsMobile;
		game.onResize();
	}

	validateResources() {
		for (let data of [Lib.prefabs, Lib.scenes]) {
			for (let name in data) {
				let objectData = data[name];
				validateObjectDataRecursive(objectData, name);
			}
		}
	}

	saveCurrentScene(name: string = this.currentSceneName) {

		this.ui.viewport.stopExecution();

		assert(name, 'Name can\'t be empty');
		assert(game.__EDITOR_mode, 'tried to save scene in running mode.');
		if (this.isCurrentSceneModified || (this.currentSceneName !== name)) {

			this.history.setCurrentStateUnmodified();
			this.saveLastSceneOpenName(name);
			this._callInPortraitMode(() => {
				Lib.__saveScene(game.currentScene, name);
				this.selection.saveCurrentSelection();
			});
		}
		this.validateResources();
	}

	get currentSceneName(): string {
		return this.settingsLocal.getItem(LAST_SCENE_NAME, '');
	}

	get currentSceneBackupName() {
		return EDITOR_BACKUP_PREFIX + this.settingsLocal.getItem(LAST_SCENE_NAME);
	}

	openUrl(url: string) {
		window.open(url);
	}

	sceneModified(saveImmediately = false) {
		this.history._sceneModifiedInner(saveImmediately);
	}

	moveContainerWithoutChildren(o: Container, dX: number, dY: number) {
		for (let c of o.children) {
			let p = c.getGlobalPosition();
			c.__nodeExtendData.tmpGlobalPos = p;
			let p2 = o.toLocal(p);
			if (isNaN(p2.x) || isNaN(p2.y)) {
				this.ui.status.warn('Object has zero scale and can not be moved without affecting children`s positions.', 30023, o, undefined, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
				return;
			}
		}
		this.shiftObject(o, dX, dY);
		for (let c of o.children) {
			let p = o.toLocal(c.__nodeExtendData.tmpGlobalPos as Point);
			this.shiftObject(c as Container, Math.round(p.x - c.x), Math.round(p.y - c.y));
			roundUpPoint(c);
		}
	}

	shiftObject(o: Container, dX: number, dY: number) {
		if (dX !== 0 || dY !== 0) {
			// Shift wrapped object to zero. If it is MovieClip its will shift all timeline.

			if (o.__shiftObject) {
				o.__shiftObject(dX, dY);
			} else {

				Timeline.disableRecording();
				if (dX !== 0) {
					this.onObjectsPropertyChanged(o, 'x', dX, true);
				}
				if (dY !== 0) {
					this.onObjectsPropertyChanged(o, 'y', dY, true);
				}
				Timeline.enableRecording();
			}
		}
	}

	previewSound(soundName: string) {
		if (Lib.getSound(soundName)?.source) {
			Lib.getSound(soundName).stop();
		} else {
			 if (previewedSound) {
				previewedSound.stop();
				previewedSound = null;
			}
			Sound.play(soundName);
			previewedSound = Lib.getSound(soundName);
		}
	}

	blurPropsInputs() {
		if (document.activeElement && (document.activeElement.classList.contains('number-input'))) {
			(document.activeElement as HTMLElement).blur();
		}
	}

	async chooseImage(title: ComponentChild = 'Choose image', activeImage?: string): Promise<string | null> {
		return this.chooseAsset(AssetType.IMAGE, title, activeImage);
	}

	async chooseSound(title: ComponentChild = 'Choose sound', activeSound?: string): Promise<string | null> {
		return this.chooseAsset(AssetType.SOUND, title, activeSound, this.previewSound);
	}

	async choosePrefab(title: ComponentChild = 'Choose prefab', currentPrefab?: string, filterCallback?: (f: FileDesc) => boolean): Promise<string | null> {
		return this.chooseAsset(AssetType.PREFAB, title, currentPrefab, undefined, filterCallback);
	}

	async chooseScene(title: ComponentChild = 'Choose scenbe', currentScene?: string, filterCallback?: (f: FileDesc) => boolean): Promise<string | null> {
		return this.chooseAsset(AssetType.SCENE, title, currentScene, undefined, filterCallback);
	}

	async chooseClass(isScene: boolean, id: string, title: ComponentChild = 'Choose class', currentClass?: string): Promise<string | null> {
		return this.chooseAsset(AssetType.CLASS, title, currentClass, undefined, (file: FileDesc) => {
			return (file as FileDescClass).asset.__isScene === isScene;
		}, id);
	}

	validateCallbackParameter(txt: string) {
		if (txt.indexOf(',') >= 0) {
			return 'Parameter can not contain commas. Use your own javascript function instead.';
		}
	}

	showFilteredAssetsList(title: ComponentChild, filterCallback?: (f: FileDesc) => boolean, onItemSelect?: (assetName: string) => void, noEasyClose = false) {
		const id = 'assets-list-' + title;
		this.ui.modal.showModal(h(AssetsView, {
			id,
			onItemSelect,
			content: undefined,
			helpId: 'ChooseId',
			x: 0,
			minW: 400,
			minH: 200,
			y: 0,
			w: 50,
			h: 50,
			key: id,
			title,
			filter: {/*project: true*/},
			filterCallback
		}), undefined, 	noEasyClose);
	}

	async chooseAsset(type: AssetType, title: ComponentChild, currentValue?: string, onItemPreview?: (assetName: string) => void, filterCallback?: (f: FileDesc) => boolean, idSuffix = ''): Promise<string | null> {
		const id = type + '_choose_asset_list_popup' + idSuffix;
		const chosen: string = await this.ui.modal.showModal(h(AssetsView, {
			onItemSelect: (assetName: string) => {
				this.ui.modal.hideModal(assetName);
			},
			id,
			content: undefined,
			helpId: 'ChooseId',
			x: 0,
			minW: 400,
			minH: 200,
			y: 0,
			w: 50,
			h: 50,
			key: id,
			title,
			currentValue,
			onItemPreview,
			hideMenu: true,
			filter: { [type]: true },
			filterCallback
		}));
		if (chosen) {
			return chosen;
		}
		return null;
	}

	/** @deprecated use 'editorEvents.on' global object instead.*/
	on() {
		assert(false, 'use \'editorEvents.on\' global object instead');
	}

	/** @deprecated use 'editorEvents.on' global object instead.*/
	addEventListener() {
		assert(false, 'use \'editorEvents.on\' global object instead');
	}

	previewAsset(file:FileDesc) {
		switch (file.assetType) {
		case AssetType.PREFAB:
			PrefabEditor.editPrefab(file.assetName);
			break;
		case AssetType.SCENE:
			game.editor.openScene(file.assetName);
			break;
		default:
			fs.showFile(file.fileName);

		}
	}

	async reloadAssetsAndClasses() {
		fs.refreshAssetsList(this.assetsFolders);

		const file = fs.getFileByAssetName('src/__beforeprojectopen', AssetType.CLASS);
		if (file) {
			await import(/* @vite-ignore */ file.fileName);
		}
		await this.reloadClasses();

		await waitForCondition(() => {
			return game.loadingProgress === 100;
		});
	}

	onObjectsPropertyChanged(o: Container, field: EditablePropertyDesc | string, val: any, isDelta?: boolean) {
		assert((!isDelta) || (typeof isDelta === 'boolean'), 'isDelta expected to be bool');
		let changed = false;
		if (typeof field === 'string') {
			field = this.getObjectField(o, field);
		}

		editorEvents.emit('beforePropertyChanged', o, field.name, field, val, isDelta);

		if (isDelta) {
			if (val === 0) {
				return;
			}
			assert(field.type === 'number', 'editable field descriptor type: Number expected');

			let v = (o as KeyedObject)[field.name];
			let newVal = v + val;
			if (field.hasOwnProperty('min')) {
				newVal = Math.max(field.min as number, newVal);
			}
			if (field.hasOwnProperty('max')) {
				newVal = Math.min(field.max as number, newVal);
			}
			if (v !== newVal) {
				(o as KeyedObject)[field.name] = newVal;
				changed = true;
			}
		} else {
			if ((o as KeyedObject)[field.name] !== val) {
				(o as KeyedObject)[field.name] = val;
				changed = true;
			}
		}

		editorEvents.emit('afterPropertyChanged', o, field.name, field, val, isDelta);

		if (changed) {
			Lib.__invalidateSerializationCache(o);
			this.refreshTreeViewAndPropertyEditor();
			this._lastChangedFiledName = field.name;
			this.sceneModified(false);
		}
		return changed;
	}

	showError(message: ComponentChild, errorCode = 99999) {
		this.ui.modal.showError(message, errorCode);
	}

	notify(message: string | Component) {
		this.ui.modal.notify(message);
	}

	refreshTreeViewAndPropertyEditor(onTreeViewUpdated?:() => void) {
		this.ui.sceneTree.refresh(onTreeViewUpdated);
		this.refreshPropsEditor();
	}

	refreshPropsEditor() {
		this.ui.propsEditor.refresh();
	}

	getFieldNameByValue(node: Container, fieldValue: any) {
		if (node instanceof Container) {
			const props = (node.constructor as SourceMappedConstructor).__editableProps;
			for (let p of props) {
				if ((node as KeyedObject)[p.name] === fieldValue) {
					return p.name;
				}
			}
		}
	}

	copyToClipboard(text: string) {
		navigator.clipboard.writeText(text).then(() => {
			this.notify(R.span(null, R.icon('copy'), '"' + text + '"'));
		}).catch(_er => {});
	}

	private lastSourceEditTime = 0;

	async editSource(fileName: string, line?: string, char?: string, absolutePath = false, errorToFindLineNum?:{stack?: string}) {
		const now = Date.now();
		if (this.lastSourceEditTime > now - 500) {
			return;
		}
		this.lastSourceEditTime = now;

		if (this.editorArguments['no-vscode-integration']) {
			return;
		}
		if (errorToFindLineNum) {
			const pureFileName = fileName.split('?')[0].split(':')[0];
			const errorLine = errorToFindLineNum?.stack?.split('\n').find(l => l.includes(pureFileName));
			if (errorLine) {
				const a = errorLine.split(':');
				line = parseInt(a[a.length - 2]) as any;
				char = parseInt(a[a.length - 1]) as any;
				if (isNaN(line as any)) {
					line = undefined;
					char = undefined;
				}
				if (isNaN(char as any)) {
					char = undefined;
				}
				await new Promise(resolve => setTimeout(resolve, 100));
			}
		}

		if (line !== undefined) {
			fileName += ':' + line;
			if (char !== undefined) {
				fileName += ':' + char;
			}
		}

		let rootPath: string = fs.getArgs()[0].split('node_modules')[0].replace(/\\/gm, '/');
		fileName = fileName.replace(rootPath, '/');
		fileName = fileName.replace(/\?v=\d+/gm, '');
		const a = fileName.split(':');
		char = (a.length > 2) ? a.pop()! : '0';
		line = a.pop()!;
		if (!isNaN(parseInt(char)) && !isNaN(parseInt(line))) {
			const url = a[0];
			if (url) {
				const SourceMapConsumer = (await (import('source-map-js'))).default.SourceMapConsumer;
				const src = await (await fetch((url.startsWith('/') ? url : ('/' + url)) + '?source-map-version' + Date.now())).text();
				if (src && !src.includes('<title>Error</title>\n')) { // vite error
					const sourceMapUrl = src.split('sourceMappingURL=')[1];
					const sourceMap = await (await fetch(sourceMapUrl)).json();
					if (sourceMap) {
						const consumer = new SourceMapConsumer(sourceMap as any);
						const ret = consumer.originalPositionFor({ line: parseInt(line), column: parseInt(char) || 0 });
						if (typeof ret.line === 'number') {
							fileName = url + ':' + ret.line;
							if (typeof ret.column === 'number') {
								fileName += ':' + ret.column;
							}
						}
					}
				}
			}
		}
		if (!absolutePath) {

			if (fileName.startsWith('\\') || fileName.startsWith('/')) {
				rootPath = rootPath.substring(0, rootPath.length - 1);
			}
			fileName = rootPath + fileName;
		}
		this.editFile(fileName);
	}

	editFile(fileName: string, findText?: string) {
		if (findText) {
			let src = fs.readFile(fileName);
			let a = src.split('\n');
			let char = 0;
			let lineNum = a.findIndex((l) => {
				char = l.indexOf(findText);
				return char >= 0;
			}) + 1;
			fileName += ':' + lineNum + ':' + char;
		}
		let url = '/__open-in-editor?file=' + encodeURIComponent(fileName);
		fetch(url);
	}

	editClassSource(c: SourceMappedConstructor | Container, className = '') {
		if (c instanceof Container) {
			c = c.constructor as SourceMappedConstructor;
		}
		if (!c || (c as any) === __UnknownClass || (c as any) === __UnknownClassScene) {
			this.ui.modal.showError('Object has unknown type \'' + className + '\', and has no source code. Probably source code was removed.');
			return;
		}

		this.editSource(c.__sourceFileName as string);
	}

	async moveAssetToLibrary(title: string, file: FileDesc) {
		let chosenFolder: string | undefined = await this.chooseAssetsFolder(title, file.lib ? file.lib.assetsDir : game.editor.currentProjectAssetsDir);
		if (!chosenFolder) {
			return;
		}
		fs.moveAssetToFolder(file, game.editor.currentProjectLibs.find(l => l.assetsDir === chosenFolder)!);
	}

	getUserVisibleFolders() {
		return game.editor.assetsFolders.filter(i => (!i.startsWith('thing-editor') || game.editor.settings.getItem('show-system-assets')));
	}


	async chooseAssetsFolder(title: string, activeFolderName?: string): Promise<string | undefined> {
		const dirs = this.getUserVisibleFolders();
		if (dirs.length === 1) {
			return dirs[0];
		} else {
			let folders: ChooseListItem[] = dirs.map((folder: string): ChooseListItem => {
				const libInfo = this.currentProjectLibs.find(l => l.assetsDir === folder);
				return {
					pureName: folder,
					name: R.fragment(libInfo ? libIcon(libInfo) : R.space(), folder.replace(/\/assets\/$/g, '').replace(/^libs\//g, ''))
				};
			});
			folders.reverse();
			folders[0].name = R.b(null, R.space(), 'project');
			const chosenItem = (folders.length === 1) ? folders[0] : await game.editor.ui.modal.showListChoose(title, folders, false, true, activeFolderName, true);
			if (chosenItem) {
				return chosenItem.pureName || chosenItem.name as string;
			}
		}
	}

	protected saveLastSceneOpenName(name: string) {
		if (!name.startsWith(EDITOR_BACKUP_PREFIX)) {
			this.settingsLocal.setItem(LAST_SCENE_NAME, name);
		}
	}

	protected __saveProjectDescriptorInner() {

		const descriptorsStack = this.currentProjectLibs.map((lib) => {
			return {
				fileName: lib.dir + '/thing-lib.json',
				desc: this.libsDescriptors[lib.name],
				raw: this.libsDescriptorsRaw[lib.name]
			};
		});
		descriptorsStack.push({
			fileName: this.currentProjectDir + 'thing-project.json',
			desc: this.projectDesc,
			raw: this.projectDescRaw,
		});

		while (descriptorsStack.length) {

			const descData = descriptorsStack.pop()!;

			const srcDescToSave = JSON.stringify(descData?.desc);
			let descToSave = JSON.parse(srcDescToSave) as KeyedObject;

			const libsProjectDescMerged = {} as ProjectDesc;
			descriptorsStack.forEach((desc) => {
				mergeProjectDesc(libsProjectDescMerged, desc.desc);
			});

			for (let key in libsProjectDescMerged) {
				if (descToSave.hasOwnProperty(key)) {

					let projectValue = descToSave[key];
					let libsValue = (libsProjectDescMerged as KeyedObject)[key];
					if (JSON.stringify(projectValue) === JSON.stringify(libsValue)) {
						delete descToSave[key];
					} else if (isProjectDescValueKeyedMap(key)) {
						for (let key in libsValue) {
							if (projectValue[key] === libsValue[key]) {
								delete projectValue[key];
							}
						}
						const assetNames = Object.keys(projectValue);
						for (const assetName of assetNames) {
							if (key === 'soundBitRates') {
								if (projectValue[assetName] === this.projectDesc.soundDefaultBitrate || !Lib.hasSound(assetName)) {
									delete projectValue[assetName];
								}
							} else if (key === 'loadOnDemandTextures') {
								if (!Lib.hasTexture(assetName)) {
									delete projectValue[assetName];
								}
							} else if (key === 'loadOnDemandSounds') {
								if (!Lib.hasSound(assetName)) {
									delete projectValue[assetName];
								}
							}
						}

					} else if (key === 'webfontloader') {
						for (const groupName in libsValue as WebFont.Config) {
							const group = libsValue[groupName] as WebFont.Google;
							if (group && group.families) {
								const projectFontGroup = (projectValue[groupName] as WebFont.Google)?.families;
								if (projectFontGroup) {
									for (const family of group.families) {
										const stringedValue = JSON.stringify(family);
										const i = projectFontGroup.findIndex(f => JSON.stringify(f) === stringedValue);
										if (i >= 0) {
											projectFontGroup.splice(i, 1);
										}
									}
									if (projectFontGroup.length === 0) {
										delete projectValue[groupName];
									}
								}
							}
						}
					}
				}
			}
			delete descToSave.dir;
			if (JSON.stringify(descToSave) !== descData.raw) {
				fs.writeFile(descData.fileName, descToSave);
			}
		}
	}
}

const WORKSPACE_FILE_NAME = 'thing-editor.code-workspace';
const TS_CONFIG_FILE_NAME = 'tsconfig.json';

function sanitizeJSON(input: string) {
	return input.replace(/\/\/.*$/gm, '').replace(/\/\*.*\*\//gm, '');
}


function excludeOtherProjects(forced = false) {

	const isExcludingEnabled = game.editor.settings.getItem('vs-code-excluding');

	if (!forced && !isExcludingEnabled) {
		return;
	}

	try { // vscode workspace

		const workspaceConfigSrc = fs.readFile(WORKSPACE_FILE_NAME);
		const foldersDataRegExt = /"folders"\s*:\s*\[[^\]]*\]/gm;
		let foldersData = foldersDataRegExt.exec(workspaceConfigSrc);
		const oldFoldersString = foldersData!.pop()!;
		const foldersDataString = sanitizeJSON(oldFoldersString);
		const workspaceConfig = JSON.parse('{' + foldersDataString + '}');
		const folders = (workspaceConfig.folders as { path: string; name: string }[]).filter((folderData) => {
			return !folderData.path.startsWith('./games/') && !folderData.path.startsWith('./libs/');
		});

		if (isExcludingEnabled) {
			folders.push({
				path: './' + editor.currentProjectDir,
				name: editor.currentProjectDir
			});
			for (let lib of editor.currentProjectLibs) {
				if (!lib.isEmbed && !folders.find(f => f.name === lib.dir)) {
					folders.push({
						path: './' + lib.dir,
						name: lib.dir
					});
				}
			}
		} else {
			folders.push({
				path: './games/',
				name: 'games'
			});
			folders.push({
				path: './libs/',
				name: 'libs'
			});
		}

		folders.sort();
		let newFoldersSrc = JSON.stringify({ folders }, undefined, '\t');
		newFoldersSrc = newFoldersSrc.substring(3, newFoldersSrc.length - 2);
		if (newFoldersSrc !== oldFoldersString) {
			fs.writeFile(WORKSPACE_FILE_NAME, workspaceConfigSrc.replace(foldersDataRegExt, newFoldersSrc));
		}
	} catch (er) {
		debugger;
		console.error('JSON parsing error: ' + WORKSPACE_FILE_NAME);
		console.error(er);
	}

	try { // tsconfig

		const tsConfigSrc = fs.readFile(TS_CONFIG_FILE_NAME);
		const foldersDataRegExt = /"include"\s*:\s*\[[^\]]*\]/gm;
		let foldersData = foldersDataRegExt.exec(tsConfigSrc)!;
		const oldFoldersString = foldersData[0];
		const foldersDataString = sanitizeJSON(oldFoldersString);
		const tsConfig = JSON.parse('{' + foldersDataString + '}');
		const include = (tsConfig.include as string[]).filter((folder) => {
			return !folder.startsWith('./games/') && !folder.startsWith('./libs/');
		});

		if (isExcludingEnabled) {
			include.push('./' + editor.currentProjectDir + 'assets/src/**/*');
			for (let lib of editor.currentProjectLibs) {
				const pathToAdd = './' + lib.dir + '/assets/src/**/*';
				if (!lib.isEmbed && !include.includes(pathToAdd)) {
					include.push(pathToAdd);
				}
			}
		} else {
			include.push('./games/');
			include.push('./libs/');
		}

		include.sort();
		let newFoldersSrc = JSON.stringify({ include });
		newFoldersSrc = newFoldersSrc.substring(1, newFoldersSrc.length - 1);
		if (newFoldersSrc !== oldFoldersString) {
			fs.writeFile(TS_CONFIG_FILE_NAME, tsConfigSrc.replace(foldersDataRegExt, newFoldersSrc));
		}
	} catch (er) {
		debugger;
		console.error('JSON parsing error: ' + TS_CONFIG_FILE_NAME);
		console.error(er);
	}
}

const editor = new Editor();

type __EditorType = typeof editor;

export type { __EditorType }; // hide Editor from intellisense
</file>

<file path="src/editor/fs.ts">
import type { Container } from 'pixi.js';
import { BitmapFont, Text, Texture } from 'pixi.js';
import type { ComponentChildren } from 'preact';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import { EDITOR_BACKUP_PREFIX, electron_ThingEditorServer } from 'thing-editor/src/editor/utils/flags';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import type HowlSound from 'thing-editor/src/engine/HowlSound';
import Lib, { __onAssetAdded, __onAssetDeleted, __onAssetUpdated } from 'thing-editor/src/engine/lib';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import { StatusClearingCondition } from './ui/status-clearing-condition';
import { regeneratePrefabsTypings } from './utils/generate-editor-typings';


let wakeLock:WakeLockSentinel | null | true = null;

interface LibInfo {
	name: string;
	dir: string;
	libNum: number;
	assetsDir: string;
	isEmbed?: boolean;
}

const OVERRIDDEN_ASSETS:Set<string> = new Set();

const prefabNameFilter = /[^a-zA-Z\-\/0-9_]/g;

interface FileDesc {
	/** file name*/
	fileName: string;
	assetName: string;
	assetType: AssetType;
	/** modification time*/
	mTime: number;
	lib: LibInfo | null;
	libInfoCache?: ComponentChildren;
	v?: number;
	_hashedAssetName?: string;

	parentAsset?: FileDesc;
	/** set true to include unknown json file in to build. Will be available in runtime via Lib.resources['json.name'] */
	includeToBuild?: boolean;

	asset: SourceMappedConstructor | SerializedObject | Texture | HowlSound | KeyedObject;
}

interface FileDescClass extends FileDesc {
	asset: SourceMappedConstructor;
}
interface FileDescPrefab extends FileDesc {
	asset: SerializedObject;
}
interface FileDescScene extends FileDesc {
	asset: SerializedObject;
}

interface FileDescSound extends FileDesc {
	asset: HowlSound;
}
interface FileDescImage extends FileDesc {
	asset: Texture;
}
interface FileDescL10n extends FileDesc {
	asset: KeyedObject;
	dir: string;
	readOnly?: boolean;
	lang: string;
	priority?: number;
	isDefault?: boolean;
	__isLangIdPlaceHolder?: boolean;
	isDirty?: boolean;
}

enum AssetType {
	IMAGE = 'IMAGE',
	SOUND = 'SOUND',
	SCENE = 'SCENE',
	PREFAB = 'PREFAB',
	CLASS = 'CLASS',
	RESOURCE = 'RESOURCE',
	BITMAP_FONT = 'BITMAP_FONT',
	L10N = 'L10N',
	/** non file asses. Used in enumAssetsPropsRecursive to copy l10n values */
	L10N_ENTRY = 'L10N_ENTRY',
	FONT = 'FONT',
}

const AllAssetsTypes: AssetType[] = Object.values(AssetType);

const assetsListsByType: Map<AssetType, FileDesc[]> = new Map();

let allAssets: FileDesc[] = [];

let prevAssetsByTypeByName: Map<AssetType, Map<string, FileDesc>>;
let assetsByTypeByName: Map<AssetType, Map<string, FileDesc>>;

const resetAssetsMap = () => {
	assetsByTypeByName = new Map();

	for (const assetType of AllAssetsTypes) {
		assetsByTypeByName.set(assetType, new Map());
		assetsListsByType.set(assetType, []);
	}
};
resetAssetsMap();

const ASSETS_PARSERS = {
	'.png': AssetType.IMAGE,
	'.jpg': AssetType.IMAGE,
	'.svg': AssetType.IMAGE,
	'.webp': AssetType.IMAGE,
	'.s.json': AssetType.SCENE,
	'.p.json': AssetType.PREFAB,
	'.l.json': AssetType.L10N,
	'.json': AssetType.RESOURCE,
	'.woff': AssetType.FONT,
	'.woff2': AssetType.FONT,
	'.wav': AssetType.SOUND,
	'.xml': AssetType.BITMAP_FONT,
	'.c.ts': AssetType.CLASS
};

const ASSET_TYPE_TO_EXT = {
	[AssetType.SCENE]: '.s.json',
	[AssetType.PREFAB]: '.p.json',
	[AssetType.CLASS]: '.c.ts'
};

const ASSET_EXT_CROP_LENGTHS: Map<AssetType, number> = new Map();
ASSET_EXT_CROP_LENGTHS.set(AssetType.FONT, 0);
ASSET_EXT_CROP_LENGTHS.set(AssetType.IMAGE, 0);
ASSET_EXT_CROP_LENGTHS.set(AssetType.SCENE, 7);
ASSET_EXT_CROP_LENGTHS.set(AssetType.PREFAB, 7);
ASSET_EXT_CROP_LENGTHS.set(AssetType.L10N, 7);
ASSET_EXT_CROP_LENGTHS.set(AssetType.SOUND, 4);
ASSET_EXT_CROP_LENGTHS.set(AssetType.CLASS, 5);
ASSET_EXT_CROP_LENGTHS.set(AssetType.RESOURCE, 5);
ASSET_EXT_CROP_LENGTHS.set(AssetType.BITMAP_FONT, 4);

const EMPTY: FileDescImage = {
	assetName: 'EMPTY',
	fileName: '/thing-editor/img/EMPTY.png',
	asset: Texture.EMPTY,
	assetType: AssetType.IMAGE,
	mTime: Number.MAX_SAFE_INTEGER,
	lib: null
};

const WHITE: FileDescImage = {
	assetName: 'WHITE',
	fileName: '/thing-editor/img/WHITE.jpg',
	asset: Texture.WHITE,
	assetType: AssetType.IMAGE,
	mTime: Number.MAX_SAFE_INTEGER,
	lib: null
};

const execFs = (command: string, filename?: string | string[] | number, content?: string | boolean | ArrayBuffer, ...args: any[]) => {
	const ret = electron_ThingEditorServer.fs(command, filename, content, ...args);
	if (ret instanceof Error) {
		game.editor.ui.modal.showFatalError('Main process error.', 99999, ret.message);
		throw ret;
	}
	return ret;
};

const execFsAsync = (command: string, filename?: string | string[], content?: string | boolean, ...args: any[]): Promise<any> => {
	return electron_ThingEditorServer.fsAsync(command, filename, content, ...args);
};

let lastAssetsDirs: string[];

let fileChangeDebounceTimeout = 0;
const fileChangeHandler = () => {
	fileChangeDebounceTimeout = 0;
	fs.refreshAssetsList();
};

electron_ThingEditorServer.onServerMessage((_ev: any, event: string, path: string) => {
	if (!game.editor.isProjectOpen) {
		return;
	}
	if (event === 'fs/change') {
		path = '/' + path.replace(/\\/g, '/');
		if (!ignoreFiles.has(path)) {
			if (fileChangeDebounceTimeout) {
				clearTimeout(fileChangeDebounceTimeout);
			}
			if (path.endsWith('.ts')) {
				game.editor.classesUpdatedExternally();
			} else {
				fileChangeDebounceTimeout = window.setTimeout(fileChangeHandler, 330);
			}
		}
	} else if (event === 'fs/notify') {
		game.editor.ui.modal.notify(path);
	}
});

const ignoreFiles = new Set();
function ignoreWatch(fileName: string) {
	ignoreFiles.add(fileName);
	window.setTimeout(() => {
		ignoreFiles.delete(fileName);
	}, 500);
}

const assetNameToFileName = (assetName: string, assetType: AssetType, libName = game.editor.currentProjectAssetsDirRooted): string => {
	const asset = (assetsByTypeByName.get(assetType) as Map<string, FileDesc>).get(assetName);
	if (asset) {
		return asset.fileName;
	}
	return libName + assetName + (ASSET_TYPE_TO_EXT as KeyedObject)[assetType];
};

const sortByMTime = (a: FileDesc, b: FileDesc) => {
	return b.mTime - a.mTime;
};

const sortAssets = () => {
	assetsListsByType.forEach((list) => {
		list.sort(sortByMTime);
	});

	allAssets.sort(sortByMTime);
};

export default class fs {

	static getAssetsList(assetType?: AssetType.SOUND): FileDescSound[];
	static getAssetsList(assetType?: AssetType.IMAGE): FileDescImage[];
	static getAssetsList(assetType?: AssetType.CLASS): FileDescClass[];
	static getAssetsList(assetType?: AssetType.SCENE): FileDescScene[];
	static getAssetsList(assetType?: AssetType.PREFAB): FileDescPrefab[];
	static getAssetsList(assetType?: AssetType): FileDesc[];
	static getAssetsList(assetType: AssetType | null = null): FileDesc[] {
		if (assetType === null) {
			return allAssets;
		}
		return assetsListsByType.get(assetType) as FileDesc[];
	}

	/** retunrs FileDesc of scene or prefab of given container */
	static getFileOfRoot(object: Container): FileDescPrefab | FileDescScene {
		const root = object.getRootContainer() || game.currentContainer;
		const rootName = root.name as string;
		if (root instanceof Scene) {
			return this.getFileByAssetName(rootName, AssetType.SCENE);
		} else {
			return this.getFileByAssetName(rootName, AssetType.PREFAB);
		}
	}

	static getFileByAssetName(assetName: string, assetType: AssetType.IMAGE): FileDescImage;
	static getFileByAssetName(assetName: string, assetType: AssetType.SCENE): FileDescScene;
	static getFileByAssetName(assetName: string, assetType: AssetType.PREFAB): FileDescPrefab;
	static getFileByAssetName(assetName: string, assetType: AssetType.SOUND): FileDesc;
	static getFileByAssetName(assetName: string, assetType: AssetType.CLASS): FileDescClass;
	static getFileByAssetName(assetName: string, assetType: AssetType): FileDesc;
	static getFileByAssetName(assetName: string, assetType: AssetType): FileDesc {
		return assetsByTypeByName.get(assetType)!.get(assetName) as FileDesc;
	}

	static removeSubAsset(assetName: string, type: AssetType) {
		const file = this.getFileByAssetName(assetName, type);
		if (file) {
			const list = (assetsListsByType.get(file.assetType) as FileDesc[]);
			list.splice(list.indexOf(file), 1);
			allAssets.splice(allAssets.indexOf(file), 1);
			assetsByTypeByName.get(file.assetType)!.delete(file.assetName);
		}
		if (prevAssetsByTypeByName) {
			const file = prevAssetsByTypeByName.get(type)!.get(assetName) as FileDesc;
			if (file) {
				prevAssetsByTypeByName.get(file.assetType as AssetType)!.delete(assetName);
			}
		}
	}

	static getLastTouch(file: FileDesc):number {
		let ret = 0;
		switch (file.assetType) {
		case AssetType.CLASS:
			return 0;
		case AssetType.SCENE:
			return Lib.scenes[file.assetName].__lastTouch || 0;
		case AssetType.PREFAB:
			return Lib.prefabs[file.assetName].__lastTouch || 0;
		case AssetType.IMAGE:
			ret = Lib.getTexture(file.assetName).baseTexture.touched;
			if (ret === 0) {
				const images = fs.getAssetsList(AssetType.IMAGE);
				const src = ((file as FileDescImage).asset.baseTexture.resource as any)?.url;
				if (src) {
					for (const image of images) {
						if (image.asset.baseTexture.resource?.src === src) {
							ret = Math.max(ret, image.asset.baseTexture.touched);
						}
					}
				}
				game.classes.Spine.__touchedSpines.forEach((time, spineName) => {
					const spine = Lib.resources[spineName];
					if (spine.spineAtlas.pages.some((page: any) => {
						return page.baseTexture.resource.src === src;
					})) {
						ret = Math.max(ret, time);
					}
				});
			}
			return ret;
		case AssetType.FONT:

			const fontName = file.assetName.split('/').pop()?.replace(/\.woff2?$/, '').toLocaleLowerCase();
			const names = Array.from(Text.__touchedFonts.keys()) as string[];
			for (let k of names) {
				const a = k.toLocaleLowerCase().split(',');
				if (a.some((fn) => {
					return fn.trim() == fontName;
				})) {
					ret = Math.max(ret, Text.__touchedFonts.get(k)!);
				}
			}
			return ret;

		case AssetType.SOUND:
			return Lib.getSound(file.assetName).__lastTouch;
		case AssetType.BITMAP_FONT:
			const fontTextures = BitmapFont.available[file.assetName.split('/').pop()!].pageTextures;
			return fontTextures[Object.keys(fontTextures)[0]].baseTexture.touched;
		case AssetType.RESOURCE:
			return Lib.resources[file.assetName]?.___lastTouch || Number.MAX_SAFE_INTEGER;
			debugger;
		}
		return Number.MAX_SAFE_INTEGER;
	}

	static addSubAsset(file: FileDesc) {
		(assetsListsByType.get(file.assetType) as FileDesc[]).push(file);
		allAssets.push(file);
		(assetsByTypeByName.get(file.assetType as AssetType) as Map<string, FileDesc>).set(file.assetName, file);
	}

	/** returns new mTime */
	static writeFile(fileName: string, data: string | ArrayBuffer | KeyedObject, separator:string | null = '	'): number {
		if (typeof data !== 'string' && !(data instanceof ArrayBuffer)) {
			data = JSON.stringify(data, fs.fieldsFilter, separator as string);
		}
		return execFs('fs/saveFile', fileName, data as string) as number;
	}

	static exists(fileName: string) {
		return execFs('fs/exists', fileName);
	}

	static log(message: string) {
		return execFs('fs/log', message);
	}

	static openDevTools() {
		return execFs('fs/devTools');
	}

	static copyFile(from: string, to: string) {
		return execFs('fs/copyFile', from, to);
	}

	static async run(script: string, ...args: any[]) {
		game.editor.ui.modal.showSpinner();
		const res = await execFsAsync('fs/run', script, undefined, args);

		game.editor.ui.modal.hideSpinner();
		if (res instanceof Error) {
			game.editor.ui.modal.showError(res.stack, undefined, 'Deploy error');
			return null;
		}
		return res;
	}

	static renameAsset(file: FileDesc) {
		let ext = '';
		if (file.assetType === AssetType.IMAGE) {
			ext = file.assetName.substring(file.assetName.lastIndexOf('.'));
		}
		game.editor.ui.modal.showPrompt('Rename asset ' + ext, file.assetName.substring(0, file.assetName.length - ext.length),
			(val) => { // filter
				return val.replace(prefabNameFilter, '-');
			},
			(val) => { //accept
				const newAssetName = val + ext;
				let newFile = fs.getFileByAssetName(newAssetName, file.assetType);
				if (file === newFile) {
					return;
				}
				if (newFile) {
					return 'Already exists';
				}
				if (val.endsWith('/') || val.startsWith('/')) {
					return 'name can not begin or end with "/"';
				}
			}).then((newName) => {
			if (newName) {
				newName += ext;
				if (newName !== file.assetName) {
					const i = file.fileName.lastIndexOf(file.assetName);
					fs.copyFile(file.fileName, file.fileName.substring(0, i) + newName + file.fileName.substring(i + file.assetName.length));
					fs.deleteFile(file.fileName);
				}
			}
		});
	}

	static copyAssetToProject(file: FileDesc) {
		if (file.assetType === AssetType.CLASS) {
			game.editor.ui.modal.showInfo('Class can not be copied to the project. Create a new class inherited from ' + (file as FileDescClass).asset.__className + ' instead.', 'Can not copy class.');
			return;
		}
		const newFileName = file.fileName.replace(file.lib!.assetsDir, game.editor.currentProjectAssetsDir);
		OVERRIDDEN_ASSETS.add(newFileName);
		fs.copyFile(file.fileName, newFileName);
		fs.refreshAssetsList();
		game.editor.ui.refresh();
	}

	static moveAssetToFolder(file: FileDesc, lib: null | LibInfo) {
		fs.copyFile(file.fileName, file.fileName.replace(file.lib ? file.lib.assetsDir : game.editor.currentProjectAssetsDir, lib ? lib.assetsDir : game.editor.currentProjectAssetsDir));
		fs.deleteFile(file.fileName);
		fs.refreshAssetsList();
		game.editor.ui.refresh();
	}

	static saveAsset(assetName: string, assetType: AssetType, data: string | Blob | KeyedObject, libName?: string, doNotSetFileAsset = false) {
		const fileName = assetNameToFileName(assetName, assetType, libName);
		ignoreWatch(fileName);
		const mTime = fs.writeFile(fileName, data);
		const file = fs.getFileByAssetName(assetName, assetType);
		if (file) {
			file.mTime = mTime;
			if (!doNotSetFileAsset) {
				file.asset = data as SerializedObject;
			}
			sortAssets();
			game.editor.ui.refresh();
		} else if (!assetName.startsWith(EDITOR_BACKUP_PREFIX)) {
			fs.refreshAssetsList();
		}
		game.editor.scrollAssetInToView(assetName);
	}

	private static deleteFile(fileName: string) {
		return execFs('fs/delete', fileName);
	}

	static deleteAsset(assetName: string, assetType: AssetType) {

		if (assetType === AssetType.SCENE) {
			if (assetName === game.editor.currentSceneName) {
				game.editor.openScene(game.projectDesc.mainScene);
			}
		}

		const fileName = assetNameToFileName(assetName, assetType);
		fs.deleteFile(fileName);
		if (!assetName.startsWith(EDITOR_BACKUP_PREFIX)) {
			fs.refreshAssetsList();
		}

		if (assetType === AssetType.PREFAB) {
			game.editor.ui.refresh();
			regeneratePrefabsTypings();
		} else if (assetType === AssetType.CLASS) {
			game.editor.reloadClasses();
		} else if (assetType === AssetType.IMAGE) {
			game.editor.ui.refresh();
		} else if (assetType === AssetType.SOUND) {
			game.editor.ui.refresh();
		}

	}

	static parseJSON(src: string, fileName: string) {
		try {
			return JSON.parse(src);
		} catch (er: any) {
			game.editor.ui.modal.showFatalError('JSON parse error. ' + fileName + '; ' + er.message, 99999, 'Error in file: ' + fileName + '\n' + (er as Error).message);
		}
	}

	static readJSONFile(fileName: string): any {
		return this.parseJSON(fs.readFile(fileName), fileName);
	}

	static readJSONFileIfExists(fileName: string) {
		const src = this.readFileIfExists(fileName);
		return src && this.parseJSON(src, fileName);
	}

	static readFileIfExists(fileName: string) {
		return (execFs('fs/readFileIfExists', fileName) as any as string | null);
	}

	static readFile(fileName: string) {
		return (execFs('fs/readFile', fileName) as any as string);
	}

	static enumProjects(): ProjectDesc[] {
		return execFs('fs/enumProjects') as ProjectDesc[];
	}

	static browseDir(path: string) {
		return execFs('fs/browseDir', path);
	}

	static showFile(fileName: string) {
		return execFs('fs/showFile', fileName);
	}

	static build(projectDir: string, debug: boolean, copyAssets: { from: string; to: string }[], projectDesc:ProjectDesc) {
		return execFsAsync('fs/build', projectDir, debug, copyAssets, projectDesc);
	}

	static watchDirs(dirs: string[]) {
		execFs('fs/watchDirs', dirs);
	}

	static isFilesEqual(fileName1: string, fileName2: string): false | string {
		return execFs('fs/isFilesEqual', fileName1, fileName2) as false | string;
	}

	static rebuildSoundsIfNeed(file: FileDesc) {
		if (file.assetType === AssetType.SOUND) {
			scheduledSoundsRebuilds.add(file.lib ? file.lib.dir : game.editor.currentProjectAssetsDir);
		}
	}

	static async setProgressBar(progress: number, operationName?:string) {
		if (progress >= 0) {
			assert(operationName, 'operationName expected.');
			if (!wakeLock) {
				wakeLock = true;
				try {
					wakeLock = await navigator.wakeLock.request('screen');
				} catch (_er) {}
			}
		} else {
			if (wakeLock && wakeLock !== true) {
				wakeLock.release();
				wakeLock = null;
			}
			assert(!operationName, 'operationName should be empty for progress clear.');
		}
		game.editor.ui?.modal.setSpinnerProgress(progress, operationName);
		execFs('fs/setProgressBar', progress, operationName);
	}

	static rebuildSounds(dir: string): object {
		const options = {
			dir,
			formats: game.editor.projectDesc.soundFormats,
			bitRates: game.editor.projectDesc.soundBitRates,
			defaultBitrate: game.editor.projectDesc.soundDefaultBitrate
		};
		return execFs('fs/sounds-build', options as any) as any;
	}

	static getArgs(): string[] {
		return execFs('fs/get-args') as any;
	}

	static getFolderAssets(dirName: string): FileDesc[] {
		assert(dirName.endsWith('/'), 'dirName should end with slash "/". Got ' + dirName);

		const lib: LibInfo | null = game.editor.currentProjectLibs.find(l => l.assetsDir === dirName) || null;
		const files = execFs('fs/readDir', dirName, game.editor.projectDesc as any) as FileDesc[];
		return files.filter((file) => {
			const wrongSymbol = fs.getWrongSymbol(file.fileName);
			if (wrongSymbol) {
				game.editor.ui.status.warn('File ' + file.fileName + ' ignored because of wrong symbol \'' + wrongSymbol + '\' in it\'s name', 32044,
					() => {
						fs.showFile(file.fileName);
					}, undefined, undefined, undefined, StatusClearingCondition.ASSETS_REFRESH);
				return;
			}
			const assetName = file.assetName || file.fileName.substring(dirName.length);
			for (const ext in ASSETS_PARSERS) {
				if (assetName.endsWith(ext)) {
					const assetType = (ASSETS_PARSERS as KeyedObject)[ext];
					file.assetName = assetName.substring(0, assetName.length - (ASSET_EXT_CROP_LENGTHS.get(assetType) as number));
					if (assetType === AssetType.CLASS) {
						file.assetName = file.assetName.replace(/-/g, '');
					}
					file.fileName = '/' + file.fileName;
					if (!file.assetType) { // can be already set in assets-loader.cjs
						file.assetType = assetType;
					}
					file.lib = lib;
					return true;
				}
			}
		});
	}

	static refreshAssetsList(dirNames?: string[]) {

		game.editor.ui.status.clearByCondition(StatusClearingCondition.ASSETS_REFRESH);

		if (dirNames) {
			assert(!lastAssetsDirs, 'dirNames already defined.');
			lastAssetsDirs = dirNames;
		} else {
			assert(lastAssetsDirs, 'dirNames is not defined.');
			dirNames = lastAssetsDirs;
		}

		prevAssetsByTypeByName = assetsByTypeByName;
		resetAssetsMap();
		allAssets = [];

		//console.log('refresh assets list');

		(assetsByTypeByName.get(AssetType.IMAGE) as Map<string, FileDesc>).set('EMPTY', EMPTY);
		(assetsByTypeByName.get(AssetType.IMAGE) as Map<string, FileDesc>).set('WHITE', WHITE);

		for (const dirName of dirNames!) {
			const files = fs.getFolderAssets(dirName);
			for (const file of files) {
				const map = assetsByTypeByName.get(file.assetType as AssetType) as Map<string, FileDesc>;
				if (file.assetType !== AssetType.CLASS && map.has(file.assetName) && !OVERRIDDEN_ASSETS.has(file.fileName)) {
					const existingFile = map.get(file.assetName)!;
					window.setTimeout(() => {
						const warn = fs.isFilesEqual(file.fileName, existingFile.fileName);
						if (warn) {
							game.editor.warnEqualFiles(warn, file, existingFile);
						}
					}, 0);
				}
				map.set(file.assetName, file);
			}
		}

		for (const assetsMap of assetsByTypeByName.values()) {
			for (const file of assetsMap.values()) {
				(assetsListsByType.get(file.assetType) as FileDesc[]).push(file);
				allAssets.push(file);

				const oldAsset = prevAssetsByTypeByName.get(file.assetType)!.get(file.assetName);
				if (!oldAsset) {
					fs.rebuildSoundsIfNeed(file);
					__onAssetAdded(file);
				} else {
					file.asset = oldAsset.asset;
					if (oldAsset.mTime !== file.mTime) {
						file.v = (oldAsset.v || 0) + 1;
						fs.rebuildSoundsIfNeed(file);
						__onAssetUpdated(file);
					} else {
						file.v = oldAsset.v;
						file._hashedAssetName = oldAsset._hashedAssetName;
					}
				}
			}
		}

		prevAssetsByTypeByName.forEach((prevAllAssets) => {
			prevAllAssets.forEach((file) => {
				if (!file.assetName.startsWith(EDITOR_BACKUP_PREFIX) && !fs.getFileByAssetName(file.assetName, file.assetType)) {
					if (file.parentAsset) {
						const newParentAsset = this.getFileByAssetName(file.parentAsset.assetName, file.parentAsset.assetType);
						file.parentAsset = newParentAsset;
						this.addSubAsset(file);
					} else {
						fs.rebuildSoundsIfNeed(file);
						__onAssetDeleted(file);
					}
				}
			});
		});

		sortAssets();

		let dirsToRebuildSounds = scheduledSoundsRebuilds.values();
		this.soundsData.clear();
		for (let dir of dirsToRebuildSounds) {
			this.soundsData.set(dir, fs.rebuildSounds(dir));
		}

		scheduledSoundsRebuilds.clear();

		editorEvents.emit('assetsRefreshed');
	}

	static soundsData: Map<string, KeyedObject> = new Map();

	static soundsRebuildInProgress() {
		return scheduledSoundsRebuilds.size;
	}

	static getFileHash(fileName: string): string {
		return execFs('fs/getFileHash', fileName) as any as string;
	}

	static getWrongSymbol(fileName: string) {
		const wrongSymbolPos = fileName.search(/[^@a-zA-Z_\-\.\d\/]/gm);
		if (wrongSymbolPos >= 0) {
			return fileName[wrongSymbolPos];
		}
	}

	static fieldsFilter = (key: string, value: any) => {
		if (!key.startsWith('___')) {
			return value;
		}
	};

	static exitWithResult(success: string | undefined, error?: string) {
		if (error) {
			console.log((new Error('exitWithResult ' + error).stack));
		}
		debugger; // stop before exit
		execFs('fs/exitWithResult', success, typeof error === 'string' ? error : JSON.stringify(error));
	}

	static showQuestion(title: string, message: string, yes: string, no: string, cancel?: string): number {
		return execFs('fs/showQuestion', title, message, yes, no, cancel) as number;
	}
}

const scheduledSoundsRebuilds: Set<string> = new Set();

export { AllAssetsTypes, AssetType };
export type { FileDesc, FileDescClass, FileDescImage, FileDescL10n, FileDescPrefab, FileDescScene, FileDescSound, LibInfo };
</file>

<file path="src/editor/localization-typings.ts">
export interface LocalizationKeys {
(id: 'example_title', values?: KeyedObject | number): string;
(id: 'gameOver', values?: KeyedObject | number): string;
(id: 'counter', values?: KeyedObject | number): string;
(id: 'menu', values?: KeyedObject | number): string;
(id: 'click_to_continue', values?: KeyedObject | number): string;
}
</file>

<file path="src/editor/preact-fabrics.ts">
import type { Container } from 'pixi.js';
import type { ComponentChild, ComponentChildren } from 'preact';
import { h, render } from 'preact';
import type { FileDescClass, FileDescImage } from 'thing-editor/src/editor/fs';
import EditorButton from 'thing-editor/src/editor/ui/editor-button';
import Tip from 'thing-editor/src/editor/ui/tip';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import type { Hotkey } from 'thing-editor/src/editor/utils/hotkey';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import { default as BasicR } from '../engine/basic-preact-fabrics';
import { CTRL_READABLE } from '../engine/utils/utils';

interface ComponentProps {
	className?: string;
	onClick?: ((ev: PointerEvent) => void) | (() => void);
	[key: string]: any;
}
const _iconsCache: KeyedMap<preact.Component> = {};

const assetsItemNameProps = {
	className: 'selectable-text class-name',
	title: CTRL_READABLE + '+click to copy class`s name',
	onMouseDown: copyTextByClick
};

const renderClass = (file: FileDescClass) => {
	return R.fragment(
		R.classIcon(file.asset),
		R.span(assetsItemNameProps,
			(file.asset).__className)
	);
};


class R extends BasicR {
	static div: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static form: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static span: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static p: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static img: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static button: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static label: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static b: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static a: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static br: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static hr: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static svg: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static td: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static tr: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static th: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static tbody: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static thead: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static table: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static polyline: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static textarea: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static iframe: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h2: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h3: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h4: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h5: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static script: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static meta: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static space: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static smallSpace: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;


	static btn(label: ComponentChild, onClick: (ev: PointerEvent) => void, title?: string, className?: string, hotkey?: Hotkey, disabled = false) {
		assert(typeof onClick === 'function', 'Function as onClick handler expected.');
		className = className || '';
		return h(EditorButton, { label, onClick, className, title, hotkey, disabled });
	}
	static icon(name: string) {
		if (!_iconsCache.hasOwnProperty(name)) {
			assert(name, 'Icon\'s name expected.');
			let src;
			if (name.startsWith('/')) {
				src = name;
			} else {
				src = '/thing-editor/img/' + name;
			}
			src += '.png';
			_iconsCache[name] = R.img({ src });
		}
		return _iconsCache[name];
	}
	static multilineText = (txt: ComponentChild) => {
		if (typeof txt !== 'string') {
			return txt;
		}
		return R.div(null, txt.split('\n').map((line, i) => {
			const lineProps = { key: i };
			const words = line.split(/[ :;,\(\)]/gm);
			words.some((word) => {
				if (/\.(ts|js|json)$/gm.test(word)) {
					(lineProps as any).onClick = () => {
						game.editor.editFile(word);
					};
					(lineProps as any).className = 'clickable';
					return true;
				}
			});
			return R.div(lineProps, line);
		}));
	};

	static imageIcon(file: FileDescImage) {
		if (file) {
			if (file.parentAsset) {
				const frame = (file.parentAsset.asset as any).frames[file.assetName].frame;
				const textureUrl = file.asset.baseTexture.resource.src;
				const scale = Math.min(30 / frame.w, 30 / frame.h);
				const width = frame.w * scale;
				return R.div({
					style: {
						verticalAlign: 'middle',
						display: 'inline-block',
						backgroundImage: 'url(' + ((file as FileDescImage).v ? (textureUrl + '?v=' + (file as FileDescImage).v) : textureUrl) + ')',
						objectFit: 'none',
						backgroundPosition: (-frame.x * scale) + 'px -' + (frame.y * scale) + 'px',
						marginLeft: (30 - width) / 2 + 'px',
						marginRight: (50 - width) / 2 + 'px',
						width: width + 'px',
						height: '30px',
						backgroundSize: (scale * file.asset.baseTexture.width) + 'px'
					}
				});
			} else {
				return R.img({
					className: 'preview-img',
					src: (file as FileDescImage).v ? (file.fileName + '?v=' + (file as FileDescImage).v) : file.fileName,
					onMouseEnter: onImageAssetEnter,
					onMouseLeave: onImageAssetLeave
				});
			}
		} else {
			return R.img({
				className: 'preview-img',
				src: '/thing-editor/img/wrong-texture.png',
				onMouseEnter: onImageAssetEnter,
				onMouseLeave: onImageAssetLeave
			});
		}
	}

	static classIcon = (constructor: SourceMappedConstructor) => {
		return R.icon(constructor.__EDITOR_icon || 'tree/game');
	};

	static sceneNode(node: Container) {

		let desc;
		if (node.__description) {
			desc = R.div(descriptionProps, node.__description.split('\n')[0]);
		}
		return R.div(sceneNodeProps,
			R.classIcon(node.constructor as SourceMappedConstructor),
			node.name ? R.span(nameProps, node.name) : undefined,
			R.span(classProps,
				'(' + (node.__nodeExtendData.unknownConstructor ||
					(node.constructor as SourceMappedConstructor).__className) + ') #' + node.___id
			),
			desc);
	}

	static tip = (id: string, header: string, text: string) => {
		return h(Tip, { id, header, text });
	};

	static input(props: ComponentProps): ComponentChild {
		if (props.hasOwnProperty('onChange') && !props.suspendOnChangeWarning && props.type !== 'checkbox' && props.type !== 'color') {
			debugger;
			//'onChage handler detected for "input" element. Use onInput instead', 99999, () => {
		}

		return h('input' as any, props);
	}
}

const descriptionProps = { className: 'tree-desc' };
let nameProps = {
	className: 'scene-node-name',
};
let classProps = { className: 'scene-node-class' };
let sceneNodeProps = { className: 'scene-node-item' };

let previewShown = false;
let assetPreviewTimeout = 0;

const imagePreviewContainer = window.document.createElement('div');
imagePreviewContainer.id = 'image-preview-container';
window.document.body.appendChild(imagePreviewContainer);

const hidePreview = () => {
	if (previewShown) {
		render(R.fragment(), imagePreviewContainer);
		previewShown = false;
	}
	if (assetPreviewTimeout) {
		clearTimeout(assetPreviewTimeout);
		assetPreviewTimeout = 0;
	}
};

window.addEventListener('mousedown', hidePreview);

Object.assign(R, BasicR);

const onImageAssetEnter = (ev: MouseEvent) => {
	hidePreview();
	let img: HTMLImageElement = (ev.target as HTMLImageElement);
	assetPreviewTimeout = window.setTimeout(() => {
		previewShown = true;
		render(R.div({
			onMouseLeave: onImageAssetLeave,
			style: {
				left: Math.max(0, ev.clientX - 128) + 'px',
				top: Math.max(128, ev.clientY) + 'px'
			},
			className: 'image-preview-tooltip fadein-animation'
		},
		R.div({
			className: 'image-preview-img',
			style: {
				backgroundImage: 'url("' + img.src + '")'
			}
		}),
		'(' + img.naturalWidth + ' × ' + img.naturalHeight + ')'
		), imagePreviewContainer);
	}, 100);
};

const onImageAssetLeave = () => {
	hidePreview();
};


export type { ComponentProps };
export default R;

export { renderClass };
</file>

<file path="src/editor/prefabs-typing.ts">
// thing-editor auto generated file.
import type Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';
import type MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type ParticleShort from 'thing-editor/src/engine/lib/assets/src/custom/particle-short.c';
import type Resizer from 'thing-editor/src/engine/lib/assets/src/extended/resizer.c';
import type PipesContainer from 'games/dear-project/assets/src/custom/pipes-contaner.c';
export default class TLib {
	static loadPrefab(prefabName: 'fader/default'):Container;
	static loadPrefab(prefabName: 'final-fader'):MovieClip;
	static loadPrefab(prefabName: 'particle-green'):ParticleShort;
	static loadPrefab(prefabName: 'ui/sure-question'):Resizer;
	static loadPrefab(prefabName: 'pipe'):Container;
	static loadPrefab(prefabName: 'pipes'):PipesContainer;
	static loadPrefab(prefabName: string): Container;
	static loadPrefab(prefabName: string): Container {
		return prefabName as any;
	}
}
</file>

<file path="src/editor/project-desc.ts">
export type ProjectOrientation = 'landscape' | 'portrait' | 'auto';

declare global {
	interface ProjectDesc {
		id: string;
		title: string;
		icon: string;
		mainScene: string;
		/** Path to project`s folder. Field generated by fs */
		dir: string;
		defaultFont: string;
		jpgQuality: number;
		screenOrientation: ProjectOrientation;
		width: number;
		height: number;
		portraitWidth: number;
		portraitHeight: number;
		renderResolution: number;
		renderResolutionMobile: number;
		framesSkipLimit: number;
		dynamicStageSize: boolean;
		__buildConfigDebug: string;
		__buildConfigRelease: string;
		preventUpscale: boolean;
		webfontloader: {
			custom?: {
				families: string[];
			};
			google?: {
				families: string[];
			};
			timeout: number;
		} | null | WebFont.Config;
		fontHolderText: string;
		mipmap: false;
		version: string;
		soundFormats: string[];
		soundDefaultBitrate: number;
		soundBitRates: KeyedMap<number>;
		loadOnDemandSounds: KeyedMap<number>;
		loadOnDemandTextures: KeyedMap<number>;
		defaultMusVol: number;
		defaultSoundsVol: number;
		embedLocales: boolean;
		__localesNewKeysPrefix: string;
		__doNotAutoCreateLocalizationFiles: string;
		__suspendWarnings: number[];
		defaultLanguage: string;
		autoFullScreenDesktop: false;
		autoFullScreenMobile: false;
		__group: string;
		libs: string[];
	}
}
</file>

<file path="src/editor/props-editor/editable.ts">
import type { DisplayObject } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';

/** editable property decorator */
function editable<T extends DisplayObject>(editablePropertyDesc?: EditablePropertyDescRaw<T>) {
	return function (target: T, propertyName: string) {
		editableInner(target, propertyName, editablePropertyDesc);
	};
}

/* Allows to define editable properties to the classes we has no access to source code.
To define editable properties for your own classes, please use '@editable()' decorator instead */
function _editableEmbed<T extends DisplayObject>(target: SourceMappedConstructor | SourceMappedConstructor[], propertyName: string, editablePropertyDesc?: EditablePropertyDescRaw<T>) {


	if (editablePropertyDesc && !editablePropertyDesc.name) {
		editablePropertyDesc.name = propertyName;
	}

	if (Array.isArray(target)) {
		for (let t of target) {
			editableInner(t.prototype as any, propertyName, editablePropertyDesc);
		}
	} else {
		editableInner(target.prototype as any, propertyName, editablePropertyDesc);
	}
}

function editableInner<T extends DisplayObject>(target: T, name: string, editablePropertyDesc?: EditablePropertyDescRaw<T>) {

	if (!target.constructor.hasOwnProperty('__editablePropsRaw')) {
		(target.constructor as SourceMappedConstructor).__editablePropsRaw = [];
		assert(target.constructor.hasOwnProperty('__editablePropsRaw'), 'Editable not own');
	}
	if (!editablePropertyDesc) {
		editablePropertyDesc = {};
	}

	if (editablePropertyDesc.hasOwnProperty('name')) {
		name = editablePropertyDesc.name!;
	}

	if (editablePropertyDesc.type === 'btn') {
		editablePropertyDesc.notSerializable = true;
		assert(editablePropertyDesc.name, 'property with type \'btn\' should have \'name\'. ');
	}
	editablePropertyDesc.name = name;

	let er = new Error('tmpError');
	let stack = (er.stack as string).split('\n');
	let lineIndex = stack.findIndex(line => line.indexOf('__decorateClass') > 0) + 1;
	if (lineIndex === 0) {
		lineIndex = stack.findIndex(line => line.indexOf('_editableEmbed') > 0) + 1;
	}

	let srcUrl = stack[lineIndex];

	let url = srcUrl.split(window.location.origin)[1];
	(editablePropertyDesc as EditablePropertyDesc).__src = url;

	(target.constructor as SourceMappedConstructor).__editablePropsRaw.push(editablePropertyDesc as EditablePropertyDescRaw);
}

export default editable;
export { _editableEmbed, propertyAssert };


const propertyAssert = (prop: EditablePropertyDesc, condition: any, message: string) => {
	if (!condition) {
		if (prop.__src) {
			game.editor.editSource(prop.__src);
		}
		message = 'Editable property "' + prop.name + '" of class "' + prop.class.__className + '" validation error: \n' + message;
		assert(condition, message);
	}
};
</file>

<file path="src/editor/schema-thing-project.json">
{
	"$schema": "http://json-schema.org/draft-04/schema#",
	"type": "object",
	"properties": {
		"title": {
			"description": "title visible in project list",
			"type": "string",
			"default": "my-project"
		},
		"id": {
			"description": "unique project id used to store local settings",
			"type": "string",
			"default": "my-project.my-website.com"
		},
		"mainScene": {
			"description": "default scene name for game.showScene method",
			"type": "string",
			"default": "main"
		},
		"icon": {
			"description": "path to the image file - which will be displayed as an project`s icon in projects list.",
			"type": "string",
			"default": "assets/bunny.png"
		},
		"__group": {
			"description": "groups projects in the projects list",
			"type": "string",
			"default": "my-projects/cool-projects"
		},
		"screenOrientation": {
			"description": "projects screen orientation",
			"type": "string",
			"enum": [
				"landscape",
				"portrait",
				"auto"
			],
			"default": "landscape"
		},
		"width": {
			"description": "landscape width of project screen",
			"type": "number",
			"default": 1280
		},
		"height": {
			"description": "landscape height of project screen",
			"type": "number",
			"default": 720
		},
		"portraitWidth": {
			"description": "width of project in portrait mode",
			"type": "number",
			"default": 720
		},
		"portraitHeight": {
			"description": "height of project in portrait mode",
			"type": "number",
			"default": 1280
		},
		"renderResolution": {
			"description": "increases quality of render on desktop in cost of performance.",
			"type": "number",
			"default": 1
		},
		"renderResolutionMobile": {
			"description": "increases quality of render on mobile devices in cost of performance.",
			"type": "number",
			"default": 1
		},
		"framesSkipLimit": {
			"description": "on low performance devices allows to update game logic more that once per each frame.",
			"type": "number",
			"default": 4
		},
		"dynamicStageSize": {
			"description": "enables stage resizing regarding of allowed screen space. false - keeps projects screen proportions always fixed.",
			"type": "boolean",
			"default": false
		},
		"preventUpscale": {
			"description": "makes project screen size be equal to all allowed screen area, but not less that defined in 'width' and 'height'",
			"type": "boolean",
			"default": false
		},
		"webfontloader": {
			"description": "allows to preload fonts form google.fonts or from project`s assets folder",
			"type": "object",
			"properties": {
				"google": {
					"description": "list of fonts should be loaded from https://fonts.google.com/",
					"type": "object",
					"properties": {
						"families": {
							"type": "array",
							"items": {
								"type": "string"
							},
							"default": [
								"Fira Sans:300,400,700:cyrillic"
							]
						}
					}
				},
				"custom": {
					"description": "list of fonts should be loaded from project assets.",
					"type": "object",
					"properties": {
						"families": {
							"type": "array",
							"items": {
								"type": "string"
							},
							"default": [
								"Soup Of Justice"
							]
						}
					}
				}
			}
		},
		"defaultFont": {
			"description": "font used for render Text objects with no fontFamily property defined",
			"type": "string",
			"default": "Fira Sans, Arial"
		},
		"jpgQuality": {
			"description": "output build jpg quality 0 - 100",
			"type": "number",
			"default": 80
		},
		"soundFormats": {
			"description": "List of sounds formats which will be generated for project. Required because there is no format all the browsers support. Usually ogg + aac covers all the browsers you need.",
			"type": "array",
			"items": {
				"type": "string"
			},
			"default": [
				"ogg",
				"aac"
			]
		},
		"soundDefaultBitrate": {
			"description": "sounds default bitrate for auto generated ogg and aac files.",
			"type": "number",
			"default": 48,
			"enum": [
				8,
				16,
				24,
				32,
				40,
				48,
				56,
				64,
				80,
				96,
				112,
				128,
				144,
				160,
				192,
				224,
				256
			]
		},
		"fontHolderText": {
			"description": "invisible peace of text added to the web page for each loaded font, to keep web fonts from unloading. Add a few characters of your language if fonts in game look wrong.",
			"type": "string",
			"default": "ЯSфz"
		},
		"__buildConfigDebug": {
			"description": "path to vite config used for debug build.",
			"type": "string",
			"default": "thing-editor/electron-main/build-config.js"
		},
		"__buildConfigRelease": {
			"description": "path to vite config used for release build.",
			"type": "string",
			"default": "thing-editor/electron-main/build-config.js"
		},
		"loadOnDemandSounds": {
			"description": "info about way assets loading in to project. Usually this data generated automatically.",
			"type": "object",
			"default": {}
		},
		"mipmap": {
			"description": "enables mipmap generation for all textures. prevent aliasing effect on small size sprites.",
			"type": "boolean",
			"default": false
		},
		"version": {
			"description": "your project`s version",
			"type": "string",
			"default": "0.0.1"
		},
		"defaultMusVol": {
			"description": "default global volume level for all BgMusic",
			"type": "number",
			"default": 1
		},
		"defaultSoundsVol": {
			"description": "default global volume level for all sounds",
			"type": "number",
			"default": 1
		},
		"embedLocales": {
			"description": "built in all localization data in to projects`s assets.",
			"type": "boolean",
			"default": true
		},
		"__localesNewKeysPrefix": {
			"description": "all new created localization keys will start with this prefix.",
			"type": "string",
			"default": ""
		},
		"__doNotAutoCreateLocalizationFiles": {
			"description": "disable automatic creation of localization files for all languages.",
			"type": "boolean",
			"default": "false"
		},
		"__suspendWarnings": {
			"description": "suspends all warnings with listed codes.",
			"type": "array",
			"items": {
				"type": "number"
			},
			"default": []
		},
		"defaultLanguage": {
			"description": "language will be used if no users language present in localization data",
			"type": "string",
			"default": "en"
		},
		"autoFullScreenDesktop": {
			"description": "go to full-screen mode on desktop, after first user click.",
			"type": "boolean",
			"default": false
		},
		"autoFullScreenMobile": {
			"description": "go to full-screen mode on mobile, after first user click.",
			"type": "boolean",
			"default": true
		},
		"libs": {
			"description": "List of thing-libraries included in project. 'thing-editor/src/engine/lib' system library always included by default.",
			"type": "array",
			"items": {
				"type": "string"
			},
			"default": [
				"my-library"
			]
		}
	},
	"title": "JSON schema for thing-editor configuration files"
}
</file>

<file path="src/editor/style-spine-sequence.css">
#spine-sequence {
	border: 1px solid #682e24;
}

.spine-sequence-wrapper {
    display: flex;
}

.spine-sequence-headers {
	white-space: nowrap;
	text-align: right;
	margin: 20px 0;
	flex-shrink: 1;
    width: 130px;
	overflow-x: hidden;
	max-height: 175px;
}

.spine-sequence-header {
	padding: 4px 10px;
}
.spine-sequence-header:hover {
	background-color: #333333;
}

.spine-sequence-random {
	position: absolute;
    left: -7px;
    top: -7px;
    text-align: center;
	color: #fff;
    width: 20px;
    border-radius: 20px;
    background-color: #5a0056;
}

.spine-sequence-header-active {
	background-color: #181818;
	border-top-left-radius: 20px;
	border-bottom-left-radius: 20px;
}

.spine-sequence-header-playing {
	color: #cc1616;
}

.spine-sequence-body {
	white-space: nowrap;
	background-color: #181818;
	flex-grow: 1;
	overflow-y: hidden;
	border-radius: 20px;
	padding: 10px;
    padding-top: 30px;
	position: relative;
}

.spine-sequence-body button {
	vertical-align: top;
}

.spine-sequence-item-wrapper {
	display: inline-block;
	position: relative;
}

.spine-sequence-item {
	width: 100%;
	height: 40px;
	box-sizing: border-box;
	white-space: nowrap;
	overflow: hidden;
	padding: 0;
	margin-right: 3px;
	background-color: #222222;
	border-radius: 20px;
	display: inline-block;
	border: 1px solid #000000;
	position: relative;
}

.spine-sequence-action-time-pointer {
	position: absolute;
	left: -1px;
	bottom: 10px;
	height: 50px;
	border-left: 1px solid #333333;
}

.spine-sequence-action-active .spine-sequence-action-time-pointer {
	border-left: 1px solid #eb8000;
}

.spine-sequence-item-name {
	padding-left: 10px;
	position: absolute;
	top: 10px;
}

.spine-sequence-action {
	position: absolute;
	width: 8px;
	height: 20px;
	border: 1px solid #333333;
	cursor: ew-resize;
	background-color: #c1c1c1;
}

.spine-sequence-action-empty {
	background-color: #cc1616;
}

.spine-sequence-action img {
    pointer-events: none;
}

.spine-sequence-action-active {
	border: 1px solid #eb8000;
}

.spine-sequence-action:hover {
	background-color: #d1d1d1;
}

.spine-sequence-item-delay {
	position: absolute;
	height: 100%;
	background-color: #33333366;
	border-right: 1px solid #000;
}

.spine-sequence-item-loop {
    position: absolute;
    left: 4px;
    bottom: 0px;
    border-left: 3px solid #339955;
    padding-left: 4px;
    font-size: 70%;
    color: #339955;
}

.spine-sequence-item-active {
	cursor: ew-resize;
	border: 1px solid #eb8000;
}

.spine-sequence-item-invalid {
	border: 1px solid #cc1616;
	color: #cc1616;
}

.spine-sequence-item-props-editor {
	padding: 10px;
	flex-shrink: 1;
}

.spine-sequence-mix-view {
	position: absolute;
	left: 0;
	top: 0;
	fill: #00000088;
	stroke: none;
}

.spine-sequences-actions-body {
	position: absolute;
	left: 0;
	top: 40px
}
</file>

<file path="src/editor/style-timeline.css">
#timeline {
	border: 1px solid #682e24;
}

.timeline {
	padding-top: 30px;
	position: absolute;
	cursor: pointer;
	bottom: 40px;
	top: 0;
	right: 0;
	left: 0;
	padding-left: 110px;
	overflow-x: auto;
	background: #292929;
}

.timeline-labels-background {
	top: 0;
	height: 100%;
	background: #353535;
	z-index: 1;
}

.timeline-fixed-block {
	cursor: default;
	left: 0;
	top: 0;
	width: 110px;
	position: absolute;
}


.objects-timeline {
	position: relative;
	margin-top: 40px;
}

.objects-timeline-labels {
	text-align: right;
	padding-right: 6px;
	font-weight: bold;
	box-sizing: border-box;
	margin-left: -110px;
	z-index: 2;
}

.preview-frame-marker {
	color: #8c8f9a;
	top: 25px;
	position: absolute;
	font-size: 70%;
	border-left: 1px solid #1dd11d;
	height: 20px;
}

.field-timeline {
	width: max-content;
	background: url(/thing-editor/img/timeline.jpg);
	background-repeat: repeat-x;
	position: relative;
}

.timeline-play-indicator {
	pointer-events: none;
	position: absolute;
	height: 30px;
	border-left: 1px solid #f00;
}

.timeline-fire-indicator {
	pointer-events: none;
	animation: fireAnimation linear 0.5s;
	animation-iteration-count: 1;
	animation-fill-mode: forwards;
	position: absolute;
	height: 24px;
	width: 8px;
	border: 1px solid #f00;
}

.timeline-speed-set-marker {
	position: absolute;
	bottom: -6px;
}

.timeline-keyframe {
	cursor: w-resize;
	position: absolute;
}

.timeline-keyframe img {
	pointer-events: none;
}

.timeline-keyframe-unreachable {
	opacity: 0.5;
	outline: 1px solid #f00;
}

.timeline-keyframe-selected {
	outline: 2px solid #eb8000;
}

.keyframe-callback-editor .props-editor-callback:focus {
	min-width: 800px;
	max-width: 800px;
}

.timeline-loop-point {
	cursor: w-resize;
	position: absolute;
	bottom: 0;
	height: 14px;
}

.timeline-loop-point-selected,
.timeline-loop-point:hover {
	outline: 2px solid #8d8d8d;
}

.timeline-loop-point-owner-selected {
	outline: 2px solid #8d8d8d;
}

.timeline-label-selected {
	outline: 2px solid #8d8d8d;
}

.timeline-keyframe-linear {
	background: #8db2ff;
	border-left: 1px solid #456aa1;
}

.timeline-keyframe-discrete {
	background: #c1c1c1;
	border-left: 1px solid #505050;
}

.timeline-keyframe-smooth {
	border-top-right-radius: 70%;
	border-bottom-right-radius: 70%;
	background: #0eca75;
	border-left: 1px solid #2b3a00;
}

.timeline-keyframe-jump-floor {
	border-bottom-left-radius: 70%;
	border-bottom-right-radius: 70%;
	background: #e2c200;
	border-left: 1px solid #ad7000;
}

.timeline-keyframe-jump-roof {
	border-top-left-radius: 70%;
	border-top-right-radius: 70%;
	background: #e2c200;
	border-left: 1px solid #ad7000;
}

.timeline-select-frame {
	pointer-events: none;
	position: absolute;
	border: 1px dashed #080;
}

.loop-arrow {
	pointer-events: none;
	position: absolute;
	right: 100%;
	bottom: -13px;
	fill: none;
	stroke: rgb(0, 136, 0);
	stroke-width: 1.5;
}

.timeline-keyframe:nth-child(3n) .loop-arrow {
	stroke: rgb(0, 103, 106);
}

.timeline-keyframe:nth-child(3n+1) .loop-arrow {
	stroke: rgb(106, 104, 0);
}

.keyframe-random-meter {
	pointer-events: none;
	position: absolute;
	left: 0;
	top: -3px;
	fill: none;
	stroke: rgb(41, 119, 184);
	stroke-width: 1.5;
	left: unset;
	right: 100%;
}

.timeline-keyframe-selected .keyframe-random-meter {
	stroke: rgb(194, 75, 28);
	z-index: 1;
}


.loop-arrow-front {
	transform: scaleX(-1);
	transform-origin: right;
}

.timeline-chart {
	position: absolute;
	fill: none;
	stroke: #9c9c9c;
	stroke-width: 1.5;
	pointer-events: none;
}

.timeline-settings {
	margin-left: 0;
}

.time-marker-body {
	top: 0;
	position: absolute;
	width: 100%;
	height: 21px;
	z-index: 1;
	background: #3b3b3b;
}

.time-marker {
	cursor: w-resize;
	width: 8px;
	height: 23px;
	position: absolute;
	top: 0;
	background: #d33;
}

.time-marker-v-line {
	position: absolute;
	pointer-events: none;
	height: 1000px;
	margin-bottom: -1000px;
	border-left: 1px solid #d33;
}

.time-marker-label {
	width: 160px;
	margin: 2px 12px;
	background: #3b3b3b;
	color: #b5b5b5;
	pointer-events: none;
}

.bottom-panel {
	overflow-x: hidden;
	display: flex;
	align-items: center;
	white-space: nowrap;
	padding: 0 8px;
	position: absolute;
	width: calc(100% - 14px);
	bottom: 8px;
	box-sizing: border-box;
}

.bottom-panel .number-input input {
	max-width: 50px;
	min-width: 50px;
}

.bottom-panel input[type=checkbox] {
	min-width: 20px;
}

.bottom-panel button {
	background-color: #181818;
	padding: 0 3px;
	border: none;
}

.bottom-panel .select-editor {
	min-width: 92px;
	max-width: 92px;
}

.bottom-panel .breakpoint-btn {
	pointer-events: all;
}

.select-item,
.select-editor-current {
	white-space: nowrap;
	padding: 3px 10px;
	line-height: 19px;
}

.timeline-buttons-group {
	display: inline-block;
	background: #282828;
	padding-left: 0;
	border-radius: 14px;
	margin: 1px;
}

.timeline-time-number {
	top: 2px;
    position: absolute;
    color: #636363;
}

.timeline-field-name {
	display: block;
    background-color: #292929;
    height: 24px;
    padding-top: 2px;
    padding-right: 5px;
    border-top-left-radius: 20px;
    border-bottom-left-radius: 20px;
    width: 100px;
}

.objects-timeline-labels button {
	padding: 0 4px;
	border-radius: 2px;
	margin: 1px;
	background: transparent;
	vertical-align: top;
}

.timeline-labels-panel {
	height: 26px;
	position: absolute;
	top: -37px;
	width: 100%;
	background: #414141;
}

.timeline-label {
	position: absolute;
	background: #814833;
	border-top-right-radius: 20px;
	color: #dba08a;
	margin-top: 7px;
	padding: 0 5px;
	padding-right: 15px;
	cursor: w-resize;
}

.timeline-label-tip {
	background-color: transparent;
	color: #0c0;
	outline: none !important;
	top: -18px;
}

.timeline-label:hover {
	z-index: 1;
	text-decoration: underline;
}

.timeline-label-tip:hover {
	z-index: 1;
	text-decoration: none;
}

.timeline-label-pointer {
	height: 26px;
	bottom: 0;
	left: -1px;
	width: 2px;
	position: absolute;
	background: #814833;
}

.timeline-label-tip .timeline-label-pointer {
	background: #0c0;
	top: 11px;
}

.tip-icon {
	font-family: sans-serif;
	font-weight: bold;
	display: inline-block;
	border-radius: 50%;
	background: #b97852;
	color: #ffe564;
	text-align: center;
	cursor: pointer;
	padding: 0 4px;
}

.tip-icon:hover {
	transform: scale(1.3);
}

.tip-discard-btn {
	border-radius: 20px;
	position: absolute;
	padding: 2px 20px;
	right: 19px;
	background: #440000;
	top: 0px;
}

.tip-container {
	background: #3e3e3e;
	color: #eae3be;
	padding: 10px;
	display: block;
	z-index: 4;
	text-align: left;
	cursor: initial;
}

.tip-discard-btn {
	position: absolute;
	right: 0;
	top: 0;
}

.tip-paragraph {
	margin: 10px;
	line-height: 1.6;
}

@keyframes fireAnimation {
	0% {
		opacity: 1;
	}

	50% {
		opacity: 1;
	}
	
	100% {
		opacity: 0;
	}
}
</file>

<file path="src/editor/style.css">
:root {
	--window-bg-color: #222222;
	--bg-color: #111111;
	--window-header-color: #333333;
}

html {
	image-rendering: pixelated;
	height: 100%;
	overflow: hidden;
}

space {
	display: inline-block;
	width: 25px;
	height: 25px;
}

smallSpace {
	display: inline-block;
	width: 6px;
	height: 6px;
}

::selection {
	color: rgb(197, 197, 197);
	background: rgb(68, 86, 146);
}

body {
	background: var(--bg-color);
	overflow: hidden;
	color: #737988;
	line-height: normal;
	font-family: Roboto, RobotoDraft, Helvetica, Arial, sans-serif;
	padding: 0;
	margin: 0;
	user-select: none;
	width: 100%;
	height: 100%;
}

img {
	vertical-align: middle;
}

button {
	border-radius: 300px;
	border: none;
	background-color: #1d1e1f;
	color: #bdc3d3;
	padding: 10px 20px;
}

button:hover {
	background-color: #252627;
}

hr {
	border: none;
	border-top: 1px solid #555555;
}

.toggled-button {
	border: 2px solid #777777;
}

.clickable {
	cursor: pointer;
}

#root {
	height: 100%;
}

.transparent {
	opacity: 0;
}

.hidden {
	display: none;
}

.main-menu {
	height: 24px;
	background-color: #222222;
}

.main-menu button:focus-visible {
    outline: none;
}

.main-menu button:focus {
	border: 1px solid #777;
	border-bottom: 1px solid transparent;
	border-bottom-left-radius: 0;
	border-bottom-right-radius: 0;
}

.main-menu button {
	border-radius: 15px;
	border: 1px solid transparent;
	box-sizing: border-box;
	height: 22px;
	margin: 1px;
	padding: 3px 10px;
}

#working-area {
	overflow: visible;
	position: relative;
	height: calc(100% - 24px);
}

.unclickable {
	vertical-align: middle;
	pointer-events: none;
	opacity: 0.3;
}

.window-body {
	border: 1px solid var(--bg-color);
	box-sizing: border-box;
	position: absolute;
	background: var(--window-bg-color);
}

.window-header {
	width: 100%;
	height: 17px;
	border-top-left-radius: 2px;
	border-top-right-radius: 2px;
	background: var(--window-header-color);
	color: #9ab;
	cursor: move;
	font-size: 70%;
	padding: 2px;
	padding-left: 10px;
	box-sizing: border-box;
	position: relative;
}

.window-content {
	display: flex;
	flex-direction: column;
	box-sizing: border-box;
	position: absolute;
	right: 0;
	left: 0;
	bottom: 0;
	top: 17px;
	padding: 7px;
}

.window-scrollable-content {
	flex-grow: 1;
	overflow-y: overlay;
	overflow-x: hidden;
	margin-right: -6px !important;
	padding-right: 6px !important;
}


.window-rb-corner {
	position: absolute;
	right: -2px;
	bottom: -2px;
	width: 8px;
	height: 8px;
	cursor: se-resize;
}

.window-lt-corner {
	position: absolute;
	left: -2px;
	top: -2px;
	width: 8px;
	height: 8px;
	cursor: se-resize;
}

.window-lb-corner {
	position: absolute;
	left: -2px;
	bottom: -2px;
	width: 8px;
	height: 8px;
	cursor: ne-resize;
}

.window-rt-corner {
	position: absolute;
	right: -2px;
	top: -2px;
	width: 8px;
	height: 8px;
	cursor: ne-resize;
}

.window-r-dragger {
	position: absolute;
	right: -2px;
	top: 0;
	width: 8px;
	height: 100%;
	cursor: e-resize;
}

.window-l-dragger {
	position: absolute;
	left: -2px;
	top: 0;
	width: 8px;
	height: 100%;
	cursor: e-resize;
}

.window-b-dragger {
	position: absolute;
	bottom: -2px;
	left: 0;
	width: 100%;
	height: 8px;
	cursor: n-resize;
}

.window-t-dragger {
	position: absolute;
	top: -4px;
	left: 0;
	width: 100%;
	height: 8px;
	cursor: n-resize;
}

.window-dragger {
	position: absolute;
	width: 100%;
	top: 0;
	height: 100%;
	cursor: move;
}

.window-menu {
	z-index: 1;
	position: absolute;
	right: 0;
	top: -17px;
}

.window-menu-btn {
	position: absolute;
	right: 0;
	top: 0;
	margin: 0;
	padding: 1px 3px;
	border: none;
	z-index: 1;
	background: transparent;
}

.window-menu-body {
	animation: scale-up-tr 0.1s ease-out forwards;
	position: relative;
	top: -3px;
	right: -3px;
	padding: 10px;
	padding-right: 30px;
	background: #1e1e1e;
}

.window-menu-body button {
	padding: 2px;
	width: 32px;
	height: 32px;
}


::-webkit-scrollbar {
	width: 6px;
	height: 15px;
	position: fixed;
}

::-webkit-scrollbar-track {
	background: transparent;
}

::-webkit-scrollbar-thumb {
	background: #131313;
}

::-webkit-scrollbar-thumb:hover {
	background: #000000;
}

::-webkit-scrollbar-corner {
	background: transparent;
}

textarea {
	padding: 2px 10px;
	border-radius: 10px;
	min-height: 25px;
}

input,
textarea {
	padding: 3px;
	margin: 2px;
	background: #181818;
	color: #8d96a3;
	border: none;
}

input:disabled,
textarea:disabled {
	background: #1b1b1b;
}

input:focus-visible,
textarea:focus-visible {
	outline-offset: 0;
	outline: 1px solid #3a8cff;
}

.selectable-text {
	font-family: Consolas, "Courier New", monospace;
	cursor: text;
	pointer-events: all;
	overflow: hidden;
	text-overflow: ellipsis;
	flex-shrink: 11;
}

.error-help-button {
	margin: 0;
	padding: 3px 10px;
	position: absolute;
	right: 10px;
}

.modal-blackout {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 1000;
	background: rgba(0, 10, 30, 0.7);
}

.modal-spinner {
	margin: auto;
	margin-top: 120px;
	border: 10px solid rgba(0, 0, 0, 0);
	border-top: 10px solid #bfbfbf;
	border-left: 10px solid #bfbfbf;
	border-radius: 50%;
	width: 60px;
	height: 60px;
	background: rgba(0, 0, 0, 0.3);
	animation: spin 2s linear infinite;
}

.modal-spinner-overlay {
	margin: auto;
	margin-top: -69px;
	border-radius: 50%;
	width: 70px;
	height: 70px;
	position: relative;
	background: #000;
}

.modal-spinner-progress {
	margin: auto;
	margin-top: 190px;
	border: 5px solid #223344;
	width: 360px;
	height: 50px;
	background: rgba(0, 0, 0, 0.8);
	overflow: hidden;
	border-radius: 35px;
	text-align: center;
	line-height: 0;
}

.modal-spinner-progress div {
	margin-bottom: -25px;
	height: 50px;
	background-color: #002c23;
}

.modal-title {
	background: #3b3b3b;
	padding: 10px 20px;
	color: #b1c0d0;
	font-weight: bold;
	position: relative;
}

.modal-title img {
	max-height: 20px;
	margin-right: 10px;
}

.modal-body {
	margin: auto;
	margin-top: 100px;
	cursor: initial;
	width: min-content;
	min-width: 500px;
}

.modal-content {
	text-align: center;
	padding: 20px;
	position: relative;
	background: var(--window-bg-color);
	max-height: 70vh;
	overflow-y: overlay;
}

.modal-content .preview-img {
    max-height: 500px;
    max-width: 500px;
}

.choose-list-header {
	display: flex;
	margin-bottom: 20px;
}

.list-view {
	overflow-y: overlay;
	max-height: 60vh;
}

.clickable.choosing-item:hover {
	background-color: #28292a;
}

.choosing-item {
	white-space: nowrap;
	padding: 4px;
	border-bottom: 1px solid #424242;
	position: relative;
}

.props-editor .props-header {
	position: absolute;
	z-index: 1000;
	width: calc(100% - 20px);
	background: var(--window-bg-color);
}

.props-editor .props-group:nth-of-type(2) {
	margin-top: 32px;
}

.refused-item {
	opacity: 0.5;
	cursor: default;
}

.choosing-item b {
	color: #aaaaaa;
}

.choosing-item img {
	margin-right: 10px;
}

.choose-list-header button {
	padding: 3px;
}

input {
	padding: 3px 10px;
	border-radius: 15px;
	box-sizing: border-box;
}

.left-align-text {
	text-align: left;
}

.modal-content input {
	font-size: 130%;
	width: 100%;
	padding: 5px 13px;
}

.main-btn {
	font-size: 120%;
	color: #008f5f;
}

.modal-reject-text {
	height: 33px;
	color: #ff0000;
}

.modal-content textarea {
	width: 50vw;
	height: 50vh;
}

.modal-footer {
	margin-top: 20px;
}

.error {
	color: #be0000;
	text-align: left;
	user-select: text;
}

.error .clickable {
	text-decoration: underline;
}

.error .clickable:hover {
	color: #ffffff;
}

.modal-notification-wrapper {
	max-width: 300px;
	position: fixed;
	pointer-events: none;
	z-index: 1100000;
}

.modal-notification-centred {
	right: calc(50% - 300px);
	bottom: unset;
	top: 20%;
	width: 600px;
}

.modal-notification {
	word-wrap: break-word;
	padding: 10px 20px;
	border-radius: 5px;
	background: #4b4e4e;
	color: #dddddd;
}

.props-field,
.props-field input,
.field-editor-wrapper input {
	font-family: Consolas, "Courier New", monospace;
}

.props-group .props-group {
	margin: 8px;
}

.props-group {
	margin-bottom: 3px;
	border-radius: 13.5px;
	border: 1px solid var(--window-header-color);
	overflow: hidden;
}

.props-group:has(.props-group-header:hover) {
	border-color: #444444;
}

.props-editor .props-group:not(:has(.props-field)) {
	display: none;
}

#property-editor-angle .props-label:before {
	content: "\00b0"
}

.field-editor-wrapper {
	flex-grow: 2;
	display: flex;
}

.field-editor-wrapper button {
	padding: 3px;
}

.props-group-splitter-helpers .props-group-header,
.props-label-helper {
	font-size: small;
}

.props-group-header {
	cursor: pointer;
	padding: 3px 15px;
	background-color: var(--window-header-color);
	color: #a3adb7;
}

.editor-viewport {
	display: flex;
	align-items: center;
	justify-content: center;
	background-color: #1a1a1a;
	width: 100%;
	height: 100%;
	overflow: hidden;
	position: relative;
}

.status-entry {
	margin-left: 10px;
	color: #686868;
}

.red-frame {
	outline: 1px solid #aa0000;
	outline-offset: -2px;
}

.editor-viewport-wrapper {
	display: flex;
	position: absolute;
	left: 0;
	top: 0;
	bottom: 0;
	right: 0;
}

.editor-viewport canvas {
	max-height: 100%;
	max-width: 100%;
	image-rendering: initial;
}

.viewport-panel-wrapper {
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.viewport-panel {
	max-width: 75px;
	display: flex;
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
}

.viewport-panel-wrapper button {
	width: 100%;
}

.prefabs-mode-title {
	overflow: hidden;
	max-width: 64px;
	text-overflow: ellipsis;
}

.viewport-bottom-panel {
	justify-content: flex-end;
}

.tree-item {
	position: relative;
	overflow-x: hidden;
}

.item-prefab-reference {
	border-right: 3px dotted #676d12;
}

.item-prefab-reference-unknown {
	border-right: 3px dotted #ff0000;
}

.tree-children .tree-item {
	padding-left: 10px;
	background-position: left top;
	background-repeat: no-repeat;
	background-image: url("/thing-editor/img/child.jpg");
}


.tree-children .tree-item:last-child {
	background-image: url("/thing-editor/img/child-last.jpg");
}

.scene-node-item {
	position: relative;
	white-space: nowrap;
	padding: 2px 0;
	cursor: pointer;
}

.scene-node-item:hover {
	background: #323334;
}

#window-info .scene-node-item {
	display: inline-block;
}

#window-info .status-body {
	overflow-y: auto;
}

.tree-desc {
	margin-bottom: 4px;
	margin-left: 18px;
	color: #318331;
	font-size: 90%;
}

.scene-node-name {
	margin-left: 2px;
	font-weight: bold;
}

.scene-node-class {
	font-size: 85%;
}

.list-item {
	position: relative;
	white-space: nowrap;
	padding: 2px;
	cursor: pointer;
}

.list-item:hover {
	background: #3a3c49;
}

.list-item img {
	margin-right: 4px;
}

.item-selected {
	cursor: default;
	background: #2c4145;
	color: #bbbbbb;
}

.tree-caret {
	position: absolute;
	right: -8px;
	top: 0;
	font-size: 200%;
	pointer-events: none;
	line-height: 50%;
}

.tree-children {
	padding-left: 5px;
}

.tree-children .tree-children {
	padding-left: 15px;
	border-left: 1px solid #565656;
}

.props-field {
	border-bottom: 1px solid #111111;
	display: flex;
	align-items: center;
}

.props-field input {
	width: 100%;
}

.props-field textarea {
	width: 100% !important;
	height: 70px;
	box-sizing: border-box;
	display: block;
}

.props-field-btn .props-label {
	display: none;
}

.props-field:last-child {
	border-bottom: none;
}

.props-field-important {
	background: #023407;
	color: #68af3f;
}

.props-field-invalid {
	background: #ffcfd4;
	color: #aa0e00;
}

.props-field-invalid input {
	text-decoration: underline wavy red;
}

.props-field-important input {
	font-weight: bold;
}

.props-field-btn button {
	margin: 4px;
	padding: 6px 15px;
}

.props-label {
	padding-left: 10px;
	box-sizing: border-box;
	width: 50%;
	max-width: 200px;
	color: #3a8cff;
	overflow-x: hidden;
}

.props-label-helper {
	color: #999999;
}

.props-wrapper {
	text-align: center;
	width: 50%;
	flex-grow: 1;
	box-sizing: border-box;
}

.default-value {
	color: #0eca75;
	font-size: 130%;
}

.props-wrapper-default-value .props-label {
	opacity: 0.5;
}

.semi-transparent {
	opacity: 0.5;
}

.number-input {
	display: block;
	position: relative;
	overflow: hidden;
}

.number-input-btn {
	overflow: hidden;
	padding: 0 5px;
	position: absolute;
	display: inline-block;
	line-height: 0.7;
	height: 11px;
	right: 0;
	cursor: pointer;
	font-size: 90%;
	color: #444444;
	height: 11px;
}


.number-input-btn:hover {
	color: #555555;
}

.number-input-btn:active {
	transform: scale(0.8);
}

.number-input-btn-up {
	top: 2px;
}

.number-input-btn-down {
	bottom: 2px;
}

.color-input {
	display: inline-flex;
	vertical-align: middle;
}

.color-input-eyedropper:hover {
	background-color:  #414229;
}

.color-input-sample {
	width: 40px;
	display: inline-block;
	height: 20px;
	border: 1px solid #888888;
	border-radius: 10px;
}

.color-input-sample:hover {
	border-color: #cecc62;
}

.color-sample {
	text-align: center;
	display: inline-block;
	width: 31px;
	margin-top: -4px;
	padding: 0;
	height: 16px;
	border: 1px solid #777777;
}

.color-slider {
	box-sizing: border-box;
	padding: 10px;
	background-color: var(--window-bg-color);
	position: absolute;
	z-index: 1001;
	border: 1px solid #555555;
	border-radius: 4px;
	text-align: center;
	width: 314px;
	height: 500px;
}

.color-slider .number-input{
	display: inline-block;
	vertical-align: middle;
	width: 60px;
	margin-right: 10px;
}

.color-slider input{
	border-radius: 13px;
}

.color-slider-sl {
	display: inline-block;
	width: 256px;
	height: 256px;
	cursor: pointer;
	position: relative;
	margin-bottom: 10px;
}

.color-slider-hue {
	background: linear-gradient(0deg,red,#ff0 17%,#0f0 33%,#0ff 50%,#00f 66%,#f0f 83%,red);
	margin-left: 10px;
	display: inline-block;
	width: 24px;
	height: 256px;
	cursor: pointer;
	position: relative;
	margin-bottom: 10px;
}

.color-slider-sl-point {
	pointer-events: none;
	position: absolute;
	width: 2px;
	height: 2px;
	background-color: #000000;
	border: 2px solid #ffffff;
}

.color-slider-hue-point {
	pointer-events: none;
	position: absolute;
	width: 32px;
	height: 2px;
	left: -6px;
	border: 2px solid #ffffff;
}

input[type=checkbox] {
	cursor: pointer;
	float: left;
	background: #181818;
	appearance: none;
	height: 21px;
	background-image: url("/thing-editor/img/check-box.png");
	background-repeat: no-repeat;
	background-position: center;
}

input[type=checkbox]:checked {
	background-image: url("/thing-editor/img/check-box-check.png");
}

input[disabled] {
	opacity: 0.5;
}


.disabled {
	opacity: 0.5;
	pointer-events: none;
}

.select-editor {
	border-radius: 15px;
	background-color: #181818;
}

.projects-search-input {
	margin-bottom: 20px;
}

.select-editor-list {
	position: fixed;
	z-index: 30;
	background: #0d0d0d;
	padding: 10px;
	color: #a8a8a8;
	border: 1px solid #2f2f2f;
	font-family: Consolas, "Courier New", monospace;
	overflow-y: auto;
}

.selected-item {
	pointer-events: none;
	border-radius: 20px;
	background: #4e4e4e;
}

.select-item:hover {
	border-radius: 20px;
	background: #333333;
}

.filter-list-item {
	display: flex;
	height: 40px;
}

.filter-list-checkbox {
	width: 18px !important;
	display: inline-block;
	padding: 3px;
	margin-right: 5px;
}

.danger {
	color: #f00 !important;
}

.reset-zoom-btn {
	padding: 0 3px;
	margin: -7px 7px;
	position: relative;
	z-index: 2;
}

.assets-view .props-group-body {
	padding-top: 2px;
}

.assets-view {
	text-align: left;
}

.lib-info:hover {
	outline: 1px solid #0eca75;
	border-radius: 10px;
}

.assets-item {
	border-radius: 30px;
	position: relative;
	white-space: nowrap;
	padding: 4px 2px;
	padding-left: 15px;
	cursor: pointer;
}

.assets-item:hover {
	background: #3b3b3b;
}

.assets-item img {
	margin: 3px;
}

.assets-item-image {
	color: #5d9662;
}

.tool-button img {
	width: 12px;
}

.assets-item-image .preview-img {
	cursor: pointer;
	pointer-events: all;
	max-width: 30px;
	max-height: 30px;
	margin: 0 10px;
}

.asset-editor img {
	cursor: pointer;
	pointer-events: all;
	max-width: 25px;
	max-height: 23px;
	margin: 0 10px;
	margin-top: 3px;
}

.image-preview-tooltip {
	text-align: center;
	pointer-events: none;
	width: 128px;
	height: 148px;
	background: #444444;
	border-radius: 10px;
	z-index: 1020;
	border: 10px solid #444444;
	transform: translateY(-128px);
	position: fixed;
}

.image-preview-img {
	width: 128px;
	height: 128px;
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
}

.assets-item-class {
	margin: 3px 0;
	padding: 2px 10px;
	color: #87b8cf;
}

.asset-item-tool-buttons button {
	padding: 0;
	margin: 0 2px;
	width: 22px;
	height: 22px;
	color: #555555;
	border-radius: 12px;
}

.asset-item-tool-buttons {
	display: none;
	position: absolute;
	right: 5px;
}

.assets-item:hover .asset-item-tool-buttons {
	display: inline-block;
}

.assets-item-current {
	background-color: #333633;
	cursor: default;
	color: #bbbbbb;
}

.assets-item-prefab {
	border-left: 3px dotted #676d12;
}

.assets-item-scene .assets-item-preview-pic{
	width: 60px;
	height: 40px;
}

.assets-item-prefab .assets-item-preview-pic{
	width: 30px;
	height: 30px;
}

.assets-item-preview-pic {
	vertical-align: middle;
	margin: 0 10px;
	padding: 1px;
	background-color: #000;
	display: inline-block;
}

.assets-item-preview-pic canvas {
	display: block;
}

.selected-text {
	background-color: rgb(102, 66, 0);
}

.prompt-variant-item {
	color: #ababab;
	text-decoration: underline;
	margin: 10px;
	padding: 0;
}

.props-header {
	display: flex;
	height: 33px;
}

.props-header .assets-item-prefab {
	margin: 0;
	flex-grow: 3;
}

.props-header button {
	white-space: nowrap;
	overflow: hidden;
	padding: 5px 15px;
	margin: 0 7px 7px 0;
	display: flex;
	width: 50%;
}

.change-prefab-button {
	padding: 0 10px !important;
	display: flex;
}


.change-prefab-button span {
	line-height: 25px;
	vertical-align: text-top;
}

.prefab-change-caret {
	vertical-align: text-top;
	font-size: 130%;
	margin-left: 7px;
	line-height: 25px;
}

.close-window-btn {
	position: absolute;
	padding: 0 3px;
	right: 0;
	top: -17px;
	font-weight: bold;
	background: #660000;
	color: #ffcece;
}

.info-badge {
	background: #660000;
	color: #DD8888;
	position: absolute;
	top: 10px;
	width: 20px;
	text-align: center;
	height: 20px;
	right: 10px;
	border-radius: 10px;
}

#data-access-debugger,
#window-info,
#language-view {
	border: 1px solid #995500;
}

.additional-window-layer .window-body {
	z-index: 20 !important;
}

.info-item {
	padding: 9px;
	position: relative;
}

.info-item .selectable-scene-node,
.choosing-item .selectable-scene-node {
	display: inline-block;
	margin-left: 10px;
}

.clear-item-btn {
	position: absolute;
	top: 0;
	right: 0;
	background-color: #660000;
	transform: scale(0.5);
	opacity: 0.6;
}

.error-status-help-button {
	transform: scale(.5);
	top: 0;
	right: 20px;
	position: absolute;
}

.close-btn {
	background-color: #660000;
	border-radius: 20px;
}

.clear-search-btn {
	position: absolute;
	top: 10px;
	padding: 0;
	width: 20px;
	height: 20px;
	right: 10px;
}

.context-menu {
	position: fixed;
	background-color: #1b1b1b;
	min-width: 220px;
	border-radius: 4px;
	padding: 10px 0;
	z-index: 10000;
	border: 1px solid #555555;
}

.context-menu-item-hotkey {
	color: #676767;
	margin-left: 20px;
}

.context-menu button {
	width: 100%;
	white-space: nowrap;
	background: transparent;
	border: none;
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 5px 20px 5px 50px;
	position: relative;
	height: 26px;
}

.context-menu-item-content {
	width: 100%;
	display: flex;
	justify-content: space-between;
}

.context-menu button:has(.current-menu-item) {
	box-sizing: border-box;
	background: #282828;
	border: 1px solid #444;
	pointer-events: none;
	cursor: unset;
}


.context-menu button:hover {
	outline: none;
	background-color: #ffffff22;
}

.context-menu img {
	left: 17px;
	top: 5px;
	height: 16px;
	position: absolute;
	max-width: 28px;
}

.small-text {
	font-size: 70%;
}

.project-item-select {
	padding: 10px 20px;
	margin: 5px;
	border-radius: 100px;
	background: #1a1a1a;
	color: #85909b;
	font-size: 120%;
	display: flex;
	align-items: center;
	justify-content: space-between;
	white-space: nowrap;
}

.project-item-select:hover {
	background: #151515;
}

.project-item-title {
	text-align: right;
	display: inline-block;
}

.project-item-select img {
	height: 40px;
	max-height: 40px;
	max-width: 50%;
}

.path-editor-function-tip {
	white-space: nowrap;
	padding: 3px 20px;
	border: 1px solid #464646;
	color: #afafaf;
	background: #3b3b3b;
}

#data-path-tip-container {
	position: fixed;
	z-index: 20;
}

.data-path-header {
	display: block;
	height: 90px;
}
.data-path-small-header {
   font-weight: normal;
   font-size: 80%;
}

.asset-editor {
	display: flex;
}

.tool-button {
	padding: 0;
}

.choose-asset-button {
	overflow: hidden;
	flex-grow: 1;
	padding: 5px;
}

.path-chooser-layer {
	opacity: 0;
}

.modal-body .window-body {
	position: relative;
	min-height: 50vh;
	min-width: 50vw;

}

.modal-body .window-dragger,
.modal-body .window-r-dragger,
.modal-body .window-l-dragger,
.modal-body .window-b-dragger,
.modal-body .window-t-dragger,
.modal-body .window-rb-dragger,
.modal-body .window-lb-dragger,
.modal-body .window-rt-dragger,
.modal-body .window-lt-dragger {
	display: none;
}

.resolution {
	font-size: 80%;
	text-align: center;
	color: #999;

}

.viewport-panel-wrapper .resolution {
	padding: 5px 0;
	background-color: #1d1e1f;
}

.viewport-panel-wrapper .resolution:hover {
	background-color: #252627;
}

.isolation-warning {
	padding: 3px;
	color: #bb0000;
}

#sceneTree:has(.isolation-warning) {
	border-color: #880000;
}

.array-prop {
	text-align: right;
	min-height: 25px;
}

.array-prop-item {
	display: flex;
}

.array-prop-item-remove-btn {
	padding: 1px 11px;
	color: #ff0000;
}

.add-item-button {
	padding: 1px 11px;
	margin: 3px 0;
}

.template-desc {
	white-space: initial;
	font-size: small;
	color: #777;
	margin-left: 20px;
	width: 56%;
}

.empty-lib-holder {
	display: inline-block;
	width: 22px;
	height: 19px;
}

.menu-icon {
	font-size: 150%;
}


.langs-editor {
	padding: 4px;
	top: 0;
	bottom: 0;
	position: absolute;
	width: 100%;
}

.langs-editor-wrapper {
	height: calc(100% - 95px);
	overflow-x: auto;
	overflow-y: hidden;
	position: absolute;
	left: 4px;
	right: 4px;
}

.langs-editor .select-editor-current {
	white-space: nowrap;
}

.langs-editor .select-editor {
	margin: 10px;
	display: inline-block;
	width: 300px;
}

.language-search-input {
	margin: 5px;
	width: 226px;
}

.langs-editor-table {
	box-sizing: content-box;
	text-align: left;
	padding-bottom: 3px;
	min-width: 700px;
	height: calc(100% - 40px);
	position: absolute;
	overflow: auto;
}

.langs-editor-th,
.langs-editor-td {
	display: inline-block;
	width: 350px;
	height: 50px;
	vertical-align: top;
}

.langs-editor-th {
	box-sizing: border-box;
	padding: 15px;
	font-weight: bold;
}

.langs-editor-header .langs-editor-th {
	height: 30px;
	padding: 5px;
	text-align: left;
}

.langs-editor-tr {
	display: flex;
	white-space: nowrap;
	box-sizing: border-box;
	border-bottom: 1px solid #111111;
}

.langs-editor textarea {
	margin: 0;
	height: 100%;
	padding: 5px;
	width: calc(100% - 3px);
	box-sizing: border-box;
	border: none;
	resize: none;
	outline-offset: -1px
}

.props-wrapper-separator {
	border-top: 2px solid var(--window-header-color);
}

.drag-target-bottom {
	background: linear-gradient(0deg, rgba(221, 26, 26, 1) 1px, rgba(221, 26, 26, 0.4) 1px, rgba(221, 26, 26, 0) 10px);
}

.drag-target-top {
	background: linear-gradient(180deg, rgba(221, 26, 26, 1) 1px, rgba(221, 26, 26, 0.4) 1px, rgba(221, 26, 26, 0) 20px);
}

.drag-target-mid {
	background:
		linear-gradient(90deg, rgba(221, 26, 26, 1) 1px, rgba(221, 26, 26, 0.4) 1px, rgba(221, 26, 26, 0) 10px),
		linear-gradient(180deg, rgba(221, 26, 26, 1) 1px, rgba(221, 26, 26, 0.4) 1px, rgba(221, 26, 26, 0) 10px),
		linear-gradient(270deg, rgba(221, 26, 26, 1) 1px, rgba(221, 26, 26, 0.4) 1px, rgba(221, 26, 26, 0) 10px),
		linear-gradient(0deg, rgba(221, 26, 26, 1) 1px, rgba(221, 26, 26, 0.4) 1px, rgba(221, 26, 26, 0) 10px);
}

.drag-target-wrap {
	background:
		linear-gradient(90deg, rgba(23, 211, 48, 1) 1px, rgba(23, 211, 48, 0.4) 1px, rgba(23, 211, 48, 0) 10px),
		linear-gradient(180deg, rgba(23, 211, 48, 1) 1px, rgba(23, 211, 48, 0.4) 1px, rgba(23, 211, 48, 0) 10px),
		linear-gradient(270deg, rgba(23, 211, 48, 1) 1px, rgba(23, 211, 48, 0.4) 1px, rgba(23, 211, 48, 0) 10px),
		linear-gradient(0deg, rgba(23, 211, 48, 1) 1px, rgba(23, 211, 48, 0.4) 1px, rgba(23, 211, 48, 0) 10px);
}

.rect-editor-group {
	display: flex;
	align-items: center;
}


.music-profiler-row {
	border: #ddd solid 1px;
	border-radius: 12px;
	padding: 0 4px;
	height: 24px;
	display: grid;
	margin: 2px 0;
	align-content: center;
	grid-template-columns: 30% 30% 40%;
}

.music-profiler-row-text {
	padding: 0 8px;
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	height: 20px;
}
.music-profiler-row-text-active {
	color:  #0f0;
}

.sound-vol-bar-bg {
	border-radius: 9px;
	border: #489648 solid 1px;
	height: 18px;
	width: 100px;
	background: rgb(62, 88, 62);
	position: relative;
	overflow: hidden;
	text-align: center;
	color: #7e998e;
	font-size: 84%;
}

.sound-vol-bar {
	left: 0;
	height: 18px;
	background: rgb(35, 185, 35);
	display: inline-block;
	position: absolute;
}

.sound-profiler-lane {
	border-bottom: #e9d5cb solid 1px;
	border-top: #e9d5cb solid 1px;
	margin-bottom: -1px;
	overflow: hidden;
	position: relative;
	height: 80px;
}

.sound-profiler-sound-entry {
	opacity: 0.6;
	padding: 0 5px;
	font-size: 90%;
	border-radius: 3px;
	border: #ffffff solid 1px;
	position: absolute;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 20px;
}

.sound-profiler-sound-entry:hover {
	opacity: 1;
	z-index: 1;
	background: #ffeacf;
	border-color: #ffbea2;
}

.local-store-row:hover {
	background-color: #131313;
}

.local-store-row {
	display: flex;
}

.local-store-column-header {
	margin-right: 20px;
	text-align: right;
}

.local-store-column {
	display: inline-block;
	width: 50%;
}

.local-store-view button {
	padding: 0 5px;
	background-color: #300c0c;
}

.project-language-tip {
	color: #008f5f;
}

.data-access-debugger-item .select-editor {
	display: inline-block;
}

.labels-log-list {
	height: 100%;
}

.labels-log-time {
	font-size: 70%;
	color: #505050;
	width: 60px;
	padding: 3px;
}

.labels-log-label {
	flex-grow: 1;
}

#labels-logger .choose-list-header input,
#labels-logger .choose-list-header .select-editor {
	flex-grow: 1;
}

.labels-log-item {
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 3px 10px;
}

.labels-log-item-selected {
	background-color: #362a00;
}

.labels-log-item:hover {
	background-color: #333333;
}

.labels-log-item-selected:hover {
	background-color: #443500;
}

.labels-log-item .scene-node-item {
	display: inline-block;
}



















.fadein-animation {
	animation: fade-in linear .1s;
	animation-iteration-count: 1;
	animation-fill-mode: forwards;
}

@keyframes fade-in {
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}

.modal-notification,
.scale-up-animation {
	animation: scale-up-tr linear .1s;
	animation-iteration-count: 1;
	animation-fill-mode: forwards;
}

@keyframes spin {
	0% {
		transform: rotate(0deg);
	}
	
	100% {
		transform: rotate(360deg);
	}
}

@keyframes scale-up-tr {
	0% {
		transform: scale(0.0);
	}

	100% {
		transform: scale(1);
	}
}

.shake {
	animation: shake-animation linear 0.3s;
	animation-iteration-count: 2;
	transform-origin: 50% 50%;
}

@keyframes shake-animation {
	0% {
		transform: translate(0px, 0px);
	}

	25% {
		transform: translate(5px, 0px);
	}

	77% {
		transform: translate(-5px, 0px);
	}

	100% {
		transform: translate(0px, 0px);
	}
}

.red-blink {
	animation: red-blink-frames linear 1s;
	animation-iteration-count: infinite;
	transform-origin: 50% 50%;
	color: #ff0000;
}

@keyframes red-blink-frames {
	0% {
		opacity: 1;
	}

	48% {
		opacity: 1;
	}

	50% {
		opacity: 0;
	}

	98% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}
</file>

<file path="src/editor/templates/basic-game-object.tst">
// this class generated with Thing-Editor's component's Wizard,
// and contain basic game-object's methods.
// For details: https://github.com/Megabyteceer/thing-editor/wiki/Custom-Components#custom-component-methods

import BASE_CLASS_NAME from 'BASE_CLASS_PATH';

export default class NEW_CLASS_NAME extends BASE_CLASS_NAME {

	/* //editable property example
	
	@editable({ min: 0, max: 100, step: 0.1 })
	myProperty = 0;

	//*/

	init() {
		//super.init();
		// Add initialization code here

	}

	update() {
		// Add your update code here

		//super.update();
	}

	onRemove() {
		// Add onRemove code here

		//super.onRemove();
	}
}
</file>

<file path="src/editor/templates/basic-scene.tst">
// this class automatically generated with Thing-Editor's component's Wizard,
// and contain full list of scene's methods, include scene
// For details: https://github.com/Megabyteceer/thing-editor/wiki/Custom-Components#custom-component-methods

import BASE_CLASS_NAME from 'BASE_CLASS_PATH';

export default class NEW_CLASS_NAME extends BASE_CLASS_NAME {
	
	/* //editable property example
	
	@editable({ min: 0, max: 100, step: 0.1 })
	myProperty = 0;

	//*/
	
	init() {
		//super.init();
		// Add initialization code here

	}
	
	onShow() {
		// Add each time scene appears on game screen

		//super.onShow();
	}

	update() {
		// Add your update code here

		//super.update();
	}

	onHide() {
		// Add each time scene disappears from game screen

		//super.onHide();
	}

	onRemove() {
		// Add on scene destroying code here

		//super.onRemove();
	}
}
</file>

<file path="src/editor/templates/full-game-object.tst">
// this class automatically generated with Thing-Editor's component's Wizard,
// and contain all possible methods. Remove any of methods you do not need.
// For details: https://github.com/Megabyteceer/thing-editor/wiki/Custom-Components#custom-component-methods

import BASE_CLASS_NAME from 'BASE_CLASS_PATH';

export default class NEW_CLASS_NAME extends BASE_CLASS_NAME {
	
	/* //editable property example
	
	@editable({ min: 0, max: 100, step: 0.1 })
	myProperty = 0;

	//*/
	
	init() {
		//super.init();
		// Add initialization code here

	}
	
	update() {
		// Add your update code here

		//super.update();
	}

	onRemove() {
		// Add onRemove code here

		//super.onRemove();
	}

	onLanguageChanged() {
		//super.onLanguageChanged();

	}

	_onRenderResize() {
		//super._onRenderResize();

	}

	_onDisableByTrigger() {
		//super._onDisableByTrigger();

	}


	/// #if EDITOR
	__EDITOR_onCreate() {
		//super.__EDITOR_onCreate();
		
	}

	__onSelect() {
		//super.__onSelect();
		
	}

	__onUnselect() {
		//super.__onUnselect();

	}

	__beforeDestroy() {
		//super.__beforeDestroy();

	}

	__beforeSerialization() {
		//super.__beforeSerialization();
		
	}

	__afterSerialization() {
		//super.__afterSerialization();
		
	}

	__beforeDeserialization() {
		//super.__beforeDeserialization();
		
	}

	__afterDeserialization() {
		//super.__afterDeserialization();
		
	}

	__onChildSelected() {
		//super.__onChildSelected();
		
	}
	
	__onIsMobileChange() {

	}

	static __validateObjectData(data:SerializedObjectProps):SerializedDataValidationError {

	}
	/// #endif
}

/// #if EDITOR

//NEW_CLASS_NAME.__EDITOR_icon= 'CURRENT_PROJECT_DIR/tree-icons/icon';
//NEW_CLASS_NAME.__canNotHaveChildren = true; //uncomment this line if your component should have no children


/// #endif
</file>

<file path="src/editor/templates/full-scene.tst">
// this class automatically generated with Thing-Editor's component's Wizard,
// and contain full list of scene's methods, include scene
// For details: https://github.com/Megabyteceer/thing-editor/wiki/Custom-Components#custom-component-methods

import BASE_CLASS_NAME from 'BASE_CLASS_PATH';

export default class NEW_CLASS_NAME extends BASE_CLASS_NAME {
	
	/* //editable property example
	
	@editable({ min: 0, max: 100, step: 0.1 })
	myProperty = 0;

	//*/

	init() {
		//super.init();
		// Add initialization code here

	}
	
	onShow() {
		// Add each time scene appears on game screen

		//super.onShow();
	}

	update() {
		// Add your update code here

		//super.update();
	}

	onHide() {
		// Add each time scene disappears from game screen

		//super.onHide();
	}

	onRemove() {
		// Add on scene destroying code here

		//super.onRemove();
	}

	onMouseDown(gameMouse, pixiEvent) { //eslint-disable-line no-unused-vars
		
	}

	onMouseMove(gameMouse, pixiEvent) { //eslint-disable-line no-unused-vars
		
	}

	onMouseUp(gameMouse, pixiEvent) { //eslint-disable-line no-unused-vars
		
	}

	onLanguageChanged() {
		//super.onLanguageChanged();

	}

	_onRenderResize() {
		//super._onRenderResize();

	}

	/// #if EDITOR
	__EDITOR_onCreate() {
		//super.__EDITOR_onCreate();
		
	}

	__onSelect() {
		//super.__onSelect();
		
	}

	__onUnselect() {
		//super.__onUnselect();

	}

	__beforeSerialization() {
		//super.__beforeSerialization();
		
	}

	__afterSerialization() {
		//super.__afterSerialization();
		
	}

	__beforeDeserialization() {
		//super.__beforeDeserialization();
		
	}

	__afterDeserialization() {
		//super.__afterDeserialization();
		
	}

	__onChildSelected() {
		//super.__onChildSelected();
		
	}
	/// #endif
}
</file>

<file path="src/editor/ui/assets-view/asset-preview.ts">
import { Color } from 'pixi.js';
import R from 'thing-editor/src/engine/basic-preact-fabrics';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import { AssetType, type FileDesc } from '../../fs';
import { editorEvents } from '../../utils/editor-events';
import exportAsPng from '../../utils/export-as-png';

const NO_PREVIEW_IMG = document.createElement('img');
NO_PREVIEW_IMG.src = '/thing-editor/img/broken-image.png';
const prefabsPreviewsCache = new Map() as Map<string, HTMLCanvasElement>;
const scenesPreviewsCache = new Map() as Map<string, HTMLCanvasElement>;

editorEvents.on('prefabUpdated', (prefabName:string) => {
	prefabsPreviewsCache.delete(prefabName);
});

editorEvents.on('sceneUpdate', (sceneName:string) => {
	prefabsPreviewsCache.delete(sceneName);
});

export const assetPreview = (file: FileDesc, width = 30, height = 30) => {
	return R.span({
		className: 'assets-item-preview-pic',
		ref: (ref: HTMLSpanElement) => {
			if (ref && !game.editor.buildProjectAndExit) {

				const isScene = file.assetType === AssetType.SCENE;

				const cache = isScene ? scenesPreviewsCache : prefabsPreviewsCache;

				const img = cache.get(file.assetName);
				if (img) {
					ref.appendChild(img);
				} else {
					setTimeout(() => {
						const o = isScene ? ((game.editor.currentSceneName === file.assetName && game.currentScene) ? game.currentScene : Lib.__loadSceneNoInit(file.assetName)) : Lib.__loadPrefabNoInit(file.assetName);
						const bgColor = isScene ? new Color((o as Scene).backgroundColor).toHex() : '#000';
						(exportAsPng(o, width, height, -1, undefined, true, !o.parent) as any).then((canvas: HTMLCanvasElement) => {
							if (!canvas) {
								canvas = NO_PREVIEW_IMG as any;
							} else {
								canvas.style.backgroundColor = bgColor;
							}
							cache.set(file.assetName, canvas);
							ref.querySelector('canvas')?.remove();
							ref.appendChild(canvas);
						});
					}, 10);
				}
			}
		},
	});
};
</file>

<file path="src/editor/ui/assets-view/asset-view-class.ts">
import type { FileDescClass } from 'thing-editor/src/editor/fs';
import fs from 'thing-editor/src/editor/fs';
import R, { renderClass } from 'thing-editor/src/editor/preact-fabrics';
import { addSharedAssetContextMenu } from 'thing-editor/src/editor/ui/assets-view/assets-view';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import getParentWhichHideChildren from 'thing-editor/src/editor/utils/get-parent-with-hidden-children';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import loadSafeInstanceByClassName from 'thing-editor/src/editor/utils/load-safe-instance-by-class-name';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const showClassContextMenu = (file: FileDescClass, ev: PointerEvent) => {
	showContextMenu(addSharedAssetContextMenu(file, [
		{
			name: 'Child',
			tip: 'Place as child to each selected object.',
			onClick: () => {
				let insertTo = game.editor.selection.slice();
				game.editor.selection.clearSelection();
				for (let o of insertTo) {
					game.editor.addTo(o, loadSafeInstanceByClassName(file.asset.__className));
				}
			},
			disabled: () => {
				return file.asset.__isScene || !game.editor.isCanBeAddedAsChild(file.asset);
			}
		},
		{
			name: 'Place',
			tip: 'Place to scene`s root.',
			onClick: () => {
				game.editor.selection.clearSelection();
				game.editor.addTo(game.currentContainer, loadSafeInstanceByClassName(file.asset.__className));
			},
			disabled: () => { return file.asset.__isScene || !game.editor.isCanBeAddedAsChild(file.asset, game.currentContainer); }
		},
		{
			name: 'Wrap',
			tip: 'Wraps selected content with a \'' + file.assetName + '\'',
			onClick: () => {
				editorUtils.wrapSelected(file.asset);
			},
			disabled: () => {
				if (!game.editor.selection.length) {
					return true;
				}
				if (game.editor.selection[0] instanceof Scene) {
					return true;
				}
				return file.asset.__isScene || !game.editor.isCanBeAddedAsChild(file.asset, game.editor.selection[0]?.parent);
			}
		},
		null,
		{
			name: R.fragment(R.icon('copy'), 'Copy class name'),
			onClick: () => {
				game.editor.copyToClipboard(file.asset.__className);
			}
		},
		{
			name: 'Go to Source code >>>',
			tip: 'Double click on class to go to it`s source code.',
			onClick: () => {
				game.editor.editClassSource(file.asset);
			}
		},
		null,
		{
			name: R.fragment(R.icon('asset-prefab'), 'Create new prefab...'),
			onClick: () => {
				editorUtils.savePrefab(file);
			},
			disabled: () => file.asset.__isScene
		},
		{
			name: R.fragment('Move to library...'),
			onClick: async () => {
				let chosenFolder: string | undefined = await game.editor.chooseAssetsFolder('Where to move class \'' + file.asset.__className + '\'?', file.lib ? file.lib.assetsDir : game.editor.currentProjectAssetsDir);
				if (!chosenFolder) {
					return;
				}
				fs.moveAssetToFolder(file, game.editor.currentProjectLibs.find(l => l.assetsDir === chosenFolder)!);
				game.editor.reloadClasses();
			},
			disabled: () => game.editor.getUserVisibleFolders().length < 2
		},
		{
			name: R.fragment(R.icon('delete'), ' Delete \'' + file.asset.__className + '\' class...'),
			onClick: () => {
				game.editor.ui.modal.showEditorQuestion(
					'Ase you sure?',
					R.fragment(
						R.div(null, 'You about to delete class'),
						renderClass(file)
					), () => {
						fs.deleteAsset(file.assetName, file.assetType);
					}, R.fragment(R.icon('delete'), ' Delete.')
				);
			}
		}
	]), ev);
};

const toolButtonsProps = {
	className: 'asset-item-tool-buttons',
	onDblClick: sp
};

const assetItemRendererClass = (file: FileDescClass) => {
	let tip;
	if (!file.asset) {
		return R.fragment();
	}
	if (file.asset.__EDITOR_tip) {
		tip = R.tip('class-' + file.asset.__className,
			'Component "' + file.asset.__className + '" description:',
			file.asset.__EDITOR_tip
		);
	}

	const clickTip = '; ' + CTRL_READABLE + '+click - find all. Alt+click - strict type';

	return R.div({
		className: 'assets-item assets-item-class',
		key: file.assetName,
		title: file.fileName,
		onContextMenu: (ev: PointerEvent) => {
			sp(ev);
			showClassContextMenu(file, ev);
		},
		onDblClick: () => {
			game.editor.editClassSource(file.asset);
		},
		onDragStart(ev: DragEvent) {
			ev.dataTransfer!.setData('text/drag-thing-editor-class-id', file.asset.__className);
		},
		draggable: true
	},
	libInfo(file),
	renderClass(file),
	tip,
	R.span(toolButtonsProps,
		R.btn('<', (ev) => {
			sp(ev);
			findNextOfThisType(file.asset, -1, (ev.ctrlKey || ev.metaKey), ev.altKey);
		}, 'Find previous ' + file.asset.__className + ' ' + CTRL_READABLE + ' - all, Alt - strict', clickTip),
		R.btn('>', (ev) => {
			sp(ev);
			findNextOfThisType(file.asset, 1, (ev.ctrlKey || ev.metaKey), ev.altKey);
		}, 'Find next ' + file.asset.__className + ' ' + CTRL_READABLE + ' - all, Alt - strict', clickTip)
	)
	);
};

function findNextOfThisType(c: SourceMappedConstructor, direction: 1 | -1, findAll: boolean, strictType: boolean) {
	if (findAll) {
		let a = game.currentContainer.findChildrenByType(c as any).filter((o) => {
			return !getParentWhichHideChildren(o);
		});
		if (game.currentContainer instanceof c) {
			a.push(game.currentContainer);
		}
		game.editor.selection.clearSelection();
		a = a.filter(o => !o.__nodeExtendData.isolate);
		if (strictType) {
			a = a.filter(o => o.constructor === c);
		}
		for (let w of a) {
			game.editor.ui.sceneTree.selectInTree(w, true);
		}
	} else {
		game.editor.ui.sceneTree.findNext((o) => {
			if (!o.__nodeExtendData.isolate) {
				if (!strictType) {
					return (o instanceof c) && !getParentWhichHideChildren(o);
				} else {
					return (o.constructor === c) && !getParentWhichHideChildren(o);
				}
			}
		}, direction);
	}
}


export default assetItemRendererClass;
</file>

<file path="src/editor/ui/assets-view/asset-view-image.ts">
import type { FileDescImage } from 'thing-editor/src/editor/fs';
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import AssetsView, { addSharedAssetContextMenu } from 'thing-editor/src/editor/ui/assets-view/assets-view';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy image name',
	onMouseDown: copyTextByClick
};

const showImageContextMenu = (file: FileDescImage, ev: PointerEvent) => {

	const menu: ContextMenuItem[] = [
		null,
		{
			name: R.fragment(R.icon('copy'), 'Copy image`s name'),
			onClick: () => {
				game.editor.copyToClipboard(file.assetName);
			}
		},
		null,
		{
			name: R.fragment('Move to library...'),
			onClick: async () => {
				game.editor.moveAssetToLibrary('Where to move image \'' + file.assetName + '\'?', file);
			},
			disabled: () => game.editor.getUserVisibleFolders().length < 2 || Lib.__isSystemTexture(file.asset, file.assetName)
		},
		{
			name: R.fragment(R.icon('delete'), ' Delete \'' + file.assetName + '\' image...'),
			onClick: () => {
				game.editor.ui.modal.showEditorQuestion(
					'Ase you sure?',
					R.fragment(
						R.div(null, 'You about to delete image'),
						R.imageIcon(file)
					), () => {
						fs.deleteAsset(file.assetName, file.assetType);
					}, R.fragment(R.icon('delete'), ' Delete.')
				);
			},
			disabled: () => Lib.__isSystemTexture(file.asset, file.assetName)
		}
	];

	if (game.editor.selection.length) {
		const props = (game.editor.selection[0].constructor as SourceMappedConstructor).__editableProps;
		for (let i = props.length - 1; i >= 0; i--) {
			const prop = props[i];
			if (game.editor.ui.propsEditor.editableProps[prop.name]) {
				if (prop.type === 'image') {
					menu.unshift({
						name: 'Assign to "' + prop.name + '" >>',
						onClick: () => {
							game.editor.editProperty(prop, file.assetName);
						}
					});
				}
			}
		}
	}

	addSharedAssetContextMenu(file, menu);
	showContextMenu(menu, ev);
};


const assetItemRendererImage = (file: FileDescImage) => {
	return R.div(
		{
			onContextMenu: (ev: PointerEvent) => {
				sp(ev);
				showImageContextMenu(file as FileDescImage, ev);
			},
			className: (AssetsView.currentItemName === file.assetName) ? 'assets-item assets-item-current assets-item-image' : 'assets-item assets-item-image',
			key: file.assetName
		},
		libInfo(file),
		R.imageIcon(file),
		R.span(assetsItemNameProps, file.assetName));
};

export default assetItemRendererImage;
</file>

<file path="src/editor/ui/assets-view/asset-view-scene.ts">
import type { ComponentChild } from 'preact';
import type { FileDescScene } from 'thing-editor/src/editor/fs';
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import AssetsView, { addSharedAssetContextMenu } from 'thing-editor/src/editor/ui/assets-view/assets-view';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import { onNewSceneClick, onSaveAsSceneClick } from 'thing-editor/src/editor/utils/scene-utils';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import { __UnknownClass } from 'thing-editor/src/editor/utils/unknown-class';
import assert from 'thing-editor/src/engine/debug/assert';
import game, { PRELOADER_SCENE_NAME } from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import { getSerializedObjectClass } from '../../utils/generate-editor-typings';
import { assetPreview } from './asset-preview';

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy scene`s name',
	onMouseDown: copyTextByClick
};

const showPrefabContextMenu = (file: FileDescScene, ev: PointerEvent) => {
	showContextMenu(addSharedAssetContextMenu(file, [
		{
			name: 'Edit scene',
			onClick: () => game.editor.openScene(file.assetName),
			disabled: () => game.editor.currentSceneName === file.assetName
		},
		null,
		{
			name: 'New scene...',
			onClick: onNewSceneClick
		},
		{
			name: 'Save as...',
			onClick: onSaveAsSceneClick
		},
		null,
		{
			name: 'Go to Source code >>>',
			tip: 'Double click on class to go to it`s source code.',
			onClick: () => {
				game.editor.editClassSource(game.classes[file.asset.c!]);
			}
		},
		null,
		{
			name: R.fragment('Move  to library...'),
			onClick: async () => {
				game.editor.moveAssetToLibrary('Where to move scene \'' + file.assetName + '\'?', file);
			},
			disabled: () => game.editor.getUserVisibleFolders().length < 2
		},
		{
			name: R.fragment(R.icon('delete'), ' Delete \'' + file.assetName + '\' scene...'),
			onClick: () => {
				game.editor.ui.modal.showEditorQuestion(
					'Ase you sure?',
					R.fragment(
						R.div(null, 'You about to delete scene'),
						file.assetName
					), () => {
						fs.deleteAsset(file.assetName, file.assetType);
					}, R.fragment(R.icon('delete'), ' Delete.')
				);
			},
			disabled: () => game.projectDesc.mainScene === file.assetName || file.assetName === PRELOADER_SCENE_NAME
		}
	]), ev);
};

const assetItemRendererScene = (file: FileDescScene): ComponentChild => {
	assert(file.asset ? file.asset.c : true, 'scene can not be prefab reference'); // asset can be empty if it is equal asset overriding notification popup where overrides asset overridden too

	const isCurrent = (file.assetName === game.editor.currentSceneName) || (AssetsView.currentItemName === game.editor.currentSceneName);
	const preview = assetPreview(file, 60, 40);
	return R.div(
		{
			className: isCurrent ? 'assets-item assets-item-scene assets-item-current' : 'assets-item assets-item-scene',
			key: file.assetName,
			onContextMenu: (ev: PointerEvent) => {
				sp(ev);
				showPrefabContextMenu(file, ev);
			},
			onMouseDown: (ev: PointerEvent) => {
				if (!isCurrent && !editorUtils.isInModal(ev.target)) {
					game.editor.openScene(file.assetName);
				}
			},
			onDblClick: () => {
				const Class = getSerializedObjectClass(file.asset);
				game.editor.editClassSource(Class, file.asset.c);
			},
			title: 'click to open scene.'
		},
		libInfo(file),
		R.classIcon(game.classes[file.asset?.c!] || __UnknownClass),
		preview,
		R.span(assetsItemNameProps, file.assetName));
};


export default assetItemRendererScene;
</file>

<file path="src/editor/ui/assets-view/asset-view-sound.ts">
import type { FileDesc } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import AssetsView, { addSharedAssetContextMenu, assetTypesIcons } from 'thing-editor/src/editor/ui/assets-view/assets-view';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import { MUTE_SOUND_MENU_ITEM } from 'thing-editor/src/editor/ui/main-menu';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const BITRATE_PROPS = {
	className: 'semi-transparent'
};

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy sound name',
	onMouseDown: copyTextByClick
};

const assetItemRendererSound = (file: FileDesc) => {
	const isDefaultBitrate = !game.editor.projectDesc.soundBitRates.hasOwnProperty(file.assetName);
	return R.div(
		{
			className: (AssetsView.currentItemName === file.assetName) ? 'assets-item assets-item-current assets-item-sound' : 'assets-item assets-item-sound',
			key: file.assetName,
			onContextMenu: (ev: PointerEvent) => {
				const currentBitrate = (game.editor.projectDesc.soundBitRates[file.assetName] || game.editor.projectDesc.soundDefaultBitrate);
				showContextMenu(addSharedAssetContextMenu(file, [
					MUTE_SOUND_MENU_ITEM,
					{
						name: R.fragment('Move to library...'),
						onClick: () => {
							game.editor.moveAssetToLibrary('Where to move sound \'' + file.assetName + '\'?', file);
						},
						disabled: () => game.editor.getUserVisibleFolders().length < 2
					},
					{
						name: R.span({ className: isDefaultBitrate ? 'semi-transparent' : undefined },
							'Bitrate ',
							currentBitrate,
							'kbps',
							isDefaultBitrate ? ' (default)' : undefined,
							' ▾'
						),
						onClick: (ev?: PointerEvent) => {
							showContextMenu([8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 192, 224, 256].map((bitrate) => {
								const isDefaultBitrate = bitrate === game.editor.projectDesc.soundDefaultBitrate;
								return {
									name: bitrate + 'kbps' + (isDefaultBitrate ? ' (default)' : ''),
									disabled: () => currentBitrate === bitrate,
									onClick: () => {
										const desc = file.lib ? game.editor.libsDescriptors[file.lib.name] : game.editor.projectDesc;
										if (!desc.soundBitRates) {
											desc.soundBitRates = {};
										}
										if (isDefaultBitrate) {
											delete desc.soundBitRates[file.assetName];
											delete game.editor.projectDesc.soundBitRates[file.assetName];
										} else {
											desc.soundBitRates[file.assetName] = bitrate;
											game.editor.projectDesc.soundBitRates[file.assetName] = bitrate;
										}
										game.editor.saveProjectDesc();
										game.editor.ui.refresh();
										fs.rebuildSounds(file.lib ? file.lib.assetsDir : game.editor.currentProjectAssetsDir);
									}
								};
							}), ev!);
						},
					},
					null,
					{
						name: R.fragment(R.icon('delete'), ' Delete \'' + file.assetName + '\' sound...'),
						onClick: () => {
							game.editor.ui.modal.showEditorQuestion(
								'Ase you sure?',
								R.fragment(
									R.div(null, 'You about to delete sound'),
									file.assetName
								), () => {
									fs.deleteAsset(file.assetName, file.assetType);
								}, R.fragment(R.icon('delete'), ' Delete.')
							);
						},
						disabled: () => !!(file.lib && file.lib.isEmbed)
					}
				]), ev);
			},
			onMouseDown: (ev: PointerEvent) => {
				if (ev.buttons === 1 && !(ev.target as HTMLDivElement).closest('.modal-content')) {
					game.editor.previewSound(file.assetName);
				}
			}
		},
		libInfo(file),
		assetTypesIcons.get(AssetType.SOUND),
		R.span(assetsItemNameProps, file.assetName),
		isDefaultBitrate ? undefined : R.span(
			BITRATE_PROPS, ' (', game.editor.projectDesc.soundBitRates[file.assetName], 'kbps)'
		)
	);
};

export default assetItemRendererSound;
</file>

<file path="src/editor/ui/assets-view/assets-view-font.ts">
import type { FileDescPrefab } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy resource`s name',
	onMouseDown: copyTextByClick
};

const assetItemRendererFont = (file: FileDescPrefab) => {
	return R.div({
		key: file.assetName
	},
	libInfo(file),
	' font: ',
	R.span(assetsItemNameProps, file.assetName.split('/').pop()!.split('.woff')[0]));
};

export default assetItemRendererFont;
</file>

<file path="src/editor/ui/assets-view/assets-view-l10n.ts">
import type { FileDescL10n } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import LanguageView from '../language-view';

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy resource`s name',
	onMouseDown: copyTextByClick
};

const assetItemRendererL10n = (file: FileDescL10n) => {
	return R.div(
		{
			key: file.assetName,
			title: file.fileName,
			onDblClick: () => {
				const key = Object.keys(file.asset)[0];
				LanguageView.editKey(key);
			}
		},
		libInfo(file),
		' language: ',
		R.span(assetsItemNameProps, file.lang)
	);
};

export default assetItemRendererL10n;
</file>

<file path="src/editor/ui/assets-view/assets-view-prefab.ts">
import type { Container } from 'pixi.js';
import type { FileDescPrefab } from 'thing-editor/src/editor/fs';
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import AssetsView, { addSharedAssetContextMenu } from 'thing-editor/src/editor/ui/assets-view/assets-view';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import copyTextByClick, { isEventBlockedByTextCopy } from 'thing-editor/src/editor/utils/copy-text-by-click';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import { getSerializedObjectClass } from 'thing-editor/src/editor/utils/generate-editor-typings';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game, { DEFAULT_FADER_NAME } from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import { assetPreview } from './asset-preview';

const toolButtonsProps = {
	className: 'asset-item-tool-buttons',
	onDblClick: sp,
	onClick: sp
};

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy prefab`s name',
	onMouseDown: copyTextByClick
};

const placeAsChild = (file: FileDescPrefab) => {
	let insertTo = game.editor.selection.slice();
	game.editor.selection.clearSelection();
	for (let o of insertTo) {
		game.editor.addTo(o, Lib.__loadPrefabReference(file.assetName));
	}
};


const showPrefabContextMenu = (file: FileDescPrefab, ev: PointerEvent) => {
	showContextMenu(addSharedAssetContextMenu(file, [
		{
			name: 'Child',
			tip: 'Place as child to each selected object. (Alt + Click)',
			onClick: () => placeAsChild(file),
			disabled: () => !game.editor.selection.length
		},
		{
			name: 'Place',
			tip: 'Place to scene`s root.',
			onClick: () => {
				game.editor.selection.clearSelection();
				game.editor.addTo(game.currentContainer, Lib.__loadPrefabReference(file.assetName));
			}
		},
		{
			name: 'Wrap',
			tip: 'Wraps selected content with a \'' + file.assetName + '\'',
			onClick: () => {
				editorUtils.wrapSelected(undefined, file.assetName);
			}
		},
		null,
		{
			name: R.fragment(R.icon('asset-prefab'), 'Edit prefab'),
			disabled: () => !game.__EDITOR_mode,
			onClick: () => {
				PrefabEditor.editPrefab(file.assetName);
			}
		},
		{
			name: R.fragment(R.icon('asset-prefab'), 'Duplicate prefab'),
			disabled: () => !game.__EDITOR_mode,
			onClick: () => {
				editorUtils.enterPrefabName(file.assetName, 'Enter name for duplicate prefab: ' + file.assetName).then((enteredName) => {
					if (enteredName) {
						PrefabEditor.acceptPrefabEdition();
						const o = Lib.__loadPrefabNoInit(file.assetName);
						Lib.__savePrefab(o, enteredName);
						PrefabEditor.editPrefab(enteredName);
						Lib.destroyObjectAndChildren(o);
					}
				});
			}
		},
		{
			name: R.fragment(R.icon('asset-prefab'), 'Inherit prefab'),
			disabled: () => !game.__EDITOR_mode,
			onClick: () => {
				editorUtils.enterPrefabName(file.assetName, 'Enter name for inherited prefab: ' + file.assetName).then((enteredName) => {
					if (enteredName) {
						const o = Lib._loadClassInstanceById('Container');
						o.__nodeExtendData.isPrefabReference = file.assetName;
						Lib.__savePrefab(o, enteredName);
						PrefabEditor.editPrefab(enteredName);
					}
				});
			}
		},
		{
			name: R.fragment(R.icon('copy'), 'Copy prefab`s name'),
			onClick: () => {
				game.editor.copyToClipboard(file.assetName);
			}
		},
		{
			name: 'Go to Source code >>>',
			tip: 'Double click on class to go to it`s source code.',
			onClick: () => {
				game.editor.editClassSource(getSerializedObjectClass(file.asset));
			}
		},
		null,
		{
			name: R.fragment('Move to library...'),
			onClick: async () => {
				game.editor.moveAssetToLibrary('Where to move prefab \'' + file.assetName + '\'?', file);
			},
			disabled: () => game.editor.getUserVisibleFolders().length < 2
		},
		{
			name: R.fragment(R.icon('delete'), ' Delete \'' + file.assetName + '\' prefab...'),
			onClick: () => {
				game.editor.ui.modal.showEditorQuestion(
					'Ase you sure?',
					R.fragment(
						R.div(null, 'You about to delete prefab'),
						file.assetName
					), () => {
						if (file.assetName === PrefabEditor.currentPrefabName) {
							PrefabEditor.exitPrefabEdit(true);
						}
						fs.deleteAsset(file.assetName, file.assetType);
					}, R.fragment(R.icon('delete'), ' Delete.')
				);
			},
			disabled: () => file.assetName === DEFAULT_FADER_NAME
		}
	]), ev);
};

const assetItemRendererPrefab = (file: FileDescPrefab) => {
	let desc;
	if (file.asset?.p.__description) {
		desc = R.div(descriptionProps, file.asset.p.__description.split('\n')[0]);
	}
	const Class = getSerializedObjectClass(file.asset);
	const preview = assetPreview(file);

	return R.div(
		{
			className: (file.assetName === PrefabEditor.currentPrefabName) || (AssetsView.currentItemName === file.assetName) ? 'assets-item assets-item-prefab assets-item-current' : 'assets-item assets-item-prefab',
			key: file.assetName,
			onClick: (ev: PointerEvent) => {
				if (isEventBlockedByTextCopy(ev)) {
					return;
				}
				if (PrefabEditor.currentPrefabName !== file.assetName && !editorUtils.isInModal(ev.target)) {

					if (ev.altKey) {
						if (!game.editor.selection.length) {
							game.editor.selection.add(game.currentContainer);
						}
						while (game.editor.selection[0].__nodeExtendData.isPrefabReference) {
							let p = game.editor.selection[0].parent;
							if (p === game.stage) {
								break;
							}
							game.editor.selection.clearSelection();
							game.editor.selection.add(p);
						}
						placeAsChild(file);
					}
					else {
						PrefabEditor.editPrefab(file.assetName);
					}

				}
			},
			onContextMenu: (ev: PointerEvent) => {
				sp(ev);
				showPrefabContextMenu(file, ev);
			},
			onDblClick: () => {
				game.editor.editClassSource(Class, file.asset.c);
			},
			title: 'Click to edit prefab. Alt + Click - place as child',
			onDragStart(ev: DragEvent) {
				ev.dataTransfer!.setData('text/drag-thing-editor-prefab-name', file.assetName);
			},
			draggable: true
		},
		libInfo(file),
		R.classIcon(Class),
		preview,
		R.span(assetsItemNameProps, file.assetName),
		R.span(toolButtonsProps,
			R.btn('<', (ev) => {
				sp(ev);
				findNextOfThisType(file.assetName, -1, (ev.ctrlKey || ev.metaKey));
			}, 'Find previous (hold ' + CTRL_READABLE + ' to find all)'),
			R.btn('>', (ev) => {
				sp(ev);
				findNextOfThisType(file.assetName, 1, (ev.ctrlKey || ev.metaKey));
			}, 'Find next (hold ' + CTRL_READABLE + ' to find all)')
		),
		desc
	);
};
const descriptionProps = { className: 'tree-desc' };

export default assetItemRendererPrefab;

function findNextOfThisType(name:string, direction: 1 | -1, findAll: boolean) {
	if (findAll) {
		let a = [] as Container[];

		game.currentContainer.forAllChildren((o)=> {
			if (o.__nodeExtendData.__deserializedFromPrefab === name) {
				a.push(o);
			}
		});
		if (game.currentContainer.__nodeExtendData.__deserializedFromPrefab === name) {
			a.push(game.currentContainer);
		}

		game.editor.selection.clearSelection();
		a = a.filter(o => !o.__nodeExtendData.isolate);

		const currentPrefab = PrefabEditor.currentPrefabName;
		for (let w of a) {
			game.editor.ui.sceneTree.selectInTree(w, true);
			if (currentPrefab !== PrefabEditor.currentPrefabName) {
				findNextOfThisType(name, direction, findAll);
				break;
			}
		}
	} else {
		game.editor.ui.sceneTree.findNext((o) => {
			return !o.__nodeExtendData.isolate && o.__nodeExtendData.__deserializedFromPrefab === name;
		}, direction);
	}
}
</file>

<file path="src/editor/ui/assets-view/assets-view-resource.ts">
import type { FileDescPrefab } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const assetsItemNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy resource`s name',
	onMouseDown: copyTextByClick
};

const assetItemRendererResource = (file: FileDescPrefab) => {
	return R.div({
		key: file.assetName,
		className: 'assets-item'
	},
	libInfo(file),
	' resource: ',
	R.span(assetsItemNameProps, file.assetName));
};

export default assetItemRendererResource;
</file>

<file path="src/editor/ui/assets-view/assets-view.ts">
import type { Container } from 'pixi.js';
import type { ComponentChild } from 'preact';
import { h } from 'preact';
import type { FileDesc, FileDescClass, FileDescPrefab } from 'thing-editor/src/editor/fs';
import fs, { AllAssetsTypes, AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import assetItemRendererClass from 'thing-editor/src/editor/ui/assets-view/asset-view-class';
import assetItemRendererImage from 'thing-editor/src/editor/ui/assets-view/asset-view-image';
import assetItemRendererScene from 'thing-editor/src/editor/ui/assets-view/asset-view-scene';
import assetItemRendererSound from 'thing-editor/src/editor/ui/assets-view/asset-view-sound';
import assetItemRendererFont from 'thing-editor/src/editor/ui/assets-view/assets-view-font';
import assetItemRendererPrefab from 'thing-editor/src/editor/ui/assets-view/assets-view-prefab';
import assetItemRendererResource from 'thing-editor/src/editor/ui/assets-view/assets-view-resource';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import type { WindowProps, WindowState } from 'thing-editor/src/editor/ui/editor-window';
import Window from 'thing-editor/src/editor/ui/editor-window';
import group from 'thing-editor/src/editor/ui/group';
import WindowMenu from 'thing-editor/src/editor/ui/window-menu';
import { EDITOR_BACKUP_PREFIX } from 'thing-editor/src/editor/utils/flags';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import scrollInToViewAndShake from 'thing-editor/src/editor/utils/scroll-in-view';
import { searchByRegexpOrText } from 'thing-editor/src/editor/utils/search-by-regexp-or-text';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import { libIcon } from '../../utils/lib-info';
import assetItemRendererL10n from './assets-view-l10n';

const SETTINGS_KEY = '__EDITOR_assetsView_list';

const assetsItemsRenderers: Map<AssetType, (file: FileDesc) => ComponentChild> = new Map();
assetsItemsRenderers.set(AssetType.IMAGE, assetItemRendererImage as any);

assetsItemsRenderers.set(AssetType.SOUND, assetItemRendererSound);

assetsItemsRenderers.set(AssetType.SCENE, assetItemRendererScene as (file: FileDesc) => ComponentChild);
assetsItemsRenderers.set(AssetType.PREFAB, assetItemRendererPrefab as (file: FileDesc) => ComponentChild);

assetsItemsRenderers.set(AssetType.BITMAP_FONT, assetItemRendererResource as (file: FileDesc) => ComponentChild);
assetsItemsRenderers.set(AssetType.RESOURCE, assetItemRendererResource as (file: FileDesc) => ComponentChild);
assetsItemsRenderers.set(AssetType.FONT, assetItemRendererFont as (file: FileDesc) => ComponentChild);
assetsItemsRenderers.set(AssetType.L10N, assetItemRendererL10n as (file: FileDesc) => ComponentChild);


(assetsItemsRenderers as Map<AssetType, (file: FileDescClass) => ComponentChild>).set(AssetType.CLASS, assetItemRendererClass);

const assetTypesIcons: Map<AssetType, ComponentChild> = new Map();
assetTypesIcons.set(AssetType.IMAGE, R.img({
	src: './img/asset-image.png',
	title: 'Show Images'
}));


assetTypesIcons.set(AssetType.SOUND, R.img({
	src: './img/asset-sound.png',
	title: 'Show Sounds'
}));
assetTypesIcons.set(AssetType.SCENE, R.img({
	src: './img/asset-scene.png',
	title: 'Show Scenes'
}));
assetTypesIcons.set(AssetType.PREFAB, R.img({
	src: './img/asset-prefab.png',
	title: 'Show Prefabs'
}));
assetTypesIcons.set(AssetType.CLASS, R.img({
	src: './img/asset-class.png',
	title: 'Show Components'
}));
assetTypesIcons.set(AssetType.RESOURCE, R.img({
	src: './img/asset-resource.png',
	title: 'Show Resources'
}));

let allWindowsIds: string[] = [];
const additionalWindows = [] as AssetsView[];

function __saveWindowsIds() {
	game.editor.settings.setItem(SETTINGS_KEY, allWindowsIds);
}

interface AssetsViewProps extends WindowProps {
	filter: KeyedMap<boolean>;
	hideMenu?: boolean;
	currentValue?: string;
	onItemSelect?: (assetName: string) => void;
	onItemPreview?: (assetName: string) => void;
	filterCallback?: (f: FileDesc) => boolean;
}

interface AssetsViewState extends WindowState {
	filter: KeyedMap<boolean>;
	filterLibs?: KeyedMap<boolean>;
	filtersActive?: boolean;
	filtersLibActive?: boolean;
	search: string;
}

export const overrideAssetInProject = (file: FileDesc) => {
	if (file.lib) {
		let o!:Container;
		if (file.assetType === AssetType.SCENE) {
			o = Lib.__loadSceneNoInit(file.assetName);
		} else if (file.assetType === AssetType.PREFAB) {
			o = Lib.__loadPrefabNoInit(file.assetName);
		}
		if (o) {
			const blocked = o?.__preventOverriding;
			Lib.destroyObjectAndChildren(o);
			if (blocked) {
				game.editor.showError('Asset`s overriding is prohibited.', 99999);
				return;
			}
		}
		fs.copyAssetToProject(file);
	}
};

const addSharedAssetContextMenu = (file: FileDesc, menu: ContextMenuItem[]) => {
	const i = menu.lastIndexOf(null);
	if (file.lib) {
		menu.splice(i + 1, 0, {
			name: 'Override asset in project',
			onClick: () => {
				overrideAssetInProject(file);
			}
		});
	}
	if (file.assetType !== AssetType.CLASS) {
		menu.splice(i + 1, 0, {
			name: 'Rename...',
			onClick: () => {
				fs.renameAsset(file);
			}
		});
	}
	menu.splice(i + 1, 0, {
		name: 'Reveal in Explorer',
		onClick: () => {
			fs.showFile(file.fileName);
		}
	});
	return menu;
};

export default class AssetsView extends Window<AssetsViewProps, AssetsViewState> {

	static currentItemName?: string = undefined;

	searchInputProps: KeyedObject;

	constructor(props: AssetsViewProps) {
		super(props);

		if (!this.state.filter) {
			this.setState({ filter: {}, filterLibs: {} });
		}

		if (this.props.hideMenu) {
			this.setState({ filter: props.filter, filtersActive: true });
		}

		this.searchInputProps = {
			className: 'search-input',
			onInput: this.onSearchChange.bind(this),
			placeholder: 'Search'
		};
	}

	componentDidMount(): void {
		super.componentDidMount();
		if (!allWindowsIds.includes(this.props.id)) {
			additionalWindows.push(this);
		}
		const input = (this.base as HTMLDivElement).querySelector('.search-input') as HTMLInputElement;
		if (input) {
			input.value = this.state.search || '';
			if (this.props.onItemSelect) {
				input.select();
			}
		}
	}

	componentWillUnmount(): void {
		if (additionalWindows.includes(this)) {
			additionalWindows.splice(additionalWindows.indexOf(this), 1);
		}
	}

	onSearchChange(ev: InputEvent) {
		let search = (ev.target as HTMLInputElement).value.toLowerCase();
		this.setState({ search });
	}

	static scrollAssetInToView(assetName: string) {
		for (let windowId of allWindowsIds) {
			const windowElement = document.getElementById(windowId) as HTMLDivElement;
			let items = windowElement.querySelectorAll('.assets-item') as any as HTMLElement[];
			for (let item of items) {
				if (item.textContent === assetName) {
					window.setTimeout(() => {
						scrollInToViewAndShake(item);
					}, 10);
					break;
				}
			}
		}
	}

	static renderAssetsViews(): ComponentChild {
		if (!game.editor.isProjectOpen) {
			return R.span();
		}
		for (const w of additionalWindows) {
			w.refresh();
		}
		if (allWindowsIds.length === 0) {
			allWindowsIds = game.editor.settings.getItem(SETTINGS_KEY);
			if (!allWindowsIds) {
				allWindowsIds = [];
				let idCounter = 0;
				for (let state of [
					{
						x: 0,
						y: 70,
						w: 20,
						h: 30,
						filter: { [AssetType.CLASS]: true },
						filtersActive: true,
						title: 'Classes',
						search: ''
					},
					{
						x: 20,
						y: 70,
						w: 20,
						h: 30,
						filter: { [AssetType.PREFAB]: true },
						filtersActive: true,
						title: 'Prefabs',
						search: ''
					},
					{
						x: 40,
						y: 70,
						w: 20,
						h: 30,
						filter: { [AssetType.IMAGE]: true },
						filtersActive: true,
						title: 'Images',
						search: ''
					},
					{
						x: 60,
						y: 70,
						w: 20,
						h: 30,
						filter: { [AssetType.SOUND]: true },
						filtersActive: true,
						title: 'Sounds',
						search: ''
					},
					{
						x: 80,
						y: 70,
						w: 20,
						h: 30,
						filter: { [AssetType.SCENE]: true },
						filtersActive: true,
						title: 'Scenes',
						search: ''
					}
				] as AssetsViewState[]) {
					const windowId = (Date.now() + idCounter++).toString();
					allWindowsIds.push(windowId);
					Window.saveWindowState(windowId, state);
				}
				__saveWindowsIds();
			}
		}

		return allWindowsIds.map((id) => {
			const props: AssetsViewProps = {
				id,
				x: 0,
				y: 70,
				w: 100,
				h: 30,
				minW: 150,
				minH: 100,
				content: undefined,
				title: 'Assets',
				helpId: 'Assets',
				key: id,
				filter: { [AssetType.CLASS]: true }
			};
			return h(AssetsView, props);
		});
	}

	renderWindowContent(): ComponentChild {
		let files = fs.getAssetsList() as FileDesc[];
		let menu;

		if (!this.props.hideMenu) {
			menu = [];

			for (const lib of game.editor.currentProjectLibs) {
				menu.push(R.span({ key: 'Libs/' + lib.name.replace(/\//gm, '!') }, R.btn(libIcon(lib), () => {
					if (!this.state.filterLibs) {
						//@ts-ignore
						this.state.filterLibs = {};
					}
					this.state.filterLibs![lib.name] = !this.state.filterLibs![lib.name];
					this.setState({ filtersLibActive: Object.values(this.state.filterLibs!).some(v => v) });
				}, lib.name, (this.state.filterLibs?.[lib.name]) ? 'toggled-button' : undefined))
				);
			}
			menu.push(R.span({ key: 'Libs/Proj' }, R.btn('Proj', () => {
				if (!this.state.filterLibs) {
					//@ts-ignore
					this.state.filterLibs = {};
				}
				this.state.filterLibs!['project'] = !this.state.filterLibs!['project'];
				this.setState({ filtersLibActive: Object.values(this.state.filterLibs!).some(v => v) });
			}, 'Project assets', (this.state.filterLibs?.project) ? 'toggled-button' : undefined)));

			AllAssetsTypes.forEach((assetType) => {
				menu.push(R.span({ key: 'Filters/' + assetType }, R.btn(assetTypesIcons.get(assetType), () => {
					this.state.filter[assetType] = !this.state.filter[assetType];
					this.setState({ filtersActive: Object.values(this.state.filter).some(v => v) });
				}, assetType, this.state.filter[assetType] ? 'toggled-button' : undefined)
				));
			});

			menu.push(R.span({ key: 'Settings/rename' }, R.btn('...', () => {
				enterNameForAssetsWindow(this.state.title as string).then((title) => {
					if (title) {
						this.setState({ title });
					}
				});
			}, 'Rename window')));

			menu.push(R.span({ key: 'Settings/clone' }, R.btn('+', () => {
				const cloneWindowId = Date.now().toString();
				const w = this.state.w / 2;
				let cloneState: AssetsViewState = JSON.parse(JSON.stringify(this.state));
				delete (cloneState as any).id;
				cloneState.w = w;
				cloneState.x += w;
				Window.saveWindowState(cloneWindowId, cloneState);
				allWindowsIds.push(cloneWindowId);
				__saveWindowsIds();
				this.setSize(w, this.state.h);
				this.saveState();
				game.editor.ui.refresh();
			}, 'Clone window')));

			if (allWindowsIds.length > 1) {
				menu.push(R.span({ key: 'Settings/close' }, R.btn('×', () => {
					game.editor.ui.modal.showEditorQuestion('Are you sure?', 'You about to close "' + this.state.title + '" window.', () => {
						this.eraseSettings();
						allWindowsIds.splice(allWindowsIds.indexOf(this.props.id), 1);
						__saveWindowsIds();
						game.editor.ui.forceUpdate();
					});
				}, 'Close window', 'close-btn')));
			}

			menu = h(WindowMenu, { menu: group.groupArray(menu, this.props.id) });
		}

		const showSystemAssets = game.editor.settings.getItem('show-system-assets', false);

		files = files.filter((asset) => {
			if (asset.assetName === 'src/__beforeprojectopen') {
				return false;
			}
			if (asset.assetName.startsWith(EDITOR_BACKUP_PREFIX)) {
				return false;
			}
			if (this.state.filtersActive) {
				if (!this.state.filter[asset.assetType]) {
					return false;
				}
			}
			if (this.state.filtersLibActive) {
				if (!this.state.filterLibs![asset.lib?.name || 'project']) {
					return false;
				}
			}
			if (!showSystemAssets) {
				if (asset.assetName.startsWith('___') || asset.assetName.indexOf('/___') > 0) {
					return false;
				}
			}
			return true;
		});

		let clearSearchBtn;
		if (this.state.search) {
			files = files.filter((asset) => {
				if (asset.assetName === AssetsView.currentItemName) {
					return true;
				} else if (asset.assetType === AssetType.SCENE) {
					if (asset.assetName === game.editor.currentSceneName) {
						return true;
					}
				} else if (asset.assetType === AssetType.PREFAB) {
					if (asset.assetName === PrefabEditor.currentPrefabName) {
						return true;
					}
				}

				if (asset.assetType === AssetType.PREFAB) {
					let prefabAsset = (asset as FileDescPrefab).asset;
					while (prefabAsset) {
						const desc = prefabAsset.p.__description;
						if (desc) {
							if (searchByRegexpOrText(desc, this.state.search)) {
								return true;
							}
						}
						if (prefabAsset.r) {
							prefabAsset = Lib.prefabs[prefabAsset.r];
						} else {
							break;
						}
					}
				} else if (asset.assetType === AssetType.CLASS) {
					const a = (asset as FileDescClass).asset;
					if (!a) {
						return false; // class loading in progress
					}
					if (searchByRegexpOrText(a.__className, this.state.search)) {
						return true;
					}
				}

				return searchByRegexpOrText(asset.assetName, this.state.search);
			});

			clearSearchBtn = R.btn('×', () => {
				this.setState({ search: '' });
				((this.base as HTMLElement).querySelector('.search-input') as HTMLInputElement).value = '';
			}, 'Discard search filter', 'close-btn clear-search-btn');
		}
		AssetsView.currentItemName = this.props.currentValue;

		if (this.props.filterCallback) {
			files = files.filter(this.props.filterCallback);
		}

		let items = files.map(AssetsView.renderAssetItem);

		if (!this.state.search) {
			items = group.groupArray(items, this.props.id);
		}

		return R.fragment(menu,
			R.input(this.searchInputProps),
			this.props.onItemSelect ?
				R.btn('auto accept', (ev) => {
					let itemElement = (ev.target as HTMLDivElement).closest('.window-content')?.querySelector('.assets-item') as HTMLDivElement;
					this.selectItem(itemElement, ev);
				}, undefined, 'hidden', { key: 'Enter' })
				: undefined,
			clearSearchBtn,
			R.div({
				title: this.props.onItemPreview ? 'Click to choose. ' + CTRL_READABLE + ' + Click to preview.' : undefined,
				className: 'assets-view window-scrollable-content',
				onMouseDown: this.props.onItemSelect ? (ev: MouseEvent) => {
					let itemElement = (ev.target as HTMLDivElement).closest('.assets-item') as HTMLDivElement;
					this.selectItem(itemElement, ev);
				} : undefined
			},
			items
			));
	}

	resetLayout() {
		game.editor.settings.removeItem(SETTINGS_KEY);
	}

	selectItem(itemElement: HTMLDivElement, ev: MouseEvent) {
		if (itemElement) {
			let chosen = (itemElement.querySelector('.selectable-text') as HTMLSpanElement).innerText;
			if ((ev.ctrlKey || ev.metaKey) && this.props.onItemPreview) {
				this.props.onItemPreview!(chosen);
			} else {
				if (this.props.currentValue !== chosen) {
					this.props.onItemSelect!(chosen);
				}
			}
		}
	}

	static renderAssetItem(file: FileDesc) {
		return assetsItemsRenderers.get(file.assetType)!(file);
	}
}

function enterNameForAssetsWindow(defaultTitle?: string) {
	return game.editor.ui.modal.showPrompt('Enter name for assets window:',
		defaultTitle,
		undefined,
		(val: string) => { //accept
			if (Lib.hasScene(val)) {
				return 'Scene with such name already exists';
			}
			if (val.endsWith('/') || val.startsWith('/')) {
				return 'name can not begin or end with "/"';
			}
		}
	);

}

export { addSharedAssetContextMenu, assetTypesIcons };
</file>

<file path="src/editor/ui/choose-list.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import group from 'thing-editor/src/editor/ui/group';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';

let listProps = { className: 'list-view' };
let listHeaderProps = { className: 'choose-list-header' };
let bodyProps = { className: 'resizable-dialog left-align-text' };

interface ChooseListProps extends ClassAttributes<ChooseList> {
	list: ChooseListItem[];
	noSearchField?: boolean;
	activeValue?: string;
	doNotGroup?: boolean;
}


interface ChooseListState {
	search: string;
}

interface ChooseListItem {
	__EDITOR_icon?: string;
	__className?: string;
	pureName?: string;
	name: ComponentChild;
	noFilter?: boolean;
	refusedBecause?: string;
	value?: any;
	[key: string]: any;
}

export type { ChooseListItem };

export default class ChooseList extends Component<ChooseListProps, ChooseListState> {

	searchInputProps: any;

	constructor(props: ChooseListProps) {
		super(props);
		this.state = { search: '' };
		this.searchInputProps = {
			autoFocus: true,
			onInput: this.onSearchChange.bind(this),
			placeholder: 'Search'
		};
		this.onSearchClearClick = this.onSearchClearClick.bind(this);
		this.renderChoosingItem = this.renderChoosingItem.bind(this);
		this.searchFilter = this.searchFilter.bind(this);
	}

	onSearchChange(ev: PointerEvent) {
		let val = (ev.target as HTMLInputElement).value;
		this.setState({ search: val });
	}

	onSearchClearClick() {
		this.setState({ search: '' });
	}

	renderChoosingItem(item: ChooseListItem, key: string) {
		assert((typeof item.name === 'string') || item.pureName || item.__className, 'pureName property expected for non plain text named items.');

		let icon;
		if (item.__EDITOR_icon) {
			icon = R.classIcon(item as SourceMappedConstructor);
		}
		let name = item.__className || item.name;

		if (typeof name === 'string') {
			key = name;
		} else if (typeof key !== 'string') {
			key = '' + key;
		}

		const isCurrentItem = this.props.activeValue === (item.pureName || item.name);

		let className = item.refusedBecause ? 'refused-item choosing-item' : (isCurrentItem ? 'choosing-item assets-item-current' : 'clickable choosing-item');

		return R.div({
			onClick: isCurrentItem ? undefined : () => {
				if (!item.refusedBecause) {
					game.editor.ui.modal.hideModal(item);
				}
			},
			title: item.refusedBecause,
			className,
			key: key
		}, icon, name);
	}

	get list() {
		if (this.state.search) {
			return this.props.list.filter(this.searchFilter);
		}

		return this.props.list;
	}

	searchFilter(item: ChooseListItem) {
		let f = this.state.search.toLocaleLowerCase();
		return item.noFilter || ((item.__className || item.pureName || item.name) as string).toLocaleLowerCase().indexOf(f) >= 0;
	}

	acceptByEnter(ev:KeyboardEvent) {
		if (this.list.length >= 1) {
			if ((this.list[0] as any).noAutoSelect) {
				if (this.list.length >= 2) {
					game.editor.ui.modal.hideModal(this.list[1]);
					sp(ev);
				}
			} else {

				game.editor.ui.modal.hideModal(this.list[0]);
				sp(ev);

			}
		}
	}

	render() {

		let list: any = this.list.map(this.renderChoosingItem as any);
		if (!this.props.doNotGroup) {
			list = group.groupArray(list, 'choose-list');
		}

		return R.div(bodyProps,
			this.props.noSearchField ? undefined : R.div(listHeaderProps,
				R.input(this.searchInputProps),
				R.btn(R.icon('reject'), this.onSearchClearClick, 'Clear search')
			),
			R.btn('auto accept', (ev) => {
				this.acceptByEnter(ev as any);
			}, undefined, 'hidden', { key: 'Enter' }),
			R.div(listProps, list)
		);
	}
}
</file>

<file path="src/editor/ui/choose-project.ts">
import type { ComponentChild } from 'preact';
import { Component, h } from 'preact';
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import group from 'thing-editor/src/editor/ui/group';
import game from 'thing-editor/src/engine/game';

function getIconPath(desc: ProjectDesc) {
	return '/games/' + desc.dir + '/' + desc.icon;
}

let topItem: ProjectDesc | null;

function renderProjectItem(desc: ProjectDesc): ComponentChild {
	if (!topItem) {
		topItem = desc;
	}
	let icon;
	if (desc.icon) {
		icon = R.img({ src: getIconPath(desc) });
	}
	let key = (desc.__group && !desc.dir.startsWith(desc.__group + '/')) ? desc.__group + '/' + desc.dir : desc.dir;
	let isProjectWrong;
	let wrongSymbol = fs.getWrongSymbol(desc.dir);
	if (wrongSymbol) {
		isProjectWrong = 'Project is blocked because of wrong symbol "' + wrongSymbol + '" in its folder name.';
	}
	const isCurrentProject = ('games/' + desc.dir + '/') === game.editor.currentProjectDir;

	let className = (isProjectWrong || isCurrentProject) ? 'project-item-select unclickable' : 'project-item-select clickable';

	return R.div({
		className,
		key,
		onClick: () => {
			game.editor.ui.modal.hideModal(desc.dir);
		}
	},
	icon,
	R.div({ className: 'project-item-title' }, desc.title,
		R.div({ className: 'small-text' }, desc.dir.split('/').pop()),
	),
	isProjectWrong ? R.span({ className: 'danger small-text' }, ' (' + isProjectWrong + ')') : undefined);
}

interface ProjectsListProps {
	projects: ProjectDesc[];

}

interface ProjectsListState {
	filter: string;
	searchInputProps: KeyedObject;
}

export default class ProjectsList extends Component<ProjectsListProps, ProjectsListState> {

	static __chooseProject(noCloseable = false) {

		game.editor.ui.viewport.stopExecution();
		const projects = fs.enumProjects();


		projects.sort((a, b) => {
			return projectOrder(b) - projectOrder(a);
		});
		return game.editor.ui.modal.showModal(h(ProjectsList, { projects }), R.span(null, R.icon('open'), 'Choose project to open:'), noCloseable);
	}

	constructor(props: ProjectsListProps) {
		super(props);
		let filter = game.editor.settings.getItem('projects-filter', '');
		this.state = {
			filter, searchInputProps: {
				className: 'projects-search-input',
				onKeyDown: (e: KeyboardEvent) => {
					if (e.key === 'Enter' && topItem) {
						game.editor.ui.modal.hideModal(topItem.dir);
					}
				},
				onInput: this.onSearchChange.bind(this),
				placeholder: 'Search',
				value: filter
			}
		};
	}

	onSearchChange(ev: Event) {
		let filter = (ev.target as any).value.toLowerCase();
		game.editor.settings.setItem('projects-filter', filter);
		this.state.searchInputProps.value = filter;
		this.setState({ filter });
	}

	render() {
		topItem = null;
		let f = this.state.filter.toLowerCase();
		let items;
		const projects = this.props.projects;
		if (f) {
			items = projects.filter((i: ProjectDesc) => {
				return i.title.toLowerCase().indexOf(f) >= 0 || i.dir.toLowerCase().indexOf(f) >= 0;
			}).map(renderProjectItem);
		} else {

			items = group.groupArray(projects.map(renderProjectItem), 'choose-project');
		}

		return R.div({ className: 'project-open-chooser' },
			R.div(null,
				R.input(this.state.searchInputProps)
			),
			R.div({ className: 'projects-list' },
				items
			)
		);
	}
}

const projectOrder = (projDesc: ProjectDesc) => {
	return game.editor.settings.getItem(projDesc.dir + '_EDITOR_lastOpenTime', 0);
};
</file>

<file path="src/editor/ui/component-debounced.ts">
import type { ComponentChild } from 'preact';
import { Component } from 'preact';

export default class ComponentDebounced<P = object, S = object> extends Component<P, S> {
	private _refreshTimeout = 0;

	onRenderedHandlers: (() => void)[] = [];

	refresh(onRendered?:() => void) {
		if (onRendered) {
			this.onRenderedHandlers.push(onRendered);
		}
		if (!this._refreshTimeout) {
			this._refreshTimeout = window.setTimeout(() => {
				this._refreshTimeout = 0;
				this.forceUpdate();
			}, 0);
		}
	}

	componentDidUpdate() {
		if (this._refreshTimeout) {
			clearTimeout(this._refreshTimeout);
			this._refreshTimeout = 0;
		}
		while (this.onRenderedHandlers.length) {
			this.onRenderedHandlers.shift()!();
		}
	}

	componentWillUnmount(): void {
		if (this._refreshTimeout) {
			clearInterval(this._refreshTimeout);
		}
	}

	render(): ComponentChild {
		return undefined;
	}
}
</file>

<file path="src/editor/ui/context-menu.ts">
import type { ComponentChild } from 'preact';
import { render } from 'preact';

import R from 'thing-editor/src/editor/preact-fabrics';
import { hotkeyToString, type Hotkey } from 'thing-editor/src/editor/utils/hotkey';

interface ContextMenuItemData {
	name: ComponentChild | (() => ComponentChild);
	onClick: ((ev?: PointerEvent) => void) | (() => void);
	disabled?: (() => boolean);
	hidden?: () => boolean;
	stayAfterClick?: boolean;
	tip?: string;
	hotkey?: Hotkey;
}

const hotkeyTipProps = {
	className: 'context-menu-item-hotkey'
};

type ContextMenuItem = ContextMenuItemData | null;

const root = document.getElementById('context-menu-root') as HTMLElement;

const hideContextMenu = () => {
	render(R.fragment(), root);
	menuShown = false;
};

let menuShown = false;
let hideMenuTimeout = 0;

window.addEventListener('pointerdown', (ev: PointerEvent) => {
	if (menuShown) {
		hideMenuTimeout = window.setTimeout(() => {
			if ((ev.target as HTMLDivElement).closest('.stay-after-click-menu-item') || (ev.target as HTMLDivElement).classList.contains('context-menu')) {
				refreshContextMenu();
			} else {
				hideContextMenu();
			}
		}, 10);
	}
});

let shownMenuTemplate: ContextMenuItem[];
let shownMenuEvent: PointerEvent;

const toggleContextMenu = (menuTemplate: ContextMenuItem[], ev: PointerEvent) => {
	if (menuShown && shownMenuTemplate === menuTemplate) {
		hideContextMenu();
	} else {
		showContextMenu(menuTemplate, ev);
		return true;
	}
};

const isItemActive = (item: ContextMenuItem) => {
	if (item) {
		if ((typeof item.disabled === 'function') ? item.disabled() : item.disabled) {
			return false;
		}
	}
	return true;
};

const showContextMenu = (menuTemplate: ContextMenuItem[], ev: PointerEvent) => {
	if (hideMenuTimeout) {
		clearTimeout(hideMenuTimeout);
		hideMenuTimeout = 0;
	}

	shownMenuTemplate = menuTemplate;
	shownMenuEvent = ev;

	//menuTemplate = menuTemplate.filter(isItemDisabled);

	while (menuTemplate[0] === null) { //trim splitters
		menuTemplate.shift();
	}
	while (menuTemplate[menuTemplate.length - 1] === null) {
		menuTemplate.pop();
	}

	for (let i = menuTemplate.length - 3; i >= 0; i--) { // cut double splitters
		if (menuTemplate[i] === null && menuTemplate[i - 1] === null) {
			menuTemplate.splice(i, 1);
		}
	}

	const menuHeight = menuTemplate.length * 40;


	const style = {
		left: Math.max(0, Math.min(window.innerWidth - 200, ev.clientX - 3)),
		top: Math.max(0, Math.min(window.innerHeight - menuHeight, ev.clientY - menuHeight / 2 - 10))
	};
	if ((ev.target as HTMLDivElement).closest('.main-menu')) {
		const mainMenuButton = (ev.target as HTMLDivElement).closest('button') as HTMLButtonElement;
		if (!mainMenuButton) {
			return;
		}
		const bounds = mainMenuButton.getBoundingClientRect();
		style.left = bounds.left;
		style.top = bounds.bottom;
	}

	if (menuTemplate.length > 0) {
		render(R.div({
			className: 'context-menu',
			style,
		}, menuTemplate.map(renderMenuItem)), root);
		menuShown = true;
	}
};

const refreshContextMenu = () => {
	if (menuShown) {
		showContextMenu(shownMenuTemplate, shownMenuEvent);
	}
};


export default showContextMenu;

const menuItemProps = { className: 'context-menu-item-content'};

function renderMenuItem(item: ContextMenuItem) {

	if (item) {
		if (item.hidden && item.hidden()) {
			return R.fragment();
		}
		return R.btn(
			R.span(menuItemProps,
				(typeof item.name === 'function') ? item.name() : item.name,
				item.hotkey ? R.span(hotkeyTipProps, hotkeyToString(item.hotkey)) : undefined),
			item.onClick,
			item.tip,
			item.stayAfterClick ? 'context-menu-item stay-after-click-menu-item' : 'context-menu-item',
			item.hotkey,
			!isItemActive(item));
	} else {
		return R.hr();
	}
}

export { hideContextMenu, refreshContextMenu, toggleContextMenu };
export type { ContextMenuItem };
</file>

<file path="src/editor/ui/editor-button.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import { hideContextMenu, refreshContextMenu } from 'thing-editor/src/editor/ui/context-menu';
import Window from 'thing-editor/src/editor/ui/editor-window';
import { MAIN_MENU } from 'thing-editor/src/editor/ui/main-menu';
import DataPathFixer from 'thing-editor/src/editor/utils/data-path-fixer';
import type { Hotkey } from 'thing-editor/src/editor/utils/hotkey';
import isHotkeyHit, { hotkeyToString } from 'thing-editor/src/editor/utils/hotkey';
import isEventFocusOnInputElement from 'thing-editor/src/editor/utils/is-event-focus-on-input-element';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';

const allHotkeyButtons: EditorButton[] = [];


const findItemForHotkey = (ev: Hotkey, handlers?: ContextMenuItem[][], windowBody?: HTMLDivElement): ContextMenuItem | undefined => {
	if (handlers) {
		for (let menuGroup of handlers) {
			for (let menuItem of menuGroup) {
				if (menuItem) {
					if (typeof menuItem.disabled !== 'function' || !menuItem.disabled()) {
						if (isHotkeyHit(ev as any, windowBody as HTMLElement, menuItem.hotkey)) {
							return menuItem;
						}
					}
				}
			}
		}
	}
};

const findMenuItemForHotkey = (hotkey: Hotkey): ContextMenuItem | undefined => {
	for (let w of Window.allOrdered) {
		let ret = findItemForHotkey(hotkey, w.props.hotkeysHandlers, w.base as HTMLDivElement);
		if (ret) {
			return ret;
		}
	}

	for (let item of MAIN_MENU) {
		let ret = findItemForHotkey(hotkey, [item.items], window.document.querySelector('#viewport') as HTMLDivElement);
		if (ret) {
			return ret;
		}
	}
};

window.addEventListener('keydown', (ev) => {
	if (ev.key !== 'Control' && ev.key !== 'Alt' && ev.key !== 'Shift') {
		for (let b of allHotkeyButtons) {
			if (b.onKeyDown(ev)) { //call only first button with this hotkey
				hideContextMenu();
				return;
			}
		}

		const item = findMenuItemForHotkey(ev as Hotkey);
		if (item) {
			if (!isEventFocusOnInputElement(ev)) {
				item.onClick();
				refreshContextMenu();
				game.editor.ui.modal.notify((typeof item.name === 'function') ? item.name() : item.name, 'hotkey');
				sp(ev);
				return;
			}
		}
	}
});

interface EditorButtonProps extends ClassAttributes<EditorButton> {
	label: ComponentChild;
	onClick: (ev: PointerEvent) => void;
	className?: string;
	title?: string;
	hotkey?: Hotkey;
	disabled?: boolean;
}

interface EditorButtonStats {
	title?: string;
}

class EditorButton extends Component<EditorButtonProps, EditorButtonStats> {

	onKeyDown(ev: KeyboardEvent) {
		if (!this.props.disabled && isHotkeyHit(ev, this.base as HTMLElement, this.props.hotkey)) {
			if (!isEventFocusOnInputElement(ev)) {
				this.onMouseDown(ev as unknown as PointerEvent);
				sp(ev);
			}
			return true;
		}
	}

	constructor(props: EditorButtonProps) {
		super(props);
		this.onMouseDown = this.onMouseDown.bind(this);
	}

	componentWillReceiveProps(props: EditorButtonProps) {
		if (this.props.hotkey !== props.hotkey) {
			this.unregisterHotkey();
			this.registerHotkey(props);
		}
	}

	componentDidMount() {
		this.registerHotkey(this.props);
	}

	registerHotkey(props: EditorButtonProps) {
		if (this.props.hotkey) {
			allHotkeyButtons.unshift(this);
		}

		let title = props.title;
		let hotkey = props.hotkey;
		if (hotkey) {
			title = props.title ? props.title + hotkeyToString(hotkey) : hotkeyToString(hotkey);
		}
		this.setState({ title});
	}

	unregisterHotkey() {
		if (this.props.hotkey) {
			let i = allHotkeyButtons.indexOf(this);
			if (i >= 0) {
				allHotkeyButtons.splice(i, 1);
			}
		}
	}

	componentWillUnmount() {
		this.unregisterHotkey();
	}

	onMouseDown(ev: PointerEvent) {
		if (ev.button === 2) {
			//             ↓
			this.props.onClick; // hover "onClick" and Ctrl+Click [FunctionLocation] to go to handler declaration
			debugger; //   ↑
		} else {
			if (this.props.disabled) return;
			DataPathFixer.onNameBlur();
			this.props.onClick(ev);
			if (!(ev.target as HTMLElement).closest('.main-menu')) {
				(ev.target as HTMLElement).blur();
			}
		}
		sp(ev);
	}

	render() {
		return R.button({
			disabled: this.props.disabled,
			className: (this.props.disabled ? 'unclickable ' : 'clickable ') + this.props.className,
			onMouseDown: this.onMouseDown,
			title: this.state.title
		}, this.props.label);
	}
}

export default EditorButton;
export { findMenuItemForHotkey };
</file>

<file path="src/editor/ui/editor-overlay.ts">
import type { Sprite } from 'pixi.js';
import { Container, Point } from 'pixi.js';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';

import getParentWhichHideChildren from 'thing-editor/src/editor/utils/get-parent-with-hidden-children';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import protectAccessToSceneNode from 'thing-editor/src/editor/utils/protect-access-to-node';
import Selection from 'thing-editor/src/editor/utils/selection';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import ___GizmoArrow from 'thing-editor/src/engine/lib/assets/src/___system/gizmo-arrow.c';
import EDITOR_FLAGS from '../utils/flags';

let isViewPortScrolling = false;
let scrollingX = 0;
let scrollingY = 0;

let rightButtonDraggingStarted = false;
let rightButtonDraggingBlocked = false;

const overlayLayer = new Container();

function initializeGizmo() {
	protectAccessToSceneNode(overlayLayer, 'gizmoLayer');
	overlayLayer.interactive = true;
	game.stage.parent.addChild(overlayLayer);
	game.__EDITOR_mode = false;
	const gizmo = Lib.loadPrefab('___system/gizmo');
	game.__EDITOR_mode = true;
	overlayLayer.addChild(gizmo);

	game.pixiApp.ticker.add(() => {
		overlayLayer.update();
	});
}

editorEvents.once('gameWillBeInitialized', () => {

	(document.querySelector('#viewport-root') as HTMLDivElement).addEventListener('pointerdown', function onMouseDown(ev: MouseEvent) {
		if (game.pixiApp && (ev.target === game.pixiApp.view)) {
			if (ev.buttons === 4) {
				isViewPortScrolling = true;
				scrollingX = game.__mouse_EDITOR.x;
				scrollingY = game.__mouse_EDITOR.y;
			} else {
				if (EDITOR_FLAGS.blockSelectByStageClick) {
					rightButtonDraggingBlocked = true;
					return;
				}
				if (ev.buttons === 2) {
					if (!___GizmoArrow.overedArrow) {
						if (ev.altKey) {
							editorUtils.clone();
						}
						moveSelectionToMouse(ev);
						rightButtonDraggingStarted = true;
					}
				} else {
					const selectionDisabled = !game.__EDITOR_mode && !game.__paused && !ev.altKey && !(ev.ctrlKey || ev.metaKey) && !ev.shiftKey;
					if (!selectionDisabled) {
						if (ev.buttons === 1 && !___GizmoArrow.overedArrow) {
							selectByStageClick(ev);
						}
					}
				}
			}
		} else {
			game.editor.selection.clearSelection();
		}
	}, true);

	window.addEventListener('mousemove', function onMouseMove(ev: MouseEvent) {
		if (game.pixiApp) {
			if (isViewPortScrolling) {
				if (ev.buttons !== 4) {
					isViewPortScrolling = false;
				} else {
					let dX = game.__mouse_EDITOR.x - scrollingX;
					let dY = game.__mouse_EDITOR.y - scrollingY;
					game.stage.x += dX;
					game.stage.y += dY;


					scrollingX = game.__mouse_EDITOR.x;
					scrollingY = game.__mouse_EDITOR.y;
				}
			} else if (!rightButtonDraggingBlocked && ev.buttons === 2 && (rightButtonDraggingStarted || (ev.target === game.pixiApp.view)) && !___GizmoArrow.draggedArrow) {
				moveSelectionToMouse(ev);
				rightButtonDraggingStarted = true;
			}
		}
	});

	window.addEventListener('mouseup', stopRightButtonMoving);

	window.addEventListener('wheel', function onWheel(ev) {
		if (game.pixiApp && (ev.target === game.pixiApp.view)) {

			let pivot = game.stage.toLocal(game.__mouse_EDITOR, game.stage.parent);


			let zoom = game.stage.scale.x;
			zoom *= 1 - ev.deltaY / 500;

			if (Math.abs(zoom - 1.0) < 0.01) {
				zoom = 1;
			}
			if (zoom > 32) {
				zoom = 32;
			}
			if (zoom < 0.02) {
				zoom = 0.02;
			}
			game.stage.x += (pivot.x * game.stage.scale.x - pivot.x * zoom);
			game.stage.y += (pivot.y * game.stage.scale.y - pivot.y * zoom);

			game.stage.scale.x = zoom;
			game.stage.scale.y = zoom;
		}
	});

});

editorEvents.once('projectDidOpen', initializeGizmo);

const p = new Point();

function moveSelectionToMouse(ev: MouseEvent) {
	if (game.editor.selection.length > 0) {
		moveSelectionToGlobalPoint(game.__mouse_uncropped as any as Point, (ev.ctrlKey || ev.metaKey));
	}
}

function moveSelectionToGlobalPoint(point: Point, withoutChildren = false) {
	if (game.editor.selection.length > 0) {
		game.editor.selection[0].parent.toLocal(point, game.stage, p);
		if (!isNaN(p.x)) {
			moveSelectionToPoint(p.x - game.editor.selection[0].x, p.y - game.editor.selection[0].y, withoutChildren);
		}
	}
}

function moveSelectionToPoint(dX: number, dY: number, withoutChildren = false) {
	if (game.editor.selection.length > 0) {

		dX = Math.round(dX);
		dY = Math.round(dY);

		dX -= game.editor.selection[0].x % 1;
		dY -= game.editor.selection[0].y % 1;

		if (withoutChildren) {
			for (let s of game.editor.selection) {
				game.editor.moveContainerWithoutChildren(s, dX, dY);
			}
		} else {
			if (dX) {
				if (game.editor.ui.propsEditor.editableProps.x) {
					game.editor.editProperty('x', dX, true);
				} else {
					game.editor.ui.propsEditor.selectField('x');
					game.editor.ui.modal.notify('x property locked');
				}
			}
			if (dY) {
				if (game.editor.ui.propsEditor.editableProps.y) {
					game.editor.editProperty('y', dY, true);
				} else {
					game.editor.ui.propsEditor.selectField('y');
					game.editor.ui.modal.notify('y property locked');
				}
			}
		}
	}
}

function isObjectUnderMouse(o: Container) {
	return ((o as Sprite).containsPoint && (!o.__doNotSelectByClick) && o.worldVisible && o.worldAlpha && (o as Sprite).containsPoint(game.__mouse_EDITOR));
}

let previousAllUnderMouse: Container[];
function selectByStageClick(ev: MouseEvent) {

	if (document.fullscreenElement) {
		return;
	}

	let allUnderMouse = new Selection();
	let i;

	const checkNodeToSelect = (o: Container) => {
		if (isObjectUnderMouse(o)) {
			let parentWhichHideChildren = getParentWhichHideChildren(o);
			if (parentWhichHideChildren) {
				if ((parentWhichHideChildren !== game.stage) && ((allUnderMouse).indexOf(parentWhichHideChildren) < 0)) {
					allUnderMouse.push(parentWhichHideChildren);
				}
			} else {
				let p = o;
				while (p) {
					if (p === game.stage) {
						allUnderMouse.push(o);
						break;
					}
					if (p.__doNotSelectByClick) {
						break;
					}
					p = p.parent;
				}

			}
		}
	};

	let a = [PrefabEditor.currentPrefabName ? game.currentContainer : game.stage];

	for (let c of a) {
		checkNodeToSelect(c);
		c.forAllChildren(checkNodeToSelect);
	}

	allUnderMouse.sortSelectedNodes();
	allUnderMouse.reverse();

	if (allUnderMouse.length > 0) {
		if (!previousAllUnderMouse || previousAllUnderMouse.some((prevObj, i) => {
			return prevObj !== allUnderMouse[i];
		})) {
			i = 0;
		} else {
			i = allUnderMouse.indexOf(getParentWhichHideChildren(game.editor.selection[0]) || game.editor.selection[0]) + 1;
		}
		let o = allUnderMouse[i % allUnderMouse.length];
		game.editor.ui.sceneTree.selectInTree(o, (ev.ctrlKey || ev.metaKey));
	} else {
		game.editor.selection.clearSelection(true);
	}
	previousAllUnderMouse = allUnderMouse;
}

function stopRightButtonMoving() {
	rightButtonDraggingStarted = false;
	rightButtonDraggingBlocked = false;
}

export default overlayLayer;

export { moveSelectionToGlobalPoint, moveSelectionToPoint, stopRightButtonMoving };
</file>

<file path="src/editor/ui/editor-window.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import Help from 'thing-editor/src/editor/ui/help';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';

const MENU_HEIGHT = 24;
const CLAMP_POW = 5;

interface CornerDraggerProps extends ClassAttributes<CornerDragger> {
	onDrag: (deltaX: number, deltaY: number) => { x: number; y: number };
	onDragEnd: () => void;
	className: string;
	type?: DraggerType;
	owner: Window;
}

interface WindowProps extends ClassAttributes<Window> {
	onResize?: () => void;
	id: string;
	x: number;
	y: number;
	w: number;
	h: number;
	minW: number;
	minH: number;
	content: ComponentChild;
	helpId: string;
	title: ComponentChild;
	hotkeysHandlers?: ContextMenuItem[][];
}

interface WindowState {
	title: ComponentChild;
	x: number;
	y: number;
	w: number;
	h: number;
}

class Window<P extends WindowProps = WindowProps, S extends WindowState = WindowState> extends ComponentDebounced<P, S> {

	renderedScale = 1;

	static all: KeyedMap<Window> = {};
	static allOrdered: Window[] = [];

	constructor(props: P) {
		super(props);

		const state: WindowState = {} as WindowState;
		for (let key in props) {
			let val = props[key];
			if (typeof val === 'number' || typeof val === 'boolean') {
				(state as KeyedObject)[key] = val;
			}
		}
		state.x;
		state.y;
		state.w = props.w - props.x;
		state.h = props.h - props.y;

		Object.assign(state, game.editor.settings.getItem('editor_window_state_' + props.id, {}));

		(this as any).state = state;

		this.setSize(state.w, state.h);
		this.setPosition(state.x, state.y);

		this.saveState = this.saveState.bind(this);
		this.deltaPosition = this.deltaPosition.bind(this);
		this.deltaLBCorner = this.deltaLBCorner.bind(this);
		this.deltaRBCorner = this.deltaRBCorner.bind(this);
		this.deltaRTCorner = this.deltaRTCorner.bind(this);
		this.deltaLTCorner = this.deltaLTCorner.bind(this);
		this.deltaR = this.deltaR.bind(this);
		this.deltaL = this.deltaL.bind(this);
		this.deltaB = this.deltaB.bind(this);
		this.deltaT = this.deltaT.bind(this);

		this.onMouseDown = this.onMouseDown.bind(this);

		if (props.hotkeysHandlers) {
			for (let handlers of props.hotkeysHandlers) {
				for (let item of handlers) {
					if (item) {
						editorUtils.preCacheImages(item.name);
					}
				}
			}
		}
	}

	componentDidMount() {
		if (!this.isModal()) {
			Window.all[this.props.id] = this as Window;
			Window.allOrdered.push(this as Window);
		}
	}

	componentWillUnmount() {
		if (this.saveStateTimeout) {
			clearTimeout(this.saveStateTimeout);
			this.saveStateTimeout = 0;
		}
		if (!this.isModal()) {
			delete Window.all[this.props.id];
			Window.allOrdered.splice(Window.allOrdered.indexOf(this as Window), 1);
		}
	}

	eraseSettings() {
		game.editor.settings.removeItem('editor_window_state_' + this.props.id);
	}

	resetLayout() {
		this.refresh();
	}

	saveStateTimeout = 0;

	setState<K extends keyof S>(state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | Partial<S> | null) | Pick<S, K> | Partial<S> | null): void {
		super.setState(state);
		if (this.saveStateTimeout) {
			clearTimeout(this.saveStateTimeout);
		}
		this.saveStateTimeout = window.setTimeout(() => {
			this.saveState();
			this.saveStateTimeout = 0;
		}, 10);
	}

	saveState() {
		Window.saveWindowState(this.props.id, this.state);
	}

	static saveWindowState(windowId: string, state: WindowState) {
		game.editor.settings.setItem('editor_window_state_' + windowId, state);
	}

	deltaPosition(x: number, y: number) {
		let ret = { x: this.state.x, y: this.state.y };
		this.setPosition(this.state.x + x, this.state.y + y);
		ret.x = this.state.x - ret.x;
		ret.y = this.state.y - ret.y;
		return ret;
	}

	deltaL(x: number, _y: number) {
		let ret = { x: this.state.w, y: this.state.h };
		this.setSize(this.state.w - x, this.state.h);
		ret.x = -(this.state.w - ret.x);
		ret.y = this.state.h - ret.y;
		this.setPosition(this.state.x + ret.x, this.state.y);
		return ret;
	}

	deltaR(x: number, _y: number) {
		let ret = { x: this.state.w, y: this.state.h };
		this.setSize(this.state.w + x, this.state.h);
		ret.x = this.state.w - ret.x;
		ret.y = this.state.h - ret.y;
		return ret;
	}

	deltaB(_x: number, y: number) {
		let ret = { x: this.state.w, y: this.state.h };
		this.setSize(this.state.w, this.state.h + y);
		ret.x = this.state.w - ret.x;
		ret.y = this.state.h - ret.y;
		return ret;
	}

	deltaT(_x: number, y: number) {
		if (this.state.y + y < 0) {
			y -= (this.state.y + y);
		}

		let ret = { x: this.state.w, y: this.state.h };
		this.setSize(this.state.w, this.state.h - y);
		ret.x = this.state.w - ret.x;
		ret.y = -(this.state.h - ret.y);
		this.setPosition(this.state.x, this.state.y + ret.y);

		return ret;
	}

	deltaLBCorner(x: number, y: number) {
		let ret = this.deltaL(x, y);
		let ret2 = this.deltaB(x, y);
		ret.y = ret2.y;
		return ret;
	}

	deltaRBCorner(x: number, y: number) {
		let ret = this.deltaR(x, y);
		let ret2 = this.deltaB(x, y);
		ret.y = ret2.y;
		return ret;
	}

	deltaRTCorner(x: number, y: number) {
		let ret = this.deltaR(x, y);
		let ret2 = this.deltaT(x, y);
		ret.y = ret2.y;
		return ret;
	}

	deltaLTCorner(x: number, y: number) {
		let ret = this.deltaL(x, y);
		let ret2 = this.deltaT(x, y);
		ret.y = ret2.y;
		return ret;
	}

	setPosition(x: number, y: number) {
		x = Math.max(0, x);
		y = Math.max(0, y);
		x = Math.min(x, 100 - this.state.w);
		y = Math.min(y, 100 - this.state.h);

		(this.state as any).x = x;
		(this.state as any).y = y;
		if (this.base) {
			(this.base as HTMLDivElement).style.left = x + '%';
			(this.base as HTMLDivElement).style.top = y + '%';
		}
	}

	setSize(w: number, h: number) {
		w = Math.max(w, 5);
		h = Math.max(h, 5);
		w = Math.min(w, 100);
		h = Math.min(h, 100);
		if ((this.state.w !== w) || (this.state.h !== h)) {
			if (this.props.onResize) {
				this.props.onResize();
			}
		}
		(this.state as any).w = w;
		(this.state as any).h = h;
		if (this.base) {
			(this.base as HTMLDivElement).style.width = w + '%';
			(this.base as HTMLDivElement).style.height = h + '%';
			let s = ((this.base as HTMLDivElement).querySelector('.window-content') as HTMLElement).style;

			const contentWpx = this.state.w * window.innerWidth / 100;
			const contentHpx = this.state.h * (window.innerHeight - MENU_HEIGHT) / 100 - 17;
			const minW = this.props.minW;
			const minH = this.props.minH;

			if (contentWpx < minW || contentHpx < minH) {
				let scale = Math.min(contentWpx / minW, contentHpx / minH);
				this.renderedScale = scale;
				s.transform = 'scale(' + scale + ')';
				s.transformOrigin = 'left top';
				s.width = Math.max(contentWpx / scale, minW) + 'px';
				s.height = Math.max(contentHpx / scale, minH) + 'px';
			} else {
				this.renderedScale = 1;
				s.transform = '';
				s.transformOrigin = '';
				s.width = '';
				s.height = '';
			}
		}
	}

	clamp() {
		const div = this.base as HTMLDivElement;
		if (div) {
			div.getClientRects();
			let bounds = div.getBoundingClientRect();

			const W = window.innerWidth / 100;
			const H = (window.innerHeight - MENU_HEIGHT) / 100;
			let clamped = false;
			for (let w of noDragWindows) {
				const otherBounds = (w.base as HTMLDivElement).getBoundingClientRect();
				let d = bounds.left - otherBounds.right;
				if (Math.abs(d) > 0.55 && Math.abs(d) < CLAMP_POW) {
					this.setPosition(otherBounds.right / W, this.state.y);
					this.setSize(this.state.w + d / W, this.state.h);
					clamped = true;
				}
				d = bounds.right - otherBounds.left;
				if (Math.abs(d) > 0.55 && Math.abs(d) < CLAMP_POW) {
					this.setSize(this.state.w - d / W, this.state.h);
					clamped = true;
				}
				d = bounds.top - otherBounds.bottom;
				if (Math.abs(d) > 0.55 && Math.abs(d) < CLAMP_POW) {
					this.setPosition(this.state.x, (otherBounds.bottom - MENU_HEIGHT) / H);
					this.setSize(this.state.w, this.state.h + d / window.innerHeight * 100);
					clamped = true;
				}
				d = bounds.bottom - otherBounds.top;
				if (Math.abs(d) > 0.55 && Math.abs(d) < CLAMP_POW) {
					this.setSize(this.state.w, this.state.h - d / window.innerHeight * 100);
					clamped = true;
				}
				if (clamped) {
					return;
				}
			}
		}
	}

	isModal() {
		return editorUtils.isInModal(this.base as any);
	}

	onMouseDown() {
		if (!this.isModal()) {
			Window.bringWindowForward((this.base as HTMLDivElement));
		}
	}

	renderWindowContent(): ComponentChild {
		return this.props.content;
	}

	render(): ComponentChild {

		let contentProps: any = {
			className: 'window-content'
		};

		const contentWpx = this.state.w * window.innerWidth / 100;
		const contentHpx = this.state.h * (window.innerHeight - MENU_HEIGHT) / 100 - 17;
		const minW = this.props.minW;
		const minH = this.props.minH;

		if (contentWpx < minW || contentHpx < minH) {
			let scale = Math.min(contentWpx / minW, contentHpx / minH);
			this.renderedScale = scale;
			contentProps.style = {
				transform: 'scale(' + scale + ')',
				transformOrigin: 'left top',
				width: Math.max(contentWpx / scale, minW) + 'px',
				height: Math.max(contentHpx / scale, minH) + 'px'
			};
		} else {
			this.renderedScale = 1;
		}

		return R.div({
			id: this.props.id,
			onMouseDown: this.onMouseDown,
			className: 'window-body',
			style: {
				left: this.state.x + '%',
				top: this.state.y + '%',
				width: this.state.w + '%',
				height: this.state.h + '%'
			},
			'data-help': 'game.editor.' + this.props.helpId
		},
		R.div({
			className: 'window-header'
		}, this.state.title || this.props.title,
		h(CornerDragger, {
			className: 'window-dragger',
			onDragEnd: this.saveState,
			onDrag: this.deltaPosition,
			owner: this as Window
		})
		),
		R.div(contentProps, this.renderWindowContent()),
		h(CornerDragger, {
			className: 'window-r-dragger',
			onDragEnd: this.saveState,
			onDrag: this.deltaR,
			type: 'v',
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-l-dragger',
			onDragEnd: this.saveState,
			onDrag: this.deltaL,
			type: 'v',
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-b-dragger',
			onDragEnd: this.saveState,
			onDrag: this.deltaB,
			type: 'h',
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-t-dragger',
			onDragEnd: this.saveState,
			onDrag: this.deltaT,
			type: 'h',
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-rb-corner',
			onDragEnd: this.saveState,
			onDrag: this.deltaRBCorner,
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-lb-corner',
			onDragEnd: this.saveState,
			onDrag: this.deltaLBCorner,
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-rt-corner',
			onDragEnd: this.saveState,
			onDrag: this.deltaRTCorner,
			owner: this as Window
		}),
		h(CornerDragger, {
			className: 'window-lt-corner',
			onDragEnd: this.saveState,
			onDrag: this.deltaLTCorner,
			owner: this as Window
		})
		);
	}

	static bringWindowForward(windowBody: HTMLElement | string, setCurrentHelp?: boolean) {
		window.setTimeout(() => {
			if (typeof windowBody === 'string') {
				windowBody = document.querySelector(windowBody) as HTMLElement;
			}
			if (windowBody) {
				if (setCurrentHelp) {
					Help.setCurrentHelp((windowBody as HTMLElement).dataset.help as string);
				}

				let w = Window.allOrdered.find(wnd => wnd.base === windowBody) as Window;
				assert(w, 'Wrong window to bring forward.');
				Window.allOrdered.splice(Window.allOrdered.indexOf(w), 1);
				Window.allOrdered.unshift(w);

				Window.allOrdered.forEach((w, i) => {
					(w.base as HTMLElement).style.zIndex = (Window.allOrdered.length - i).toString();
				});
			}
		}, 1);
	}
}


export default Window;

export type { WindowProps, WindowState };


let emptyImage = new Image();

type DraggerType = 'v' | 'h';


const allDraggers: CornerDragger[] = [];
const activeDraggers: CornerDragger[] = [];
let noDragWindows: Window[] = [];


const addNeighborDraggersAsActive = (thisBounds: DOMRect, ev: DragEvent, draggerType?: DraggerType) => {
	for (let dragger of allDraggers) {
		if (dragger.props.type === draggerType) {
			if (activeDraggers.indexOf(dragger) < 0) {
				const b = (dragger.base as HTMLDivElement).getBoundingClientRect();

				let isDraggersNeighbors = false;

				isDraggersNeighbors =
					((thisBounds.left) <= b.right) &&
					((thisBounds.right) >= b.left) &&
					((thisBounds.top) <= b.bottom) &&
					((thisBounds.bottom) >= b.top);

				if (isDraggersNeighbors) {
					activeDraggers.push(dragger);
					dragger.prevX = ev.pageX;
					dragger.prevY = ev.pageY;
					addNeighborDraggersAsActive(b, ev, draggerType,);
					continue;
				}
			}
		}
	}
};


class CornerDragger extends Component<CornerDraggerProps> {

	prevX = 0;
	prevY = 0;

	constructor(props: CornerDraggerProps) {
		super(props);
		this.dragEndHandler = this.dragEndHandler.bind(this);
		this.dragStartHandler = this.dragStartHandler.bind(this);
		this.dragHandler = this.dragHandler.bind(this);
	}

	componentDidMount(): void {
		if (this.props.type) {
			allDraggers.push(this);
		}
	}

	componentWillUnmount(): void {
		if (this.props.type) {
			allDraggers.splice(allDraggers.indexOf(this), 1);
		}
	}

	dragStartHandler(ev: DragEvent) {
		this.prevX = ev.pageX;
		this.prevY = ev.pageY;
		(ev.dataTransfer as DataTransfer).setDragImage(emptyImage, 0, 0);
		activeDraggers.length = 0;
		activeDraggers.push(this);

		if (!(ev.ctrlKey || ev.metaKey) && !ev.shiftKey && !ev.altKey) {
			let thisBounds = (this.base as HTMLDivElement).getBoundingClientRect();
			addNeighborDraggersAsActive(thisBounds, ev, this.props.type);
		}

		noDragWindows = Window.allOrdered.filter((w) => {
			return !activeDraggers.some(d => d.props.owner === w);
		});
	}

	drag(ev: DragEvent) {
		if (this.prevX !== ev.pageX || this.prevY !== ev.pageY) {
			if (ev.pageX !== 0 || ev.pageY !== 0) {
				let ret = this.props.onDrag((ev.pageX - this.prevX) / window.innerWidth * 100, (ev.pageY - this.prevY) / window.innerHeight * 100);
				this.prevX += Math.round(ret.x * window.innerWidth / 100);
				this.prevY += Math.round(ret.y * window.innerHeight / 100);
			}
		}
	}

	dragHandler(ev: DragEvent) {
		if (ev.x === 0 && ev.y === 0) {
			return; // drag finish generates zero positioned event bug.
		}
		for (let dragger of activeDraggers) {
			dragger.drag(ev);
		}
		if (!(ev.ctrlKey || ev.metaKey) && !ev.shiftKey && !ev.altKey) {
			for (let dragger of activeDraggers) {
				dragger.props.owner.clamp();
			}
		}
	}

	dragEndHandler() {
		for (let dragger of activeDraggers) {
			dragger.props.onDragEnd();
		}
	}

	render() {
		return R.div({
			className: this.props.className,
			onDragStart: this.dragStartHandler,
			onDrag: this.dragHandler,
			onDragEnd: this.dragEndHandler,
			draggable: true
		});
	}
}
</file>

<file path="src/editor/ui/filter-list.ts">
import { h } from 'preact';
import game from 'thing-editor/src/engine/game';
import R from '../preact-fabrics';
import type { ChooseListItem } from './choose-list';
import ChooseList from './choose-list';

const listProps = {
	className: 'filter-list'
};


class FilterList extends ChooseList {

	renderChoosingItem(item: ChooseListItem) {
		return R.div(
			{
				className: item.disabled ? 'filter-list-item disabled' : 'filter-list-item clickable',
				onClick: () => {
					if (!item.disabled) {
						item.unselected = !item.unselected;
						this.forceUpdate();
					}
				},
				key: item.name
			},
			R.input({
				className: 'checkbox filter-list-checkbox',
				type: 'checkbox',
				checked: !item.unselected
			}),
			item.name
		);
	}

	render() {
		return R.div(
			listProps,
			R.div({
				className: 'filter-list-item clickable',
				onClick: () => {
					const checked = this.props.list.every(i => !i.unselected || i.disabled);
					for (let i of this.props.list) {
						if (!i.disabled) {
							i.unselected = checked;
						}
					}
					this.forceUpdate();
				}
			},
			R.input({
				className: 'checkbox filter-list-checkbox',
				type: 'checkbox',
				checked: this.props.list.every(i => !i.unselected || i.disabled)
			}),
			'All'
			),
			super.render(),
			R.btn(
				'Cancel',
				() => {
					game.editor.ui.modal.hideModal(false);
				},
				undefined,
				undefined,
				{key: 'Escape'}
			),
			R.btn(
				this.props.list.every(i => i.unselected) ? 'Continue without assets copying' : 'Copy assets and continue',
				() => {
					game.editor.ui.modal.hideModal(this.props.list.filter((i) => !i.unselected));
				},
				undefined,
				'main-btn',
				{key: 'Enter'}
			)
		);
	}
}

export const showListFilter = (title:string, list:ChooseListItem[]):Promise<ChooseListItem[]> => {
	return game.editor.ui.modal.showModal(h(FilterList, { list, doNotGroup: true }), title, true);
};
</file>

<file path="src/editor/ui/group.ts">
import type { ComponentChild, ComponentChildren } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import game from 'thing-editor/src/engine/game';

const GROUP_ID_CHECKER = /[^0-9a-zA-Z_\-]/gm;

function renderGroup(group: GroupFolderData, idPrefix:string): ComponentChildren | ComponentChildren[] {
	if (Array.isArray(group) && group.__folderName) {
		let key = 'props-group-' + idPrefix + group.__folderName.replace(GROUP_ID_CHECKER, '__');
		return R.div({ key, className: 'props-group ' + key },
			R.div({
				className: 'props-group-header',
				'groupidproperty': key,
				onClick: toggleGroup
			}, group.__subFolderName),
			R.div({ className: 'props-group-body' + (isGroupHidden(key) ? ' hidden' : '') },
				group.map(i => renderGroup(i, idPrefix)))
		);
	}
	return group;
}

interface GroupAbleItem {
	key: string;
}

declare class GroupFolderData extends Array {
	__folderName: string;
	__subFolderName: string;
}


let groupsArray: GroupFolderData;
let groups: KeyedMap<GroupFolderData>;
const getGroupByFolderName = (path:string[]) => {
	let folderName = '';
	let group = groupsArray;
	while (path.length) {
		const subFolderName = path.shift()!;
		folderName += subFolderName + '/';
		if (!groups.hasOwnProperty(folderName)) {
			const g = [] as any;
			group.push(g);
			group = g;
			group.__folderName = folderName;
			group.__subFolderName = subFolderName;
			groups[folderName] = group;
		} else {
			group = groups[folderName];
		}
	}
	return group;
};

function groupArray(a: ComponentChild[], idPrefix:string, delimiter = '/') {
	groups = {};
	groupsArray = [] as any;

	for (let item of a as GroupAbleItem[]) {

		let name = item.key;
		const path = name.split(delimiter);
		path.pop();
		getGroupByFolderName(path).push(item);
	}
	return groupsArray.map(i => renderGroup(i, idPrefix));
}

function isGroupHidden(groupId: string) {
	return game.editor.settings.getItem(groupId, false);
}

function toggleGroup(ev: MouseEvent) {
	let groupId = (ev.target as HTMLDivElement).attributes.getNamedItem('groupidproperty')!.value as string;
	let group = (ev.target as any).closest('.props-group').querySelector('.props-group-body');
	let isHidden = group.classList.contains('hidden');
	game.editor.settings.setItem(groupId, !isHidden);
	if (isHidden) {
		group.classList.remove('hidden');
		group.style.transition = 'unset';
		group.style.opacity = 0.001;
		group.style.position = 'absolute';
		group.style.maxHeight = 'unset';
		group.style.transform = 'scaleY(0)';
		group.style.transformOrigin = 'top left';
		let height: number;
		let timer = window.setInterval(() => {
			height = group.clientHeight;
			if (height > 0) {
				clearInterval(timer);
				group.style.maxHeight = '0px';
				group.style.position = 'unset';
				group.style.opacity = 1;
				group.style.transition = 'all 0.1s';
				timer = window.setInterval(() => {
					if (group.clientHeight <= 6) {
						clearInterval(timer);
						group.style.transform = 'scaleY(1)';
						group.style.maxHeight = height + 'px';
						window.setTimeout(() => {
							group.style.maxHeight = 'unset';
						}, 114);
					}
				}, 1);
			}
		}, 1);
	} else {
		group.style.transform = 'scaleY(1)';
		group.style.transformOrigin = 'top left';
		group.style.transition = 'unset';
		group.style.maxHeight = group.clientHeight + 'px';
		group.style.transition = 'all 0.1s';
		window.setTimeout(() => {
			group.style.transform = 'scaleY(0)';
			group.style.maxHeight = '0px';
		}, 1);
		window.setTimeout(() => {
			group.classList.add('hidden');
		}, 114);
	}
}

export default { renderGroup, groupArray };

export type { GroupAbleItem as GroupAbleItem, GroupFolderData };
</file>

<file path="src/editor/ui/help.ts">
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';

const doNotDisturbHelpIdProps = { 'data-do_not_disturb_helpID': true };
const HELP_ROOT = 'https://github.com/Megabyteceer/thing-editor/wiki/';

let latestClickedHelpURL = HELP_ROOT;

window.addEventListener('mousedown', (ev) => {
	if (ev.buttons === 4) {
		sp(ev);
	}
	let t = ev.target as HTMLElement;
	while (t) {
		if (t.dataset) {
			if (t.dataset.do_not_disturb_helpID) {
				return;
			}
			if (t.dataset.help) {
				Help.setCurrentHelp(t.dataset.help);
				return;
			}
		}
		t = t.parentNode as HTMLElement;
	}
	latestClickedHelpURL = HELP_ROOT + 'editor.Overview';
}, true);

export default class Help extends Component {

	static openErrorCodeHelp(errorCode?: number) {
		if (!errorCode) {
			errorCode = 90001;
		}
		game.editor.openUrl(Help.getUrlForError(errorCode));
	}

	static getUrlForError(errorCode: number): string {
		return HELP_ROOT + 'Error-Messages#' + errorCode;
	}

	static setCurrentHelp(url: string) {
		latestClickedHelpURL = url;
		if (!latestClickedHelpURL.startsWith('http')) {
			latestClickedHelpURL = HELP_ROOT + latestClickedHelpURL;
		}
	}

	render() {
		return R.span(doNotDisturbHelpIdProps, R.btn('Help (F1)', () => {
			game.editor.openUrl(latestClickedHelpURL);
		},
			'Click any element and then press (F1) to see its description.',
			'menu-btn',
			{ key: 'F1' }
		));
	}
}
</file>

<file path="src/editor/ui/isolation.ts">
import type { Container } from 'pixi.js';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import game from 'thing-editor/src/engine/game';


const toggleIsolation = () => {
	if (EDITOR_FLAGS.isolationEnabled) {
		exitIsolation();
	} else {
		isolateSelected();
	}
};

const isolateSelected = () => {
	EDITOR_FLAGS.isolationEnabled = true;

	game.forAllChildrenEverywhere(isolateObject);
	for (let o of game.editor.selection) {
		unIsolateObject(o);
		o.forAllChildren(unIsolateObject);
		let p = o.parent;
		while (p) {
			unIsolateObject(p);
			p = p.parent;
			if (!p.__nodeExtendData.isolate) {
				break;
			}
		}
	}
	game.editor.refreshTreeViewAndPropertyEditor();
};

const exitIsolation = () => {
	if (EDITOR_FLAGS.isolationEnabled) {
		EDITOR_FLAGS.isolationEnabled = false;
		game.forAllChildrenEverywhere(unIsolateObject);
		game.editor.refreshTreeViewAndPropertyEditor();
	}
};

const isolateObject = (o: Container) => {
	o.__nodeExtendData.isolate = true;
};

const unIsolateObject = (o: Container) => {
	o.__nodeExtendData.isolate = false;
};

export { exitIsolation, toggleIsolation };
</file>

<file path="src/editor/ui/labels-logger.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes, ComponentChild } from 'preact';
import { h } from 'preact';

import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Window from 'thing-editor/src/editor/ui/editor-window';
import MainMenu from 'thing-editor/src/editor/ui/main-menu';
import { hideAdditionalWindow, showAdditionalWindow } from 'thing-editor/src/editor/ui/ui';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import game from 'thing-editor/src/engine/game';
import copyTextByClick from '../utils/copy-text-by-click';

import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import { searchByRegexpOrText } from '../utils/search-by-regexp-or-text';
import type { SelectEditorItem } from './props-editor/props-editors/select-editor';
import SelectEditor from './props-editor/props-editors/select-editor';

let lastItemTime = 0;

/// 99999

interface LabelsLoggerProps extends ClassAttributes<LabelsLogger> {
}

let listProps = {
	className: 'window-scrollable-content labels-log-list',
};

const enum FilterType {
	ALL = 'all',
	AFFECTS_SELECTION = 'affecting selection',
	SELECTION_IS_ROOT = 'selection is root'
}

const filterSelect = [
	{
		name: FilterType.ALL,
		value: FilterType.ALL
	},
	{
		name: FilterType.AFFECTS_SELECTION,
		value: FilterType.AFFECTS_SELECTION
	},
	{
		name: FilterType.SELECTION_IS_ROOT,
		value: FilterType.SELECTION_IS_ROOT
	}
] as SelectEditorItem[];

interface LabelsLoggerState {
	search: string;
	filter: FilterType;
}

interface LabelLogItem {
	label: string;
	root: Container;
	_rootId: number;
	time: number;
}


let labelNamesProps = {
	className: 'selectable-text labels-log-label',
	title: CTRL_READABLE + '+click to copy label`s name',
	onMouseDown: copyTextByClick
};


const log: LabelLogItem[] = [];

let instance: LabelsLogger;

export default class LabelsLogger extends ComponentDebounced<LabelsLoggerProps, LabelsLoggerState> {

	searchInputProps: KeyedObject;
	constructor(props: LabelsLoggerProps) {
		super(props);

		this.state = {
			search: '',
			filter: FilterType.ALL
		};

		this.searchInputProps = {
			className: 'search-input',
			onInput: this.onSearchChange.bind(this),
			placeholder: 'Search'
		};
	}

	onSearchChange(ev: InputEvent) {
		let search = (ev.target as HTMLInputElement).value.toLowerCase();
		this.setState({ search });
	}

	clearSearch() {
		this.setState({search: undefined});
	}

	static allLabels = new Set() as Set<string>;

	static logGotoLabelRecursive(label: string, root:Container) {
		this.allLabels.add(label);
		if (instance && !game.currentScene?.___framesToSkip) {
			log.push({label, root, _rootId: root.___id, time: game.time});
			if (log.length > 1100) {
				log.splice(0, 100);
			}
			instance.refresh();
		}
	}

	static refresh() {
		instance?.refresh();
	}

	componentDidMount(): void {
		instance = this;
	}

	componentWillUnmount(): void {
		instance = null!;
	}

	renderItem(item: LabelLogItem) {
		const isRemoved = item._rootId !== item.root.___id;
		const timeDelta = item.time - lastItemTime;
		lastItemTime = item.time;
		const timeSplitter = R.div({title: 'game.time shift in frames', className: 'labels-log-time'}, timeDelta ? ('+' + timeDelta) : undefined);

		return R.fragment(
			R.div(
				{
					className: isRemoved ? 'labels-log-item disabled' : (item.root.__nodeExtendData.isSelected ? 'labels-log-item labels-log-item-selected' : 'labels-log-item'),
					onClick: isRemoved ? undefined : () => {
						game.editor.selection.select(item.root);
						instance.refresh();
					}
				},
				timeSplitter,
				R.span(labelNamesProps, item.label),
				R.sceneNode(item.root)
			)
		);
	}

	render(): ComponentChild {
		let list = log;
		if (this.state.search) {
			list = log.filter((item) => {
				if (searchByRegexpOrText(item.label, this.state.search)) {
					return true;
				}
				if (item._rootId === item.root.___id) {
					if (searchByRegexpOrText(item.root.name || '', this.state.search)) {
						return true;
					}
					if (searchByRegexpOrText((item.root.constructor as SourceMappedConstructor).__className!, this.state.search)) {
						return true;
					}
				}
			});
		}

		if (this.state.filter !== FilterType.ALL) {
			const filterContainers = new Set();
			for (let container of game.editor.selection) {
				filterContainers.add(container);
				if (this.state.filter === FilterType.AFFECTS_SELECTION) {
					while (container) {
						container = container.parent;
						filterContainers.add(container);
					}
				}
			}
			list = list.filter(i => filterContainers.has(i.root));
		}

		lastItemTime = list[0]?.time || 0;

		return R.fragment(
			R.btn('×', LabelsLogger.toggle, 'Hide labels logger', 'close-window-btn', { key: 'Escape' }),

			R.div({className: 'choose-list-header'},
				h(SelectEditor, {
					select: filterSelect,
					onChange: (filter: FilterType) => {
						this.setState({filter});
					}, value: this.state.filter
				}), R.input(this.searchInputProps), R.btn('×', this.clearSearch, 'Discard search filter', 'close-btn clear-search-btn')
			),
			R.div(listProps,
				list.map(this.renderItem)
			),
			R.btn(R.fragment('CLEAR', R.icon('delete')), clearLog, undefined, 'danger', undefined, !log.length)
		);
	}

	static toggle() {
		game.editor.settings.setItem('labels-logger-shown', !game.editor.settings.getItem('labels-logger-shown'));
		LabelsLogger.renderWindow();
	}

	static renderWindow() {
		if (game.editor.settings.getItem('labels-logger-shown')) {
			LabelsLogger.show();
		} else {
			LabelsLogger.hide();
		}
	}

	static show() {
		showAdditionalWindow('labels-logger', 'LabelsLogger', 'Labels Logger',
			h(LabelsLogger, null),
			50, 50, 80, 80, 450, 200);
		Window.bringWindowForward('#labels-logger');
	}

	static hide() {
		hideAdditionalWindow('labels-logger');
	}
}

window.setTimeout(LabelsLogger.renderWindow, 100,);

function clearLog() {
	log.length = 0;
	instance?.refresh();
}

editorEvents.on('playToggle', clearLog);

MainMenu.injectMenu('settings', [{
	name: () => {
		return R.span(null, R.span({ className: '.menu-icon' }, game.editor.settings.getItem('labels-logger-shown') ? '☑' : '☐'), ' Labels logger');
	},
	hotkey: { key: 'l', ctrlKey: true, shiftKey: true },
	onClick: () => {
		LabelsLogger.toggle();
	},
	stayAfterClick: true
}], 'labels-logger', -1);
</file>

<file path="src/editor/ui/language-view.ts">
import { Text } from 'pixi.js';
import type { ClassAttributes, ComponentChild } from 'preact';
import { h } from 'preact';
import type { FileDescL10n } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Window from 'thing-editor/src/editor/ui/editor-window';
import group from 'thing-editor/src/editor/ui/group';
import type { SelectEditorItem } from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import SelectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import { hideAdditionalWindow, showAdditionalWindow } from 'thing-editor/src/editor/ui/ui';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import scrollInToViewAndShake from 'thing-editor/src/editor/utils/scroll-in-view';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import L from 'thing-editor/src/engine/utils/l';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import { StatusClearingCondition } from './status-clearing-condition';

/** dir_name >> language >> FileDescL10n */
const assetsFiles: Map<string, Map<string, FileDescL10n>> = new Map();

type L10NData = KeyedMap<string>;

let currentLanguageData: L10NData;

const assetsDirs: string[] = [];

let langsIdsList: string[] = [];
let currentDirAssets: Map<string, FileDescL10n>;
let currentDir: string;
let languages: KeyedMap<L10NData> = {};

let currentIdsList: string[] = [];

let instance: LanguageView | null;

let assetsFilesIsDirty = false;

let ignoreEdit = false;

const priority = (file:FileDescL10n) => {
	let ret = file.lang.charCodeAt(0);
	if (file.priority) {
		ret += file.priority;
	}
	if (file.lang === game.projectDesc.defaultLanguage) {
		ret += 10000000;
	}
	return ret;
};
const sortLanguages = (a:FileDescL10n, b:FileDescL10n) => {
	return priority(b) - priority(a);
};

export default class LanguageView extends ComponentDebounced<ClassAttributes<LanguageView>> {

	componentDidMount(): void {
		instance = this;
	}

	componentWillUnmount(): void {
		instance = null;
	}

	render(): ComponentChild {
		return R.fragment(
			R.btn('×', LanguageView.toggle, 'Hide Text Editor', 'close-window-btn', {key: 'Escape'}),
			h(LanguageTableEditor, null));
	}

	static selectableList: SelectEditorItem[] = [];

	static addAssets() {
		if (!initialized) {
			init();
		}
		assetsFilesIsDirty = true;
	}

	static removeAsset() {
		assetsFilesIsDirty = true;
	}

	static toggle() {
		if (!instance) {
			showAdditionalWindow('language-view', 'language-view', 'Localization', h(LanguageView, null), 40, 0, 100, 70, 600, 300);
			Window.bringWindowForward('#language-view');
		} else {
			hideAdditionalWindow('language-view');
		}
	}

	static editKey(key: string | null, langId: string = L.getCurrentLanguageId()) {
		if (!ignoreEdit) {
			ignoreEdit = true;
			window.setTimeout(() => {
				ignoreEdit = false;
			}, 10);
			showTextTable().then(() => {
				if (key) {
					view!.createKeyOrEdit(key, langId);
				} else {
					view!.onAddNewKeyClick();
				}
			});
		}
	}

	static addTranslationToProject(key:string, value:string, langId:string) {
		if (currentDirAssets) {

			const file = currentDirAssets.get(langId)!;
			if (!file.readOnly) {
				file.asset[key] = value;
				onModified(langId);
			}

			if (view) {
				view.forceUpdate();
			}
			return true;
		}
	}

	static __validateTextData() {
		currentDirAssets.forEach((langData, langId) => {

			let templatesExample;
			for (let textId in langData) {
				let text = langData.asset[textId];
				if (text) {

					let a: string[] = [];
					text.replace(/%\w/gm, ((m: string) => {
						a.push(m);
					}) as any);

					a.sort((a, b) => {
						if (a > b) return 1;
						if (a < b) return -1;
						return 0;
					});
					let templates = a.join(',');

					if (typeof templatesExample === 'undefined') {
						templatesExample = templates;
					} else {
						if (templatesExample !== templates) {
							(() => {
								let localLangId = langId;
								let localTextId = textId;
								game.editor.ui.status.warn('Localization data with id "' + textId + '" has no matched %d %s templates set.', 32052, () => {
									LanguageView.editKey(localTextId, localLangId);
								}, undefined, undefined, undefined, StatusClearingCondition.TEXT_EDITOR_CLOSE);
							})();
						}
					}
				}
			}
		});
	}

	static __getTextAssets() {
		return languages;
	}
}

const assetsUpdateHandler = (enforced = false) => {
	if (assetsFilesIsDirty && (game.editor.isProjectOpen || enforced)) {
		parseAssets();
		if (instance) {
			instance.refresh();
		}
	}
};

let initialized = false;
const init = () => {
	initialized = true;
	editorEvents.on('assetsRefreshed', assetsUpdateHandler);
	editorEvents.on('firstSceneWillOpen', () => assetsUpdateHandler(true));
};


const __serializeLanguage = (langData: KeyedObject, empty = false) => {
	let ret: KeyedObject = {};
	for (let srcId in langData) {
		if (langData.hasOwnProperty(srcId)) {
			let a = srcId.split(/[\.]/gm);
			let r = ret;
			while (a.length > 1) {
				let pathPart = a.shift() as string;
				if (!r.hasOwnProperty(pathPart)) {
					r[pathPart] = {};
				}
				r = r[pathPart];
			}
			r[a[0]] = empty ? '' : langData[srcId];
		}
	}
	return ret;
};

const parseAssets = () => {
	assetsFilesIsDirty = false;

	const list = LanguageView.selectableList;
	list.length = 0;

	assetsDirs.length = 0;
	langsIdsList.length = 0;
	currentIdsList.length = 0;

	languages = {};

	assetsFiles.clear();

	const files = fs.getAssetsList(AssetType.L10N) as FileDescL10n[];

	for (const file of files) {
		const a = file.fileName.split('/');
		if (!file.lang) {
			file.lang = (a.pop()!).replace(/\.l\.json$/, '');
		}
		if (!file.dir) { // can be already set in assets-loader.cjs
			file.dir = a.join('/');
		}
	}

	files.sort(sortLanguages);

	for (const file of files) {
		if (!assetsFiles.has(file.dir)) {
			assetsFiles.set(file.dir, new Map());
			assetsDirs.push(file.dir);
		}
		assetsFiles.get(file.dir)!.set(file.lang, file);

		const langId = file.lang;
		let langData: L10NData;
		if (!languages[file.lang]) {
			langsIdsList.push(langId);
			langData = {};
			languages[langId] = langData;
		} else {
			langData = languages[langId];
		}
		Object.assign(langData, file.asset);
	}

	if (!currentDir) {
		game.editor.assetsFoldersReversed.some(folder => {
			return files.some((file) => {
				if (file.fileName.startsWith('/' + folder) || file.isDefault) {
					currentDir = file.dir;
					return true;
				}
			});
		});
	}

	currentDirAssets = assetsFiles.get(currentDir)!;

	const firstFile = currentDirAssets.values().next().value!;
	for (let key in firstFile.asset) {
		currentIdsList.push(key);
	}

	L.setLanguagesAssets(languages);
	L.setCurrentLanguage();

	currentLanguageData = languages[L.getCurrentLanguageId()];

	for (let key in currentLanguageData) {
		list.push({
			value: key,
			name: key
		});
	}

	list.sort(sortTextList);

	list.unshift({
		value: null,
		name: '- - -'
	});

	assetsFiles.forEach((folderFiles: Map<string, FileDescL10n>) => {
		const langs = L.getLanguagesList();
		for (const langId of langs) {
			if (!folderFiles.has(langId)) {
				L.getLanguagesList();
				createFilesForLanguage(langId);
			}
		}
	});
	generateLocalizationTypings();
};

const generateLocalizationTypings = () => {
	const src = ['export interface LocalizationKeys {'];
	for (const key in currentLanguageData) {
		src.push('(id: \'' + key + '\', values?: KeyedObject | number): string;');
	}
	src.push('}\n');
	fs.writeFile('/thing-editor/src/editor/localization-typings.ts', src.join('\n'));
};

const sortTextList = (a: SelectEditorItem, b: SelectEditorItem) => {
	if (a.value > b.value) {
		return 1;
	} else {
		return -1;
	}
};

//////////////////////////////////////////////////////////
////// TABLE ////////////////////////////////////////////
////////////////////////////////////////////////////////

const tableBodyProps = { className: 'langs-editor-table' };
const langsEditorProps = { className: 'langs-editor' };
const langsEditorWrapperProps = { className: 'langs-editor-wrapper' };

function showTextTable(): Promise<void> {
	return new Promise((resolve) => {
		if (!view) {
			LanguageView.toggle();
			window.setTimeout(resolve, 1);
		} else {
			resolve();
		}
	});
}

let view: LanguageTableEditor | null;

interface LanguageTableEditorState {
	filter?: string;
}

class LanguageTableEditor extends ComponentDebounced<ClassAttributes<LanguageTableEditor>, LanguageTableEditorState> {

	searchInputProps = {
		className: 'language-search-input',
		onInput: this.onSearchChange.bind(this),
		placeholder: 'Search',
		value: ''
	};

	constructor(props: ClassAttributes<LanguageTableEditor>) {
		super(props);
		this.onAddNewLanguageClick = this.onAddNewLanguageClick.bind(this);
		this.onAddNewKeyClick = this.onAddNewKeyClick.bind(this);
		this.state = {};
	}

	onSearchChange(ev: InputEvent) {
		this.searchInputProps.value = (ev.target as any).value;
		this.setState({ filter: (ev.target as any).value.toLowerCase() });
	}

	componentDidMount() {
		view = this;
	}

	componentWillUnmount() {
		view = null;
		game.editor.ui.status.clearByCondition(StatusClearingCondition.TEXT_EDITOR_CLOSE);
		LanguageView.__validateTextData();
	}

	onAddNewLanguageClick() {
		game.editor.ui.modal.showPrompt('Enter new language ID:',
			'ru',
			(langId) => { //filter
				return langId.toLowerCase();
			},
			(langId) => { //accept
				if (currentLanguageData.hasOwnProperty(langId)) {
					return 'Language with ID=' + langId + ' already exists';
				}
			}
		).then((langId) => {
			if (langId) {
				createFilesForLanguage(langId);
				this.forceUpdate();
			}
		});
	}

	onAddNewKeyClick() {

		let defaultKey = game.editor.projectDesc.__localesNewKeysPrefix;
		for (let o of game.editor.selection) {
			let props = (o.constructor as SourceMappedConstructor).__editableProps;
			for (let p of props) {
				if (p.type === 'l10n') {
					let k = (o as any)[p.name];
					if (k) {
						if (!L.has(k)) {
							defaultKey = k;
						}
						break;
					}
				}
			}
		}
		if (!defaultKey) {
			if (currentIdsList[0]) {
				let a = currentIdsList[0].split('.');
				a.pop();
				defaultKey = a.join('.');
				if (defaultKey) {
					defaultKey += '.';
				}
			} else {
				defaultKey = '';
			}
		}

		game.editor.ui.modal.showPrompt('Enter new translatable KEY:',
			defaultKey,
			(key) => { //filter
				return key;
			},
			isKeyInvalid
		).then((enteredName) => {
			if (enteredName) {
				this.createKeyOrEdit(enteredName, undefined, true);
			}
		});
	}

	createKeyOrEdit(key: string, langId = 'en', enforceCreateInCurrentSource = false) {
		showTextTable().then(() => {

			if (!enforceCreateInCurrentSource) {
				if (!currentIdsList.includes(key)) { // find key in another source
					for (const dirAssets of assetsFiles.values()) {
						for (const file of dirAssets.values()) {
							if (file.asset.hasOwnProperty(key)) {
								currentDir = file.dir;
								parseAssets();
								this.refresh();

								setTimeout(() => {
									this.createKeyOrEdit(key, langId, enforceCreateInCurrentSource);
								}, 20);
								return;
							}
						}
					}
				}
			}

			if (!currentLanguageData.hasOwnProperty(key)) {
				currentDirAssets.forEach((file) => {
					file.asset[key] = '';
				});
				parseAssets();
				onModified(langId);
				this.forceUpdate();

				if (game.editor.selection.length === 1) {
					if (game.editor.selection[0] instanceof Text) {
						let t = game.editor.selection[0];
						if (((!t.text) || (t.text === 'New Text 1')) && !t.translatableText) {
							game.editor.onObjectsPropertyChanged(t, 'translatableText', key);
						}
					}
				}
			}
			window.setTimeout(() => {
				let area = document.querySelector('.langs-editor-table #' + textAreaID(langId, key)) as HTMLTextAreaElement;
				scrollInToViewAndShake(area);
				area.focus();
			}, 10);
		});
	}

	render() {

		let lines: ComponentChild[] = [];

		let header = R.div({ className: 'langs-editor-tr langs-editor-header' }, R.div({ className: 'langs-editor-th' }), langsIdsList.map((langId) => {
			return R.div({ key: langId, className: 'langs-editor-th' }, langId);
		}));

		currentIdsList.forEach((id) => {
			let filter = this.state.filter;
			if (filter) {
				if (id.indexOf(filter) < 0) {
					if (langsIdsList.every(langId => (currentDirAssets.get(langId)!).asset[id]?.toLowerCase().indexOf(filter!) < 0)) {
						return;
					}
				}
			}

			lines.push(R.span({ key: id, className: 'langs-editor-tr' },
				R.div({
					className: 'langs-editor-th selectable-text',
					title: CTRL_READABLE + '+click to copy key, Double click to rename, Right click to delete',
					onContextMenu: sp,
					onMouseDown: (ev: PointerEvent) => {
						let currentKey = (ev.target as any).innerText as string;

						if (ev.buttons === 2) {
							return game.editor.ui.modal.showEditorQuestion('Translatable key delete', 'Delete key ' + currentKey + '?', () => {
								currentDirAssets.forEach((file) => {
									delete file.asset[currentKey];
								});
								onModified();
								this.forceUpdate();
							});
						}
						else if ((ev.ctrlKey || ev.metaKey)) {
							copyTextByClick(ev);
						}
						sp(ev);
					},
					onDoubleClick: (ev: PointerEvent) => {
						let currentKey = (ev.target as any).innerText as string;

						return game.editor.ui.modal.showPrompt('Translatable key rename:', currentKey, undefined, (nameToCheck) => {
							if (nameToCheck === currentKey) {
								return 'Please rename key.';
							}
							if (currentLanguageData.hasOwnProperty(nameToCheck)) {
								return 'Key with that name already exists.';
							}
						}).then((newKey) => {
							if (newKey) {
								currentDirAssets.forEach((file) => {
									file.asset[newKey] = currentLanguageData[id];
									delete file.asset[id];
								});

								onModified();
								this.forceUpdate();
							}
						});
					}
				}, id),
				langsIdsList.map((langId) => {

					const asset = currentDirAssets.get(langId)!;
					if (!asset) {
						return undefined;
					}

					let text = asset.asset[id];

					let areaId = textAreaID(langId, id);

					return R.div({ key: langId, className: asset.__isLangIdPlaceHolder ? 'langs-editor-td disabled' : 'langs-editor-td' },
						R.textarea({
							key: asset.assetName + '_' + areaId,
							value: text,
							id: areaId,
							disabled: asset.readOnly,
							onInput: (ev: InputEvent) => {
								console.log('edited: ' + id);
								asset.asset[id] = (ev.target as any).value as string;
								parseAssets();
								onModified(langId);
							}
						})
					);
				})
			));
		});

		if (!this.state.filter) {
			lines = group.groupArray(lines, 'language-view', '.');
		}

		const select: SelectEditorItem[] = assetsDirs.map((dir) => {
			return { value: dir, name: dir };
		});

		const openBtn = R.btn('🔍 file', () => {
			const firstFile = currentDirAssets.values().next().value!;
			game.editor.editSource(firstFile.fileName);
		});

		return R.div(langsEditorProps,
			R.btn('+ Add translatable KEY...', this.onAddNewKeyClick, undefined, 'main-btn'),
			R.btn('+ Add language...', this.onAddNewLanguageClick),
			R.input(this.searchInputProps),
			(assetsDirs.length > 1) ? R.div(null, 'Localization data source: ',
				h(SelectEditor, {
					onChange: (value: string) => {
						if (value !== currentDir) {
							currentDir = value;
							parseAssets();
							this.forceUpdate();
						}

					}, noCopyValue: true, value: currentDir, select
				})
				, openBtn) : R.div(null, currentDir, openBtn),
			R.div(langsEditorWrapperProps,
				header,
				R.div(tableBodyProps,
					lines
				)
			)
		);
	}
}

function isKeyInvalid(val: string) {
	if (currentLanguageData.hasOwnProperty(val)) {
		return 'ID already exists';
	}
	if (val.endsWith('.') || val.startsWith('.')) {
		return 'ID can not begin or end with "."';
	}
	if (val.match(/[^a-zA-Z\._\d\/]/gm)) {
		return 'ID can contain letters, digits, "_", "/" and "."';
	}
}

const idFixer = /[^0-9a-z\-]/ig;
function textAreaID(lang: string, id: string) {
	return (lang + '-' + id).replace(idFixer, '-');
}


let debounceTimeOut = 0;
function onModified(modifiedLangId?: string) {
	if (modifiedLangId) {
		currentDirAssets.get(modifiedLangId)!.isDirty = true;
	} else {
		for (const file of 	currentDirAssets.values()) {
			file.isDirty = true;
		}
	}
	if (debounceTimeOut) {
		clearTimeout(debounceTimeOut);
	}

	debounceTimeOut = window.setTimeout(() => {
		L.refreshAllTextEverywhere();

		currentDirAssets.forEach((file) => {
			if (!file.readOnly) {
				if (file.isDirty) {
					let content = __serializeLanguage(file.asset);
					fs.saveAsset(file.assetName, AssetType.L10N, content, undefined, true);
				}
			}
		});

		debounceTimeOut = 0;
	}, 600);
	parseAssets();
}

function createFilesForLanguage(langId: string) {
	let created = false;

	assetsFiles.forEach((dirAssets: Map<string, FileDescL10n>, dir: string) => {
		if (!dirAssets.has(langId)) {
			if (dir.endsWith('.l.json')) {
				// add placeholders for non standard translations added via assets-loader.js
				const placeholder = Object.assign({}, dirAssets.values().next().value) as FileDescL10n;
				placeholder.__isLangIdPlaceHolder = true;
				dirAssets.set(langId, placeholder);
			} else if (!game.projectDesc.__doNotAutoCreateLocalizationFiles) {

				let langData: KeyedObject = __serializeLanguage((currentDirAssets.values().next().value as FileDescL10n).asset, true);
				const fileName = dir + '/' + langId + '.l.json';
				fs.writeFile(fileName, langData);
				game.editor.ui.status.warn('Localization file ' + fileName + ' created.', 90001, () => {
					fs.showFile(fileName);
					game.editor.ui.status.clearLastClickedItem();
				});

				created = true;
			}
		}
		if (created) {
			fs.refreshAssetsList();
		}
	});
}
</file>

<file path="src/editor/ui/local-store-view.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Window from 'thing-editor/src/editor/ui/editor-window';
import { hideAdditionalWindow, showAdditionalWindow } from 'thing-editor/src/editor/ui/ui';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

let instance: LocalStoreView | null;

const LIST_PROPS = { className: 'window-scrollable-content local-store-view' };
const ROW_PROPS = { className: 'local-store-row' };

const HEADER_COLUMN_PROPS = {
	className: 'selectable-text local-store-column local-store-column-header',
	title: CTRL_READABLE + '+click to copy',
	onMouseDown: copyTextByClick
};

const COLUMN_PROPS = {
	className: 'selectable-text local-store-column',
	title: CTRL_READABLE + '+click to copy',
	onMouseDown: copyTextByClick
};

interface LocalStoreViewState {
	filter?: string;
}

export default class LocalStoreView extends ComponentDebounced<ClassAttributes<LocalStoreView>, LocalStoreViewState> {

	searchInputProps = {
		className: 'local-store-search-input',
		onInput: this.onSearchChange.bind(this),
		placeholder: 'Search',
		value: ''
	};

	static refresh() {
		if (instance) {
			instance.refresh();
		}
	}

	static toggle() {
		if (!instance) {
			showAdditionalWindow('language-view', 'language-view', 'Localization', h(LocalStoreView, null), 40, 0, 100, 70, 600, 300);
			Window.bringWindowForward('#language-view');
		} else {
			hideAdditionalWindow('language-view');
		}
	}

	componentDidMount(): void {
		instance = this;
	}

	componentWillUnmount(): void {
		instance = null;
	}

	onSearchChange(ev: InputEvent) {
		this.searchInputProps.value = (ev.target as any).value;
		this.setState({ filter: (ev.target as any).value.toLowerCase() });
	}

	render(): ComponentChild {
		const list = [];

		let filter = this.state.filter;

		for (const key in game.settings.data) {

			const val = JSON.stringify(game.settings.data[key]);
			if (filter) {
				if (!key.toLocaleLowerCase().includes(filter) && !val.toLocaleLowerCase().includes(filter)) {
					continue;
				}
			}
			list.push(R.div(ROW_PROPS,
				R.span(HEADER_COLUMN_PROPS, key),
				R.span(COLUMN_PROPS, val),
				R.btn('×', () => {
					game.settings.removeItem(key);
					this.refresh();
				})
			));
		}


		return R.fragment(
			R.btn('×', LocalStoreView.toggle, 'Hide Local Store View', 'close-window-btn', {key: 'Escape'}),
			R.input(this.searchInputProps),
			R.div(
				LIST_PROPS,
				list
			),
			R.btn(R.fragment('Clear local store', R.icon('delete')), () => {
				game.editor.ui.modal.showEditorQuestion('Are you sure?', 'You about to remove game\'s local store data.', () => {
					game.settings.clear();
					LocalStoreView.toggle();
				}, R.fragment('Clear ', R.icon('delete')));
			})
		);
	}
}
</file>

<file path="src/editor/ui/main-menu.ts">
import type { ComponentChild } from 'preact';
import { Component, h } from 'preact';
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';

import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu, { toggleContextMenu } from 'thing-editor/src/editor/ui/context-menu';
import Window from 'thing-editor/src/editor/ui/editor-window';
import Build from 'thing-editor/src/editor/utils/build';
import newComponentWizard from 'thing-editor/src/editor/utils/new-component-wizard';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import { onNewSceneClick, onSaveAsSceneClick } from 'thing-editor/src/editor/utils/scene-utils';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type ___Ruler from 'thing-editor/src/engine/lib/assets/src/___system/ruler.c';
import L from 'thing-editor/src/engine/utils/l';

// no R.span because it causes use before initialization
const CHECKED = h('span', { className: '.menu-icon' }, '☑');
const UNCHECKED = h('span', { className: '.menu-icon' }, '☐');

let unmutedIconsCache: ComponentChild;
const UNMUTED_ICON = (): ComponentChild => {
	if (!unmutedIconsCache) {
		unmutedIconsCache = R.icon('asset-sound');
	}
	return unmutedIconsCache;
};

let mutedIconsCache: ComponentChild;
const MUTED_ICON = (): ComponentChild => {
	if (!mutedIconsCache) {
		mutedIconsCache = R.icon('sound-mute');
	}
	return mutedIconsCache;
};

const menuProps = {
	className: 'main-menu',
	'data-help': 'editor.MainMenu'
};

const chooseProjectClick = () => {
	game.editor.chooseProject();
};

const saveSceneClick = () => {
	game.editor.saveCurrentScene();
};

const savePrefabClick = () => {
	PrefabEditor.acceptPrefabEdition();
};

const exitClick = () => {
	fs.exitWithResult('exit menu click');
};

const browseClick = () => {
	fs.browseDir(game.editor.currentProjectDir);
};

const projectPropsClick = () => {
	game.editor.editSource(game.editor.currentProjectDir + 'thing-project.json');
};

const buildReleaseClick = () => {
	Build.build(false);
};

const buildDebugClick = () => {
	Build.build(true);
};

interface MainMenuItem {
	name: string;
	id: string;
	items: ContextMenuItem[];
}

const MUTE_SOUND_MENU_ITEM: ContextMenuItem = {
	name: () => {
		return R.span(null, game.editor.settings.getItem('sound-muted') ? MUTED_ICON() : UNMUTED_ICON(), ' Mute game sounds');
	},
	onClick: () => {
		game.editor.toggleSoundMute();
	},
	stayAfterClick: true,
	hotkey: { key: 'm', ctrlKey: true }
};

function switchLanguage(direction: number) {
	let a = L.getLanguagesList();
	let i = a.indexOf(L.getCurrentLanguageId());
	i += direction;
	if (i < 0) i = a.length - 1;
	if (i >= a.length) i = 0;
	L.setCurrentLanguage(a[i]);
}

const MAIN_MENU: MainMenuItem[] = [
	{
		name: 'File',
		id: 'file',
		items: [
			{
				name: 'Open project...',
				onClick: chooseProjectClick,
				hotkey: { key: 'o', ctrlKey: true }
			},
			null,
			{
				name: 'Save scene',
				onClick: saveSceneClick,
				hotkey: { key: 's', ctrlKey: true },
				disabled: () => !game.editor.isCurrentContainerModified || PrefabEditor.currentPrefabName as any as boolean
			},
			{
				name: 'Save prefab',
				onClick: savePrefabClick,
				hotkey: { key: 's', ctrlKey: true },
				disabled: () => !game.editor.isCurrentContainerModified || !PrefabEditor.currentPrefabName as any as boolean
			},
			null,
			{
				name: 'New Component...',
				onClick: newComponentWizard
			},
			null,
			{
				name: 'New scene...',
				onClick: onNewSceneClick,
				hotkey: { key: 'n', ctrlKey: true }
			},
			{
				name: 'Save scene as...',
				onClick: onSaveAsSceneClick,
				hotkey: { key: 's', ctrlKey: true, shiftKey: true }
			},
			null,
			{
				name: 'Exit',
				onClick: exitClick,
				hotkey: { key: 'w', ctrlKey: true }
			}
		]
	},
	{
		name: 'Edit',
		id: 'edit',
		items: [
		]
	},
	{
		name: 'Project',
		id: 'project',
		items: [
			{
				name: 'Browse project folder...',
				tip: 'Reveal project folder in Explorer',
				onClick: browseClick,
				hotkey: { key: 'b', ctrlKey: true }
			},
			null,
			{
				name: 'Build release...',
				onClick: buildReleaseClick
			},
			{
				name: 'Build debug...',
				onClick: buildDebugClick
			},
			null,
			{
				name: 'Local store view...',
				tip: 'View \'game.settings\' saved data content.',
				onClick: () => game.editor.LocalStoreView.toggle()
			},
			{
				name: 'Text data editor...',
				tip: 'Edit localization text data',
				onClick: () => game.editor.LanguageView.toggle(),
				hotkey: { key: 'e', ctrlKey: true }
			},
			{
				name: () => {
					return R.span(null, 'Switch project language [', R.b({ className: 'project-language-tip' }, L.getCurrentLanguageId()), ']');
				},
				onClick: () => {
					switchLanguage(1);
				},
				disabled: () => {
					return L.getLanguagesList().length < 2;
				},
				stayAfterClick: true,
				hotkey: { key: 'l', ctrlKey: true, altKey: true }
			},
			{
				name: 'Project Properties...',
				tip: 'Edit thing-project.json file',
				onClick: projectPropsClick
			}
		]
	},
	{
		name: 'Settings',
		id: 'settings',
		items: [
			MUTE_SOUND_MENU_ITEM,
			{
				name: () => {
					return R.span(null, game.isMobile.any ? CHECKED : UNCHECKED, ' isMobile.any',);
				},
				onClick: () => {
					game.editor.toggleIsMobileAny();
				},
				hotkey: { key: 'm', ctrlKey: true, shiftKey: true },
				stayAfterClick: true
			},
			{
				name: () => {
					return R.span(null, game.editor.settings.getItem('show-gizmo', true) ? CHECKED : UNCHECKED, ' Gizmo');
				},
				tip: 'Hides gizmo and selection outline.',
				onClick: () => {
					game.editor.toggleHideHelpers();
				},
				stayAfterClick: true,
				hotkey: { key: 'h', ctrlKey: true }
			},
			{
				name: () => {
					return R.span(null, game.editor.settings.getItem('safe-area-frame', true) ? CHECKED : UNCHECKED, ' Safe area');
				},
				tip: 'Hides project`s safe area frame.',
				onClick: () => {
					game.editor.toggleSafeAreaFrame();
				},
				stayAfterClick: true,
				hotkey: { key: 'f', ctrlKey: true }
			},
			null,
			{
				name: () => {
					return R.span(null, game.editor.settings.getItem('show-system-assets') ? CHECKED : UNCHECKED, ' Show editor`s system assets');
				},
				onClick: () => {
					game.editor.toggleShowSystemAssets();
				},
				stayAfterClick: true
			},
			{
				name: () => {
					return R.span(null, game.editor.settings.getItem('vs-code-excluding') ? CHECKED : UNCHECKED, ' VScode excluding');
				},
				tip: 'Does VSCode should exclude other projects from workspace.',
				onClick: () => {
					game.editor.toggleVSCodeExcluding();
				},
				stayAfterClick: true
			},
			{
				name: 'Open dev tools',
				hotkey: {key: 'F12'},
				onClick: () => {
					fs.openDevTools();
				}
			},
			{
				name: 'Reset windows layout',
				onClick: () => {
					for (const w of Window.allOrdered) {
						w.eraseSettings();
						w.resetLayout();
					}
					location.reload();
				}
			},
			{
				name: 'Show ruler',
				hotkey: {key: 'r', altKey: true},
				onClick: async () => {
					const overlay = (await import('thing-editor/src/editor/ui/editor-overlay')).default;
					const ruler = overlay.getChildByName('___system/ruler') as ___Ruler;
					if (ruler) {
						ruler.removeRuler();
					} else {
						const ruler = Lib.__loadPrefabNoInit('___system/ruler') as ___Ruler;
						overlay.addChild(ruler);
						ruler.initRuler();
					}
				}
			}
		]
	}
];

const injectedMenus: Map<string, ContextMenuItem[]> = new Map();

export default class MainMenu extends Component {

	static injectMenu(targetMenuId: 'file' | 'edit' | 'project' | 'settings' | any, items: ContextMenuItem[], injectionId: string, pos?: number) {
		let menu: MainMenuItem | undefined = MAIN_MENU.find(i => i.id === targetMenuId);
		if (!menu) {
			menu = {
				id: targetMenuId,
				name: targetMenuId,
				items: []
			};
			MAIN_MENU.push(menu);
		}

		if (injectedMenus.has(injectionId)) {
			const oldItems = injectedMenus.get(injectionId)!;
			let i = 0;
			for (const item of oldItems) {
				i = menu.items.findIndex(i => i === item, i - 1); // remove closest null splitter
				assert(i >= 0, 'main menu re-injection error');
				menu.items.splice(i, 1);
			}
		}
		injectedMenus.set(injectionId, items);

		if (typeof pos === 'number') {
			if (pos < 0) {
				pos = menu.items.length + pos;
			}
			menu.items.splice(pos, 0, ...items);
		} else {
			menu.items = menu.items.concat(items);
		}
	}

	render() {
		if (!game.editor) {
			return R.span(null,);
		}
		return R.div(menuProps,
			MAIN_MENU.map((menuItem: MainMenuItem) => {
				return R.span({
					onPointerOver: (ev: PointerEvent) => {
						if (document.querySelector('.context-menu')) {
							(ev.target as HTMLElement).focus();
							showContextMenu(menuItem.items, ev);
						}
					}
				},
				R.btn(menuItem.name, (ev: PointerEvent) => {
					if (toggleContextMenu(menuItem.items, ev)) {
						(ev.target as HTMLElement).focus();
					} else {
						(ev.target as HTMLElement).blur();
					}
				}, 'menu item id: ' + menuItem.id));
			}));
	}

}

export { MAIN_MENU, MUTE_SOUND_MENU_ITEM };
</file>

<file path="src/editor/ui/modal.ts">
import type { ClassAttributes, Component, ComponentChild } from 'preact';
import { h } from 'preact';
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics.js';
import type { ChooseListItem } from 'thing-editor/src/editor/ui/choose-list';
import ChooseList from 'thing-editor/src/editor/ui/choose-list';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Help from 'thing-editor/src/editor/ui/help';
import Prompt from 'thing-editor/src/editor/ui/modal/prompt';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import assert from 'thing-editor/src/engine/debug/assert.js';
import game from 'thing-editor/src/engine/game';
import { getCurrentStack } from '../utils/stack-utils';

let modal: Modal;

interface ModalEntry {
	content: ComponentChild;
	title: ComponentChild;
	noEasyClose: boolean;
	resolve: (res: unknown) => void;
	onCancel?: () => void;
}

let topModalEntry :ModalEntry | undefined;

const questionFooterProps = { className: 'modal-footer' };

let blackoutProps = { className: 'modal-blackout fadein-animation' };
let blackoutPropsClosable = {
	className: 'modal-blackout fadein-animation', style: { cursor: 'pointer' }, onMouseDown: (ev: PointerEvent) => {
		if ((ev.target as HTMLElement).className.indexOf('modal-blackout') === 0) {
			if (topModalEntry!.onCancel) {
				topModalEntry!.onCancel();
			}
			modal.hideModal();
		}
	}
};

let spinnerProgress = -1;
let spinnerName: string | undefined;
let spinnerProps = { className: 'modal-spinner' };
let spinnerOverlayProps = { className: 'modal-spinner-overlay' };
let spinnerProgressProps = { className: 'modal-spinner-progress' };
let bodyProps = { className: 'modal-body' };
let titleProps = { className: 'modal-title' };
let contentProps = {
	className: 'modal-content',
	ref: (content: HTMLDivElement | null) => {
		if (content) {
			const searchInput = (content as HTMLDivElement).querySelectorAll('input')[0] as HTMLInputElement;

			if (searchInput) {
				window.setTimeout(() => {
					searchInput.select();
				}, 10);
			}
		}
	}
};
let errorProps = { className: 'error' };
let notifyProps = { className: 'modal-notification' };
let notifyWrapperProps = { className: 'modal-notification-wrapper', style: { left: '0px', top: '0px' } };
let notifyPropsDuringSpinner = { className: 'modal-notification modal-notification-centred modal-notification-wrapper' };

let notifyTexts: Set<string | Component> = new Set();
const notifyHides: Map<string, string | Component> = new Map();

let spinnerShowCounter = 0;
const spinnerCallStacks = [] as any;

let renderModal = (props: ModalEntry, i: number) => {
	let title;

	if (props.title) {
		title = R.div(titleProps, props.title);
	}

	topModalEntry = props;

	return R.div({ key: i },
		R.div(props.noEasyClose ? blackoutProps : blackoutPropsClosable,
			R.div(bodyProps,
				title,
				R.div(contentProps,
					props.content
				)
			)
		)
	);
};

let renderSpinner = () => {
	return R.div(blackoutProps,
		R.div(spinnerProps),
		R.div(spinnerOverlayProps),
		(spinnerProgress >= 0) ? R.div(spinnerProgressProps, R.div({style: {width: (spinnerProgress * 100) + '%'}}), spinnerName) : undefined
	);
};


interface ModalState {
	modals: ModalEntry[];
}

class Modal extends ComponentDebounced<ClassAttributes<Modal>, ModalState> {

	constructor() {
		super();
		this.state = {
			modals: []
		};
	}

	isUIBlockedByModal(element?: HTMLElement) {
		if (!element) {
			return false;
		}
		if (this.isSpinnerShown()) {
			return true;
		}

		if (this.state.modals.length > 0) {
			const topModals = document.querySelectorAll('.modal-body');
			const topModal = topModals[topModals.length - 1];
			return !topModal.contains(element) && !element.classList.contains('modal-close-button');
		}
		return false;
	}

	hideModal(val?: any) {
		assert(modal.state.modals.length > 0, 'tried to close modal dialogue, but no one opened.');
		let closedModalItem = modal.state.modals.pop()!;
		modal.refresh(() => {
			closedModalItem.resolve(val);
		});
	}

	showModal(content: ComponentChild, title: ComponentChild = '', noEasyClose = false, toBottom = false, onCancel?:() => void): Promise<any> {
		if (game.editor.buildProjectAndExit) {
			fs.log('editor.ui.modal.showModal() called');
			fs.exitWithResult(undefined, getCurrentStack('modal shown').stack);
		}
		game.editor.blurPropsInputs();
		return new Promise((resolve) => {
			modal.state.modals[toBottom ? 'unshift' : 'push']({ content, title, noEasyClose, resolve, onCancel });
			modal.refresh();
		});
	}

	showInfo(message: ComponentChild, title: ComponentChild, errorCode = 99999) {
		return this.showModal(message, errorCode ?
			R.span(null, R.icon('info'), errorCode, ' ', title, R.btn('?', () => {
				Help.openErrorCodeHelp(errorCode);
			}, 'Open description for this message (F1)', 'error-help-button', { key: 'F1' }))
			: title
		);
	}

	showPrompt(title: ComponentChild, defaultText?: string, filter?: (val: string) => string, accept?: (val: string) => string | undefined, noEasyClose?: boolean, multiline?: boolean, variants?: string[]):Promise<string | undefined> {
		return this.showModal(h(Prompt, { defaultText, filter, accept, multiline, variants }), title, noEasyClose);
	}

	showListChoose(title: ComponentChild, list: any[], noEasyClose?: boolean, noSearchField = false, activeValue?: string, doNotGroup = false, onCancel?:() =>void):Promise<ChooseListItem | undefined> {
		return this.showModal(h(ChooseList, { list, noSearchField, activeValue, doNotGroup}), title, noEasyClose, false, onCancel);
	}

	notify(txt: string | Component, hideId?: string) {
		if (EDITOR_FLAGS.isTryTime) {
			return Promise.resolve();
		}
		if (game.editor.buildProjectAndExit) {
			console.log('notification: ');
			console.log(txt);
		}
		notifyTexts.add(txt);
		if (hideId) {
			if (notifyHides.has(hideId)) {
				notifyTexts.delete(notifyHides.get(hideId)!);
			}
			notifyHides.set(hideId, txt);
		}

		window.setTimeout(() => {
			notifyTexts.delete(txt);
			this.refresh();
		}, 1200);
		this.refresh();
	}

	componentDidMount() {
		assert(!modal, 'Modal already mounted.');
		modal = this;
	}

	isSpinnerShown() {
		return spinnerShowCounter > 0;
	}

	showSpinner() {
		spinnerShowCounter++;
		spinnerCallStacks.push(getCurrentStack('showSpinner()'));
		if (spinnerShowCounter === 1) {
			if (game.stage) {
				game.stage.interactiveChildren = false;
			}
			modal.refresh();
		}
	}


	setSpinnerProgress(val:number, operationName?:string) {
		spinnerProgress = val;
		spinnerName = operationName;
		modal.refresh();
	}

	hideSpinner() {
		spinnerProgress = -1;
		spinnerShowCounter--;
		spinnerCallStacks.pop();
		assert(spinnerShowCounter >= 0, 'hideSpinner() invoked without showSpinner()');
		if (spinnerShowCounter === 0) {
			window.setTimeout(() => {
				if (game.stage) {
					game.stage.interactiveChildren = true;
				}
				modal.refresh();
			}, 10);
		}
	}

	showEditorQuestion(title: ComponentChild, message: ComponentChild, onYes: () => void, yesLabel: ComponentChild = 'Ok', onNo?: () => void, noLabel: ComponentChild = 'Cancel', noEasyClose = false) {

		let yesBtn = R.btn(yesLabel, () => {
			modal.hideModal(true);
			if (onYes) {
				onYes();
			}
		}, undefined, 'main-btn', { key: 'Enter' });

		let noBtn;
		if (typeof onNo !== 'undefined') {
			noBtn = R.btn(noLabel, () => {
				modal.hideModal();
				onNo();
			});
		}

		if (game.editor.buildProjectAndExit) {
			fs.log(JSON.stringify(message));
			fs.exitWithResult(undefined, 'editor modal question shown.');
		} else {
			return this.showModal(R.div(null, message,
				R.div(questionFooterProps,
					yesBtn,
					noBtn
				)
			), title, noEasyClose);
		}
	}

	__debugSpinnerCallStack() {
		return spinnerCallStacks;
	}

	showError(message: ComponentChild, errorCode = 99999, title = 'Error!', noEasyClose = false, toBottom = false): Promise<any> {
		if (EDITOR_FLAGS.isTryTime) {
			return Promise.resolve();
		}
		try {
			document.fullscreenElement && document.exitFullscreen();
		} catch (_er) { /**/ }

		if (game.editor.buildProjectAndExit) {
			message = preactComponentChildToString(message);
			fs.exitWithResult(undefined, 'Build failed: ' + game.editor.buildProjectAndExit + '\n' + message + '; Error code: ' + errorCode);
			return Promise.resolve();
		} else {
			if (game.stage && !game.__EDITOR_mode) {
				window.setTimeout(game.editor.ui.viewport.stopExecution, 0);
			}
			return this.showModal(R.div(errorProps, R.multilineText(message)), R.span(null, R.icon('error'), errorCode, ' ', title, R.btn('?', () => {
				Help.openErrorCodeHelp(errorCode);
			}, 'Open description for this error (F1)', 'error-help-button', { key: 'F1' })), noEasyClose, toBottom);
		}
	}

	showFatalError(message: ComponentChild, errorCode: number, additionalText = 'Please check console output for exceptions messages, and restart application (Reload page) by press (F5) button. You will receive question about saving any unsaved changes.') {
		if (EDITOR_FLAGS.isTryTime) {
			return Promise.resolve();
		}
		game.editor.__FatalError = true;
		this.showError(R.div(null, R.div(null, R.b(null, R.multilineText(message))), R.multilineText(additionalText), R.br(), R.btn('Dev Tools', () => fs.openDevTools()), R.btn('Reload editor', () => location.reload())), errorCode, 'Fatal Error', true, true);
	}

	render(): ComponentChild {
		let spinner: ComponentChild;
		if (spinnerShowCounter > 0) {
			spinner = renderSpinner();
		}

		let notify: ComponentChild;
		let notifies: ComponentChild[] = [];
		notifyWrapperProps.style.left = (Math.min(game.editor.mouseX, document.body.clientWidth - 300)) + 'px';
		notifyWrapperProps.style.top = (game.editor.mouseY) + 'px';
		notifyTexts.forEach((notifyText) => {
			notifies.push(R.div(notifyProps, notifyText));
		});
		if (notifies.length > 0) {
			notify = R.div(spinner ? notifyPropsDuringSpinner : notifyWrapperProps, notifies);
		}

		let hotkeyButton;
		if (this.state.modals.length > 0) {
			hotkeyButton = R.btn('х', () => {
				let m = modal.state.modals[modal.state.modals.length - 1];
				if (m && !m.noEasyClose) {
					modal.hideModal();
				}
			}, undefined, 'modal-close-button hidden', { key: 'Escape' });
		}
		return R.fragment(spinner, this.state.modals.map(renderModal), notify, hotkeyButton);
	}
}

function preactComponentChildToString(message: ComponentChild) {
	if (typeof message === 'string') {
		return message;
	}
	let ret = '';
	try {
		JSON.stringify(message, (key, value) => {
			if (key !== 'type' && typeof value === 'string') {
				ret += value + '\n';
			}
			return value;
		});
	} catch (_er) { }
	return ret;
}

export default Modal;

export { preactComponentChildToString };
</file>

<file path="src/editor/ui/modal/prompt.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import copyTextByClick from '../../utils/copy-text-by-click';

let modalRejectProps = { className: 'modal-reject-text' };

interface PromptProps extends ClassAttributes<Prompt> {
	defaultText?: string;
	filter?: (val: string) => string;
	accept?: (val: string) => string | undefined;
	multiline?: boolean;
	/** accept button tool tip */
	title?: string;
	variants?: string[];
}

interface PromptState {
	value: string;
	rejectReason?: ComponentChild;
	accepted?: boolean;
}

const variantItemNameProps = {
	className: 'selectable-text class-name',
	title: CTRL_READABLE + '+click to copy name',
	onMouseDown: copyTextByClick
};

export default class Prompt extends Component<PromptProps, PromptState> {

	constructor(props: PromptProps) {
		super(props);
		this.state = { value: props.defaultText || '' };
		this.onChange = this.onChange.bind(this);
		this.onAcceptClick = this.onAcceptClick.bind(this);
	}

	componentDidMount() {
		window.setTimeout(() => {
			let input = document.querySelector('.modal-content input') as HTMLInputElement;
			if (input) {
				try {
					input.focus();
					input.setSelectionRange(0, input.value.length);
				} catch (_er) { }
			}
		}, 1);
		this.checkAcceptance(this.state.value);
	}

	onChange(ev: InputEvent) {
		let val = this.props.filter ? this.props.filter((ev.target as HTMLInputElement).value) : (ev.target as HTMLInputElement).value;
		this.checkAcceptance(val);
	}

	checkAcceptance(val: string) {
		let reject = this.props.accept ? this.props.accept(val) : undefined;
		this.setState({
			value: val,
			rejectReason: reject,
			accepted: (val && !reject) as boolean
		});
	}

	onAcceptClick() {
		if (this.state.accepted) {
			game.editor.ui.modal.hideModal(this.state.value);
		}
	}

	render() {
		let input = (this.props.multiline ? R.textarea : R.input);

		let variantsView;
		let variantsStrings = (this.props.variants) ? this.props.variants.filter(v => !this.state.value || v.includes(this.state.value)) : undefined;
		if (variantsStrings) {
			if (variantsStrings.length > 20) {
				variantsStrings.length = 20;
			}

			const selection = R.span({className: 'selected-text'}, this.state.value);

			variantsView = variantsStrings.map((txt) => {
				const isBlocked = this.props.accept && this.props.accept(txt);

				const a = ('_' + txt).split(this.state.value);
				const labelArray = [] as any[];
				for (const txt of a) {
					if (labelArray.length) {
						labelArray.push(selection);
						labelArray.push(txt);
					} else {
						labelArray.push(txt.substring(1));
					}
				}
				const label = R.span(variantItemNameProps, labelArray);

				return R.btn(label, (ev) => {
					if (ev.ctrlKey || ev.metaKey) {
						game.editor.copyToClipboard(txt);
					} else {
						this.setState({value: txt, accepted: true});
						setTimeout(() => {
							this.onAcceptClick();
						}, 10);
					}
				}, undefined, 'prompt-variant-item', undefined, !!isBlocked);
			});
		}

		return R.fragment(
			R.div(modalRejectProps, this.state.rejectReason),
			R.div({ className: 'prompt-dialogue' },
				variantsView,
				input({ value: this.state.value, onInput: this.onChange, onKeyDown: (ev: KeyboardEvent) => {
					if (ev.key === 'Enter') {
						if (!this.props.multiline) {
							this.onAcceptClick();
							sp(ev);
						}
					}
				}
				 })
			),
			R.btn('Ok', this.onAcceptClick, this.props.title, 'main-btn', this.props.multiline ? undefined : { key: 'Enter' })
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/get-property-definition-url.ts">
import fs from 'thing-editor/src/editor/fs';

const getPropertyDefinitionUrl = (fileName: string, fieldName: string, Class: SourceMappedConstructor): string => {
	if (!Class.hasOwnProperty('__sourceCode')) {
		Class.__sourceCode = fs.readFile(fileName).split('\n');
	}

	const src = Class.__sourceCode;

	let fieldRegExp1 = new RegExp('\\s*((set|get)\\s+)*' + fieldName + '[\\s=;:\\(]');
	let fieldRegExp2 = new RegExp('_editableEmbed\\(\\S+,\\s*[\'"`]' + fieldName + '[\'"`]');
	let fieldRegExp3 = new RegExp('\\.prototype, [\'"`]' + fieldName + '[\'"`]');

	src.some((line, i) => {
		let match = fieldRegExp1.exec(line);
		if (match) {
			if (i > 0 && src[i - 1].indexOf('@editable(') >= 0) {
				fileName += ':' + (i + 1) + ':' + (match.index + 1);
				return true;
			}
		}
		match = fieldRegExp2.exec(line);
		if (match) {
			fileName += ':' + (i + 1) + ':' + (match.index + 1);
			return true;
		}
		match = fieldRegExp3.exec(line);
		if (match) {
			fileName += ':' + (i + 1) + ':' + (match.index + 1);
			return true;
		}
	});

	return fileName;
};

export { getPropertyDefinitionUrl };
</file>

<file path="src/editor/ui/props-editor/props-editor.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes, Component, ComponentChild, ComponentType } from 'preact';
import { h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import { propertyAssert } from 'thing-editor/src/editor/props-editor/editable';
import Window from 'thing-editor/src/editor/ui/editor-window';
import type { GroupFolderData } from 'thing-editor/src/editor/ui/group';
import PropsFieldWrapper from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import BooleanEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/boolean-editor';
import BtnProperty from 'thing-editor/src/editor/ui/props-editor/props-editors/btn-editor';
import CallbackEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/call-back-editor';
import 'thing-editor/src/editor/ui/props-editor/props-editors/color-editor';
import ColorEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/color-editor';
import DataPathEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/data-path-editor';
import 'thing-editor/src/editor/ui/props-editor/props-editors/number-editor';
import NumberEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/number-editor';
import { PowDampPresetEditor } from 'thing-editor/src/editor/ui/props-editor/props-editors/pow-damp-preset-selector';
import RefFieldEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/refs-editor';
import 'thing-editor/src/editor/ui/props-editor/props-editors/string-editor';
import StringEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/string-editor';
import TimelineEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-editor';

import fs, { AssetType } from 'thing-editor/src/editor/fs';
import group from 'thing-editor/src/editor/ui/group';
import ImageEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/image-editor';
import L10nEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/l10n-editor';
import PrefabPropertyEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/prefab-property-editor';
import RectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/rect-editor';
import SoundEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/sound-editor';
import { getSerializedObjectClass } from 'thing-editor/src/editor/utils/generate-editor-typings';
import getObjectDefaults from 'thing-editor/src/editor/utils/get-prefab-defaults';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import scrollInToViewAndShake from 'thing-editor/src/editor/utils/scroll-in-view';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import ResourceEditor from './props-editors/resource-editor';
import SpineSequencesEditor from './props-editors/spine-sequences/spine-sequences-editor';

let editorProps = {
	className: 'props-editor window-scrollable-content',
	onscroll: (ev: Event) => {
		game.editor.settings.setItem('props-editor-scroll-y', (ev.target as HTMLDivElement).scrollTop);
	}
};

const prefabSelectCaret = R.span({ className: 'prefab-change-caret' }, '▾');

const headerProps = {
	className: 'props-header'
};

const MIXED_ICON = {
	__EDITOR_icon: 'tree/mixed-type'
};

const NOTHING_SELECTED = R.div({
	style: {
		display: 'flex',
		alignItems: 'center',
		justifyContent: 'center',
		height: '100%'
	}
}, 'Nothing selected');

type EditablePropsRenderer = ComponentType<Component>;

const renderers: Map<EditablePropertyType, EditablePropsRenderer> = new Map();
const typeDefaults: Map<EditablePropertyType, any> = new Map();

class PropsEditor extends ComponentDebounced<ClassAttributes<PropsEditor>> {

	editableProps: KeyedMap<boolean> = {};
	disableReasons: KeyedMap<string | undefined> = {};

	refs: Map<string, PropsFieldWrapper> = new Map();

	static registerRenderer(type: EditablePropertyType, render: any, def: any) {
		assert(!renderers.has(type), 'Renderer for type \'' + type + '\' already defined.');
		renderers.set(type, render);
		typeDefaults.set(type, def);
	}

	static getRenderer(prop: EditablePropertyDesc): EditablePropsRenderer {
		propertyAssert(prop, renderers.has(prop.type), 'Property with type \'' + prop.type + '\' has no renderer.');
		return renderers.get(prop.type) as EditablePropsRenderer;
	}

	static getDefaultForType(prop: EditablePropertyDesc): any {
		propertyAssert(prop, typeDefaults.has(prop.type), 'Property with type \'' + prop.type + '\' has no default value.');
		return typeDefaults.get(prop.type);
	}

	restoreScrollPosInterval = 0;

	componentDidMount(): void {
		this.restoreScrollPosInterval = window.setInterval(() => {
			const div = (this.base as HTMLDivElement);
			if (div.querySelector('.props-group-props-editorBasic__props')) {
				div.scrollTop = game.editor.settings.getItem('props-editor-scroll-y', 0);
				clearInterval(this.restoreScrollPosInterval);
				this.restoreScrollPosInterval = 0;
			}
		}, 10);
	}

	componentWillUnmount(): void {
		if (this.restoreScrollPosInterval) {
			clearInterval(this.restoreScrollPosInterval);
		}
	}

	onChangePrefabClick() {
		game.editor.choosePrefab('Select prefab to reference to', game.editor.selection[0].__nodeExtendData.isPrefabReference).then((selectedPrefabName) => {
			if (selectedPrefabName) {
				let newObjects = [];
				const selected = game.editor.selection.slice();
				for (let o of selected) {
					const objectData = Lib.__serializeObject(o);
					objectData.r = selectedPrefabName!;

					let newObject = Lib._deserializeObject(objectData);

					if ((newObject instanceof MovieClip) && newObject._timelineData) {
						for (let animationField of newObject._timelineData.f) {
							const animationValue = animationField.t[0].v;
							if ((newObject as KeyedObject)[animationField.n] !== animationValue) {
								(newObject as KeyedObject)[animationField.n] = animationValue;
								game.editor.ui.status.warn('Value of property "' + animationField.n + '" was changed to ' + animationValue + ' because its refers to MovieClip where property is animated.', 30018, newObject, animationField.n);
								game.editor.sceneModified();
							}
						}
					}

					Lib.__invalidateSerializationCache(o.parent);
					o.parent.addChildAt(newObject, o.parent.children.indexOf(o));
					o.remove();
					newObjects.push(newObject);
				}
				game.editor.selection.clearSelection();
				for (let o of newObjects) {
					game.editor.selection.add(o);
				}
				game.editor.refreshTreeViewAndPropertyEditor();
				game.editor.sceneModified(true);
			}
		});
	}

	onChangeClassClick() {
		let title;
		let isScene = game.editor.selection[0] instanceof Scene;
		if (isScene) {
			title = 'Choose new scene type for current scene';
		} else {
			title = 'Choose new type for ' + game.editor.selection.length + ' selected element';
			if (game.editor.selection.length > 1) {
				title += 's';
			}
		}
		game.editor.chooseClass(isScene, '_changeClass', title, ((game.editor.selection[0].__nodeExtendData.unknownConstructor || game.editor.selection[0].constructor) as SourceMappedConstructor).__className).then((selectedClassName) => {
			if (selectedClassName) {
				const selectedClass = game.classes[selectedClassName];
				assert(selectedClass, 'Class selection return wrong class name.');
				let a = game.editor.selection.slice(0);
				let selectionData = game.editor.selection.saveSelection();

				a.some((o) => {
					o.__nodeExtendData.isTypeChanging = true;
					if (selectedClass.__beforeChangeToThisType) {
						(selectedClass.__beforeChangeToThisType as (o: Container) => void)(o);
					}
					o.constructor = selectedClass; // assign temporary fake constructor
					delete o.__nodeExtendData.unknownConstructor;
					delete o.__nodeExtendData.unknownConstructorProps;
					Lib.__invalidateSerializationCache(o);

				});

				let isDataOfScene = game.currentContainer instanceof Scene;
				let newSceneData = Lib.__serializeObject(game.currentContainer);

				a.some((o) => {
					assert(o.hasOwnProperty('constructor'), '');
					delete (o as any).constructor;
					o.__nodeExtendData.isTypeChanging = false;
				});
				game.__setCurrentContainerContent(Lib._deserializeObject(newSceneData, isDataOfScene));
				game.editor.selection.loadSelection(selectionData);
				game.editor.sceneModified(true);
			}
		});
	}

	selectField(fieldName: string, focus = false, selectAll = false, fieldArrayItemNumber = -1) {
		let a = fieldName.split(',');

		window.setTimeout(() => {

			let fn = a[0];
			this.refs.forEach((field) => {
				if (field.props.field.name === fn) {
					field.onAutoSelect(a);
				}
			});

			let fldInput: HTMLInputElement = document.querySelector('.props-editor #property-editor-' + fn.replace('.', '_')) as HTMLInputElement;
			if (fieldArrayItemNumber >= 0) {
				fldInput = fldInput.querySelectorAll('.array-prop-item')[fieldArrayItemNumber] as HTMLInputElement;
			}

			if (!fldInput) {
				try {
					fldInput = document.querySelector(fieldName) as HTMLInputElement;
				} catch (_er) {
					//
				}
			}
			if (fldInput) {

				if (fn === fieldName) {
					Window.bringWindowForward(fldInput.closest('.window-body') as HTMLInputElement);
					scrollInToViewAndShake(fldInput);
				}

				if (focus || selectAll) {
					let input = fldInput.querySelector('input');
					if (input) {
						input.focus();
						if (selectAll && input.value) {
							input.select();
						}
					}
				}
			}
		}, 10);
	}

	render() {

		const visibleProps: KeyedMap<number> = {};
		this.editableProps = visibleProps as any as KeyedMap<boolean>;

		if (game.editor.selection.length <= 0) {
			return NOTHING_SELECTED;
		}
		const node = game.editor.selection[0];
		const Constructor = (node.constructor as SourceMappedConstructor);

		let props: EditablePropertyDesc[] = Constructor.__editableProps;


		let prefabReferencesPresent = false;
		let nonPrefabsPresent = false;

		for (let o of game.editor.selection) {
			if (o.__nodeExtendData.isPrefabReference) {
				prefabReferencesPresent = true;
			} else {
				nonPrefabsPresent = true;
			}
			let hidePropsEditor = o.__nodeExtendData.hidePropsEditor;
			if (hidePropsEditor && !hidePropsEditor.visibleFields) {
				return hidePropsEditor.title || 'Not editable';
			}
			let props = (o.constructor as SourceMappedConstructor).__editableProps;
			for (let p of props) {
				let name = p.name;
				if ((!hidePropsEditor) || hidePropsEditor.visibleFields[name] || name === '__root-splitter') {
					visibleProps[name] = visibleProps.hasOwnProperty(name) ? (visibleProps[name] + 1) : 1;
				}
			}
		}
		props = props.filter((p) => {

			if (visibleProps[p.name] === game.editor.selection.length) {

				let propDisabled;
				if (node.__nodeExtendData.unknownConstructor) {
					propDisabled = 'Can not edit unknown typed object. Fix type problem first.';
				} else if (node.__nodeExtendData.unknownPrefab) {
					propDisabled = 'Can not edit reference to unknown prefab. Fix prefab problem first.';
				}

				if (!propDisabled) {
					propDisabled = (p.disabled && p.disabled(node)) ||
						(Constructor.__isPropertyDisabled && Constructor.__isPropertyDisabled!(p));
				}

				this.editableProps[p.name] = !propDisabled;
				this.disableReasons[p.name] = (typeof propDisabled === 'string') ? propDisabled : undefined;
				return true;
			} else {
				this.disableReasons[p.name] = 'Not all selected objects have that property.';
				this.editableProps[p.name] = false;
			}
		});

		let propsList: ComponentChild[] = [];
		let currentPropsGroup!: GroupFolderData;

		const defaultValues = getObjectDefaults(node);

		for (let p of props) {
			if (p.visible) {
				let invisible;
				for (let o of game.editor.selection) {
					if (!p.visible(o)) {
						invisible = true;
						break;
					}
				}

				if (invisible) {
					currentPropsGroup.push( // invisible property place holder
						R.div({ key: p.name })
					);
					continue;
				}
			}

			if (p.type === 'splitter') {
				if (currentPropsGroup) {
					propsList.push(group.renderGroup(currentPropsGroup, 'props-editor'));
				}
				currentPropsGroup = [] as any;
				currentPropsGroup.__folderName = currentPropsGroup.__subFolderName = p.title!;
			} else {
				currentPropsGroup.push(
					h(PropsFieldWrapper, { key: p.name, defaultValue: defaultValues[p.name], propsEditor: this, field: p, onChange: game.editor.editProperty })
				);
			}
		}
		assert(currentPropsGroup, 'Properties list started not with splitter.');
		propsList.push(group.renderGroup(currentPropsGroup, 'props-editor'));

		let header: ComponentChild;
		if (prefabReferencesPresent === nonPrefabsPresent) {
			header = 'References and non references are selected.';
		} else if (nonPrefabsPresent) {
			let classButtonContent;
			if (node.__nodeExtendData.unknownConstructor) {
				classButtonContent = R.fragment(R.classIcon(node.constructor as SourceMappedConstructor), ' ', R.b({
					className: 'danger selectable-text',
					title: CTRL_READABLE + '+click to copy Class`s name',
					onMouseDown: copyTextByClick
				}, node.__nodeExtendData.unknownConstructor));
			} else {
				let firstClass = node.constructor as SourceMappedConstructor;
				if (game.editor.selection.some((o) => {
					return o.constructor !== firstClass;
				})) {
					classButtonContent = R.fragment(R.classIcon(MIXED_ICON as SourceMappedConstructor), ' Mixed types selected');
				} else {
					classButtonContent = R.fragment(R.classIcon(firstClass), ' ', R.b({
						className: 'selectable-text',
						title: CTRL_READABLE + '+click to copy Class`s name',
						onMouseDown: copyTextByClick
					}, firstClass.__className));
				}
			}
			header = R.btn(classButtonContent, this.onChangeClassClick, 'Change objects Class', undefined, undefined, !game.__EDITOR_mode);
			const deserializedFrom = game.editor.selection[0]?.__nodeExtendData.__deserializedFromPrefab;
			if (!game.__EDITOR_mode && deserializedFrom) {
				header = R.fragment(
					header,
					R.btn(R.b({
						className: 'selectable-text',
						title: CTRL_READABLE + '+click to copy prefab`s name',
						onMouseDown: copyTextByClick
					}, deserializedFrom), () => {
						const prefabName = deserializedFrom;
						if (prefabName) {
							game.editor.ui.viewport.stopExecution();
							PrefabEditor.editPrefab(prefabName, true);
						}
					}, undefined, undefined, { key: 'e', ctrlKey: true })
				);
			}
		} else {
			if (node.__nodeExtendData.unknownPrefab) {
				header = R.btn(R.fragment(
					R.b({
						className: 'danger selectable-text',
						title: CTRL_READABLE + '+click to copy prefab`s name',
						onMouseDown: copyTextByClick
					}, node.__nodeExtendData.unknownPrefab),
					prefabSelectCaret
				), this.onChangePrefabClick, 'Change prefab referenced to', 'danger', undefined, !game.__EDITOR_mode);
			} else {
				const prefabName = node.__nodeExtendData.isPrefabReference!;


				const file = fs.getFileByAssetName(prefabName, AssetType.PREFAB);


				header = R.fragment(

					R.btn(R.b({
						ctrlClickCopyValue: prefabName,
						className: 'selectable-text',
						title: CTRL_READABLE + '+click to copy prefab`s name',
						onMouseDown: copyTextByClick
					},
					R.span(null, R.classIcon(getSerializedObjectClass(file.asset)), prefabName),
					prefabSelectCaret
					), this.onChangePrefabClick, 'Change prefab referenced to', 'change-prefab-button', undefined, !game.__EDITOR_mode),
					R.btn('Edit prefab', () => {
						PrefabEditor.editPrefab(prefabName, true);
					}, undefined, undefined, { key: 'e', ctrlKey: true }, !game.__EDITOR_mode)
				);
			}
		}

		return R.div(editorProps, R.div(headerProps, header), propsList);
	}
}

export default PropsEditor;

PropsEditor.registerRenderer('color', ColorEditor, 0);
PropsEditor.registerRenderer('number', NumberEditor, 0);
PropsEditor.registerRenderer('string', StringEditor, null);
PropsEditor.registerRenderer('l10n', L10nEditor, null);
PropsEditor.registerRenderer('image', ImageEditor, null);
PropsEditor.registerRenderer('resource', ResourceEditor, null);
PropsEditor.registerRenderer('prefab', PrefabPropertyEditor, null);
PropsEditor.registerRenderer('sound', SoundEditor, null);
PropsEditor.registerRenderer('boolean', BooleanEditor, false);
PropsEditor.registerRenderer('btn', BtnProperty, undefined);
PropsEditor.registerRenderer('splitter', null, undefined);
PropsEditor.registerRenderer('ref', RefFieldEditor, undefined);
PropsEditor.registerRenderer('data-path', DataPathEditor, null);
PropsEditor.registerRenderer('callback', CallbackEditor, null);
PropsEditor.registerRenderer('timeline', TimelineEditor, null);
PropsEditor.registerRenderer('pow-damp-preset', PowDampPresetEditor, null);
PropsEditor.registerRenderer('rect', RectEditor, null);
PropsEditor.registerRenderer('spine-sequence', SpineSequencesEditor, null);
</file>

<file path="src/editor/ui/props-editor/props-editors/array-editable-property.ts">
import type { ComponentChild } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import PropsEditor from 'thing-editor/src/editor/ui/props-editor/props-editor';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';

const arrayProps = { className: 'array-prop' };
const arrayItemProps = { className: 'array-prop-item' };

interface ArrayEditablePropertyState {
	toggled?: boolean;
	filter?: string;
}

export default class ArrayEditableProperty extends Component<EditablePropertyEditorProps, ArrayEditablePropertyState> {

	onChange(newArray: any[]) {
		this.props.onChange(newArray);
	}

	render(): ComponentChild {
		const field = this.props.field;
		let arrayValue = this.props.value;
		if (arrayValue && !Array.isArray(arrayValue)) {
			arrayValue = [arrayValue];
		}
		if (arrayValue.length === 0) {
			arrayValue = [field.defaultArrayItemValue || PropsEditor.getDefaultForType(field)];
		}

		const canRemoveItem = field.canBeEmpty !== false || arrayValue.length > 1;

		return R.div(
			arrayProps,
			arrayValue.map((value: any, i: number) => {
				return R.div(arrayItemProps, h(field.renderer, {
					value,
					onChange: (itemValue: any) => {
						if (itemValue && itemValue.target) {
							itemValue = itemValue.target.value;
						}
						const newArray = arrayValue.slice();
						newArray[i] = itemValue;
						this.onChange(newArray);
					},
					onBlur: this.props.onBlur,
					field,
					disabled: this.props.disabled
				}), R.btn('×', () => {
					const newArray = arrayValue.slice();
					newArray.splice(i, 1);
					this.onChange(newArray);
				}, 'remove item', 'array-prop-item-remove-btn', undefined, !canRemoveItem));
			}),
			R.btn('+', (ev) => {
				const newArray = arrayValue.slice();
				newArray.push(field.defaultArrayItemValue || PropsEditor.getDefaultForType(field));
				this.onChange(newArray);
				setTimeout(() => {
					const allInputs = (ev.target as HTMLDivElement).closest('.array-prop')!.querySelectorAll('input');
					allInputs[allInputs?.length - 1]?.focus();
				}, 10);
			}, 'Add item', 'add-item-button')
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/boolean-editor.ts">
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import game from 'thing-editor/src/engine/game';

const BooleanEditor = (props: EditablePropertyEditorProps) => {
	return R.input({
		onChange: (ev: InputEvent) => {
			props.onChange((ev.target as HTMLInputElement).checked);
			game.editor.history.scheduleHistorySave();
		}, disabled: props.disabled,
		className: 'checkbox clickable',
		type: 'checkbox',
		checked: props.value || false
	});
};

export default BooleanEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/btn-editor.ts">
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import game from 'thing-editor/src/engine/game';

const BtnProperty = (props: EditablePropertyEditorProps) => {
	const field = props.field;

	return R.btn(field.name, () => {
		game.editor.selection.some(field.onClick!);
	}, field.title, field.className, field.hotkey);
};

export default BtnProperty;
</file>

<file path="src/editor/ui/props-editor/props-editors/call-back-editor.ts">
import type { DataPathEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-editors/data-path-editor';
import DataPathEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/data-path-editor';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import { findMethodDecorator } from 'thing-editor/src/engine/utils/get-value-by-path';


export default class CallbackEditor extends DataPathEditor {

	constructor(props: DataPathEditorProps) {
		super(props);
		this.itIsCallbackEditor = true;
	}

	cleanupPath(path: string): string {
		return path ? path.split(',')[0] : '';
	}

	isItTargetValue(val: any) {
		assert(val, 'empty value selected in callback chooser. Field filter need improvements: ');

		let type = typeof val;
		return (type === 'function') && (!CallbackEditor.isFunctionIsClass(val));
	}

	finalValueChoosed(_path: string[], val: any, parent: any) {
		let path = _path.join('.');

		let helper = (typeof val === 'function') && findMethodDecorator('___EDITOR_callbackParameterChooserFunction', parent, val);
		if (helper) {
			helper(parent).then((params: any[] | any) => {
				if (!params) {
					return;
				}
				if (!Array.isArray(params)) {
					params = [params];
				}
				params = params.map((p: any) => {
					if (typeof p === 'number') {
						return p.toString();
					}
					return p;
				});

				for (let p of params) {
					assert((p.indexOf(',') < 0), 'parameter chooser returned parameter containing wrong symbol (, or `)');
				}
				params = params.join(',');
				if (params) {
					this.applyFinalPath(path + ',' + params);
				}
			});
		} else {
			if ((typeof (val) === 'function') && (val.length > 0)) {
				path += ',';
				game.editor.ui.propsEditor.selectField(this.props.field ? this.props.field.name : '.keyframe-callback-editor', true);
			}
			this.applyFinalPath(path);
		}
	}

	get chooseButtonTip() {
		return 'Choose call-back function';
	}

	isFieldGoodForCallbackChoose(fieldName: string, object: KeyedObject, val: SelectableProperty, isChild = false) {
		if (!super.isFieldGoodForCallbackChoose(fieldName, object, val, isChild)) {
			return false;
		}

		if (typeof val === 'undefined') {
			val = object[fieldName];
		}
		if (!val) {
			return false;
		}
		let type = typeof val;
		return (type === 'object' || type === 'function') && !val.___EDITOR_isHiddenForCallbackChooser;
	}

}
</file>

<file path="src/editor/ui/props-editor/props-editors/color-editor.ts">
import { Component, h, render } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import game from 'thing-editor/src/engine/game';

let pickerContainer: undefined | HTMLDivElement;

let sliderShown = false;
const hide = () => {
	if (sliderShown) {
		render(R.fragment(), pickerContainer!);
		sliderShown = false;
	}
};

class ColorEditor extends Component<EditablePropertyEditorProps> {

	componentWillUnmount(): void {
		if (sliderShown) {
			hide();
		}
	}

	render () {
		let val = this.props.value || 0;

		return R.div({
			className: 'color-input',
		},
		R.div({
			className: 'clickable color-input-eyedropper',
			onMouseUp: (ev:MouseEvent) => {
				if (ev.which === 1) {

					const eyeDropper = new (window as any).EyeDropper();
					eyeDropper.open().then((color: any) => {
						const newVal = parseInt(color.sRGBHex.replace('#', ''), 16);
						if (newVal !== val) {
							this.props.onChange(newVal);
							game.editor.history.scheduleHistorySave();
						}
					}).catch((_er:any) => undefined);
				}
			},
		}, R.icon('eyedropper')
		),
		R.span({
			disabled: true,
			className: 'clickable color-input-sample',
			onMouseDown: (ev: PointerEvent) => {
				import('./color-slider').then((ColorSlider) => {

					if (!pickerContainer) {
						pickerContainer = window.document.createElement('div');
						pickerContainer.id = 'color-picker-container';
						window.document.body.appendChild(pickerContainer);
					}
					sliderShown = true;
					render(h(ColorSlider.default, {
						color: val,
						x: ev.clientX + 20,
						y: ev.clientY - 200,
						hide,
						onChange: (newVal:number) => {
							this.props.onChange(newVal);
						}
					}
					), pickerContainer);
				});
			},
			style: { backgroundColor: '#' + val.toString(16).padStart(6, '0')}
		})
		);
	}
}

export default ColorEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/color-slider.ts">
import { Color } from 'pixi.js';
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import game from 'thing-editor/src/engine/game';
import NumberEditor from './number-editor';

interface ColorSliderProps extends ClassAttributes<ColorSlider> {
	color: number;
	x: number;
	y: number;
	hide: () => void;
	onChange: (val: number) => void;
}

interface ColorSliderState {
	color: Color;
}

let lastHue = 0;
let lastSaturation = 0;
let hexString = 'ffffff';

const colorFromHSL = (hue: number, saturation: number, light: number) => {
	return new Color('hsl(' + (hue * 360) + ' ' + (saturation * 100) + '% ' + (light * 100) + '%)');
};

let startX = 0;
let startY = 0;

export default class ColorSlider extends Component<ColorSliderProps, ColorSliderState> {

	constructor(props: ColorSliderProps) {
		super(props);
		const color = new Color(props.color);
		this.state = { color };
		this.applyHexEditor(color);
		this.onSLPick = this.onSLPick.bind(this);
		this.onHuePick = this.onHuePick.bind(this);
	}

	applyHexEditor(color:Color) {
		hexString = color.toHex().replace('#', '').toLowerCase();
	}

	onSLPick(ev:PointerEvent) {
		if (!ev.buttons) {
			window.removeEventListener('pointermove', this.onSLPick);
			return;
		}

		const saturation = Math.max(0, Math.min(1, (ev.clientX - startX) / 255));
		const light = 1 - Math.max(0, Math.min(1, ((ev.clientY - startY) / 255)));
		this.setSL(saturation, light / (1 + saturation));
	}

	onHuePick(ev:PointerEvent) {
		 if (!ev.buttons) {
			window.removeEventListener('pointermove', this.onHuePick);
			return;
		}
		this.setHue((255.9 - (Math.max(0, Math.min(255.9, ev.clientY - startY)))) / 256);
	}

	setSL(saturation:number, light:number) {
		const hsl = this.toHsl();
		hsl[1] = saturation;
		hsl[2] = light;
		lastSaturation = saturation;
		this.fromHSL(...hsl);
	}

	setHue(hue:number) {
		const hsl = this.toHsl();
		hsl[0] = hue;
		lastHue = hue * 6;
		this.fromHSL(...hsl);
	}

	toHsl(): [h: number, s: number, l: number] {
		const r = this.state.color.red;
		const g = this.state.color.green;
		const b = this.state.color.blue;

		let max = Math.max(r, g, b);
		let min = Math.min(r, g, b);
		let d = max - min;
		let h = lastHue;
		if (d === 0) h = lastHue;
		else if (max === r) h = (g - b) / d % 6;
		else if (max === g) h = (b - r) / d + 2;
		else if (max === b) h = (r - g) / d + 4;
		let l = (min + max) / 2;
		let s = d === 0 ? lastSaturation : d / (1 - Math.abs(2 * l - 1));

		if (h < 0) {
			h += 6;
		}

		s = Math.min(s, 1.5 - l);


		lastHue = h;
		lastSaturation = s;

		return [h / 6, s, l];
	}

	fromHSL(h: number, s: number, l: number) {
		const color = colorFromHSL(h, s, l);
		this.setState({color});
		this.props.onChange(color.toNumber());
		this.applyHexEditor(color);
	}

	setColor(val: number, dontSetHexValue = false) {
		const color = new Color(val);
		this.setState({color});
		if (!dontSetHexValue) {
			this.applyHexEditor(color);
		}
		this.props.onChange(val);
	}

	accept() {
		this.props.hide();
		game.editor.history.scheduleHistorySave();
	}

	cancel() {
		if (this.props.color !== this.state.color.toNumber()) {
			this.props.onChange(this.props.color);
		}
		this.props.hide();
	}

	componentDidMount(): void {
		(window.document.querySelector('.color-slider #hex-color') as HTMLInputElement).select();
	}

	render(): ComponentChild {
		const colorNumber = this.state.color.toNumber();
		const hsl = this.toHsl();
		const hue = hsl[0];
		const saturation = hsl[1];
		const light = hsl[2];
		hsl[1] = 1;
		hsl[2] = 0.5;
		const color = colorFromHSL(...hsl);
		return R.div(null,
			R.div({className: 'modal-blackout', style: {opacity: 0}, onMouseDown: (ev:PointerEvent) => {
				if ((ev.target as HTMLDivElement).classList.contains('modal-blackout')) {
					this.accept();
				}
			}
			}),
			R.div({ className: 'color-slider', style: {
				left: Math.min(Math.max(0, this.props.x), window.document.body.clientWidth - 314),
				top: Math.min(Math.max(0, this.props.y), window.document.body.clientHeight - 500)
			} },
			R.div({
				style: {
					border: '1px solid #888888',
					marginBottom: 3,
					width: 80,
					height: 30
				}},
			R.div({
				style: {
					display: 'inline-block',
					width: 40,
					height: 30,
					background: this.state.color.toHex()
				}
			}),
			R.div({
				style: {
					display: 'inline-block',
					width: 40,
					height: 30,
					background: new Color(this.props.color).toHex()
				}
			})
			),
			R.div({
				className: 'color-slider-sl',
				onMouseDown: (ev:PointerEvent) => {
					if (ev.buttons === 1) {
						startX = ev.clientX - ev.layerX;
						startY = ev.clientY - ev.layerY;
						window.addEventListener('pointermove', this.onSLPick);
						this.onSLPick(ev);
					}
				},
				style: {
					background: 'linear-gradient(transparent 0%, #000000 100%), linear-gradient(to left, transparent 0%, #ffffff 100%),' + color.toRgbaString()
				}
			},
			R.div({className: 'color-slider-sl-point', style: {top: Math.min(255, Math.max(0, 255 - (light * (1 + saturation)) * 255)) - 3, left: Math.min(255, Math.max(0, saturation * 255)) - 3}})
			),
			R.div({
				className: 'color-slider-hue',
				onMouseDown: (ev:PointerEvent) => {
					if (ev.buttons === 1) {
						startX = ev.clientX - ev.layerX;
						startY = ev.clientY - ev.layerY;
						window.addEventListener('pointermove', this.onHuePick);
						this.onHuePick(ev);
					}
				}
			}, R.div({className: 'color-slider-hue-point', style: {top: 255 - (hue) * 255 - 3}})),
			R.div(null,
				'#', R.input({
					id: 'hex-color',
					onInput: (ev:InputEvent) => {
						hexString = (ev.target as HTMLInputElement).value.replace('#', '');
						let num = parseInt(hexString.substring(0, 6), 16);
						if (!isNaN(num)) {
							this.setColor(num, true);
						}
					},
					value: hexString
				}),
				R.span({
					className: 'clickable color-input-eyedropper',
					onMouseUp: (ev:MouseEvent) => {
						if (ev.which === 1) {
							const eyeDropper = new (window as any).EyeDropper();
							eyeDropper.open().then((color: any) => {
								const newVal = parseInt(color.sRGBHex.replace('#', ''), 16);
								if (newVal !== parseInt(hexString, 16)) {
									this.setColor(newVal);
								}
							}).catch((_er:any) => undefined);;
						}
					},
				}, R.icon('eyedropper')),
				R.br(),
				R.br(),
				'R: ', h(NumberEditor, {
					value: Math.floor(this.state.color.red * 255),
					min: 0,
					max: 255,
					onChange: (val) => {
						this.setColor((colorNumber & 0xFFFF) | (val << 16));
					}
				}),
				'G: ', h(NumberEditor, {
					value: Math.floor(this.state.color.green * 255),
					min: 0,
					max: 255,
					onChange: (val) => {
						this.setColor((colorNumber & 0xFF00FF) | (val << 8));
					}
				}),
				'B: ', h(NumberEditor, {
					value: Math.floor(this.state.color.blue * 255),
					min: 0,
					max: 255,
					onChange: (val) => {
						this.setColor((colorNumber & 0xFFFF00) | val);
					}
				})
			),
			R.br(),
			R.btn('Cancel', () => this.cancel(), undefined, undefined, {key: 'Escape'}),
			R.btn('Ok', () => this.accept(), undefined, 'main-btn', {key: 'Enter'}),

			)
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/data-path-editor.ts">
import { Container, DisplayObject } from 'pixi.js';
import type { ComponentChild } from 'preact';
import { Component, h, render } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import CallbackEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/call-back-editor';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import { getAllObjectRefsCount } from 'thing-editor/src/editor/utils/scene-all-validator';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import getValueByPath, { getLatestSceneNodeBypath } from 'thing-editor/src/engine/utils/get-value-by-path';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const fieldEditorWrapperProps = { className: 'field-editor-wrapper' };
const selectableSceneNodeProps = { className: 'selectable-scene-node' };
const functionTipProps = { className: 'path-editor-function-tip' };

const PROPERTY_ITEM_PROPS = {
	className: 'selectable-text path-choose-item',
	title: CTRL_READABLE + '+click to copy',
	onMouseDown: copyTextByClick,
	onClick: (ev:MouseEvent) => {
		 if (ev.ctrlKey || ev.metaKey) {
			sp(ev);
		}
	}
};

let initialized = false;

let chooserElement:HTMLDivElement;
const hideChooser = () => {
	render(R.fragment(), chooserElement);
};
const headerProps = {className: 'data-path-header'};
const smallHeaderProps = {className: 'data-path-small-header'};

let tipSyncInterval = 0;
const syncTip = () => {
	if (document.activeElement) {
		let bounds = document.activeElement.getBoundingClientRect();
		dataPathTipContainer.style.left = (bounds.x - 2) + 'px';
		dataPathTipContainer.style.top = (bounds.y - 27) + 'px';
	}
};

const startTipSync = (enabled: any = false) => {
	if (enabled) {
		if (!tipSyncInterval) {
			tipSyncInterval = window.setInterval(syncTip, 50);
		}
	} else {
		if (tipSyncInterval) {
			clearInterval(tipSyncInterval);
			tipSyncInterval = 0;
		}
	}
};

const dataPathTipContainer = window.document.createElement('div');
dataPathTipContainer.id = 'data-path-tip-container';
window.document.body.appendChild(dataPathTipContainer);

interface DataPathEditorProps extends Omit<EditablePropertyEditorProps, 'field'> {
	field?: EditablePropertyDesc;
	onCancel?: () => void;
	title: string;
}

interface DataPathEditorState {
	focus: boolean;

}

interface DataPathSelectItem {
	order?: number;
	noFilter?: boolean;
	name: ComponentChild;
	pureName?: string;
	nameOfChild?: string;
	refusedBecause?: string;
}

export default class DataPathEditor extends Component<DataPathEditorProps, DataPathEditorState> {

	itIsCallbackEditor = false;

	constructor(props: DataPathEditorProps) {
		super(props);
		this.onEditClicked = this.onEditClicked.bind(this);
		this.onBreakpointClick = this.onBreakpointClick.bind(this);
		this.refreshTip = this.refreshTip.bind(this);
		this.onGotoTargetClick = this.onGotoTargetClick.bind(this);
		this.onFocus = this.onFocus.bind(this);
		this.onBlur = this.onBlur.bind(this);
	}

	onFocus() {
		this.setState({ focus: true });
	}

	onBlur() {
		this.setState({ focus: false });
		this.hideParamsTip();
	}

	static isFunctionIsClass(f: () => any) {
		return f.toString().startsWith('class ');
	}

	static choosePath(title: string, currentPath = ''):Promise<string> {
		return new Promise((resolve:(ret: string)=> void) => {
			if (!chooserElement) {
				chooserElement = window.document.createElement('div');
				chooserElement.classList.add('path-chooser-layer');
				window.document.body.appendChild(chooserElement);
			}
			render(h(DataPathEditor, {
				title: '',
				field: {
					name: title
				} as EditablePropertyDesc,
				ref: (ref:ComponentChild | null) => {
					if (ref) {
						(ref as DataPathEditor).startChoosing();
					}
				},
				value: currentPath,
				onChange: (value:string) => {
					resolve(value);
					hideChooser();
				},
				onCancel: () => {
					hideChooser();
				}
			}), chooserElement);
		});
	}

	onGotoTargetClick() {

		if (this.props.value && this.props.value.startsWith('Sound.play')) {
			callByPath(this.props.value, game.editor.selection[0]);
			return;
		}

		game.currentScene._refreshAllObjectRefs();
		let node = getLatestSceneNodeBypath(this.props.value, game.editor.selection[0]);
		if (!node) {
			return;
		}
		if (node.getRootContainer() !== game.currentContainer) {
			PrefabEditor.exitPrefabEdit();
		}
		game.editor.ui.sceneTree.selectInTree(node);
	}

	onBreakpointClick() {
		let node = game.editor.selection[0];
		node.__nodeExtendData.__pathBreakpoint = this.props.value || (node as KeyedObject)[this.props.field!.name];
	}

	onEditClicked() {
		if (!this.props.disabled) {
			if (!initialized) {
				initSelectableProps();
				initialized = true;
			}
			game.currentScene._refreshAllObjectRefs();

			this.startChoosing();
		}
	}

	startChoosing() {
		game.editor.currentPathChoosingField = this.props.field!;

		let path: string[];
		let parent: KeyedObject = game;
		_rootParent = parent;
		if (this.props.value) {
			path = this.cleanupPath(this.props.value as string).split('.');
			parentsPath = [];
			let pathI;
			for (pathI = 0; (pathI < path.length - 1); pathI++) {
				let itemName = path[pathI];
				let p: KeyedObject;
				if ((itemName === 'this') && (pathI === 0)) {
					p = game.editor.selection[0];
				} else if (itemName.startsWith('#')) {
					p = (parent as Container).getChildByName(itemName.substr(1)) as KeyedObject;
				} else {
					p = parent[itemName];
				}
				if (p) {
					parentsPath.push(parent);
					parent = p;
				} else {
					break;
				}
			}
			path.length = pathI;
		} else {
			parentsPath = [parent];
			path = [];
		}

		this.chooseProperty(parent, path);
	}

	cleanupPath(path: string): string {
		return path;
	}

	isItTargetValue(val: any) {
		if (this.props.field!.isValueValid && !this.props.field!.isValueValid(val)) {
			return false;
		}

		if (!val) return true;

		let type = typeof val;

		return ((type !== 'object') && (type !== 'function' || !CallbackEditor.isFunctionIsClass(val)));
	}

	finalValueChoosed(path: string[], _val: any, _parent: any) {
		this.applyFinalPath(path.join('.'));
	}

	applyFinalPath(path: string) {
		this.props.onChange(path);
		game.editor.history.scheduleHistorySave();
	}

	isFieldGoodForCallbackChoose(fieldName: string, object: KeyedObject, val?: SelectableProperty, isChild = false) {
		EDITOR_FLAGS.rememberTryTime();
		try {
			if ((object as Container).__EDITOR_filterPropsSelection?.(fieldName)) {
				EDITOR_FLAGS.checkTryTime();
				return false;
			}
			if (fieldName.startsWith('_')) {
				EDITOR_FLAGS.checkTryTime();
				return false;
			}
			if (typeof val === 'undefined') {
				val = object[fieldName];
			}
			if (!val) {
				EDITOR_FLAGS.checkTryTime();
				return true;
			}
			let type = typeof val;
			if (type === 'object' || (type === 'function')) {

				if (isChild && val instanceof DisplayObject && val.__nodeExtendData.hidden) {
					EDITOR_FLAGS.checkTryTime();
					return false;
				}
				EDITOR_FLAGS.checkTryTime();
				return !(val as SelectableProperty).___EDITOR_isHiddenForChooser &&
					(this.itIsCallbackEditor || !(val as SelectableProperty).___EDITOR_isHiddenForDataChooser);
			}
			EDITOR_FLAGS.checkTryTime();
			return true;
		} catch (_er) { /* empty */ }
		EDITOR_FLAGS.checkTryTime();
	}

	get chooseButtonTip() {
		return 'Choose data source';
	}

	interval = 0;

	componentDidMount(): void {
		this.interval = window.setInterval(this.refreshTip, 50);
	}

	componentWillUnmount(): void {
		this.hideParamsTip();
		clearInterval(this.interval);
	}

	refreshTip() {
		if (!this.state || !this.state.focus || !game.editor.selection.length || !game.currentScene) {
			return;
		}
		let val = this.props.value;
		if (val) {
			game.currentScene._refreshAllObjectRefs();
			let f;
			try {
				Lib.__outdatedReferencesDetectionDisabled++;
				f = getValueByPath(val, game.editor.selection[0], true);
				Lib.__outdatedReferencesDetectionDisabled--;
			} catch (_er) { }

			if (typeof f === 'function') {
				let paramsView: ComponentChild;
				let firstLine = f.toString().split('\n').shift();
				let params: string[] = f.___EDITOR_argumentsTip || firstLine.split('(').pop().split(')').shift().split(', ').filter((p: string) => p);
				if (!params.length) {
					paramsView = 'no parameters';
				} else {
					let paramsW: Array<ComponentChild> = [];

					let cursorPos = ((this.base as HTMLDivElement).querySelector('input') as HTMLInputElement).selectionStart || 0;
					let selectedParamIndex = -1;
					let paramsStartVal = val.indexOf(',');
					if (paramsStartVal > 0 && cursorPos > paramsStartVal) {
						selectedParamIndex = 0;
						let leftPart = val.substr(0, cursorPos);
						let a = leftPart.split(',');
						if (a.length > 1) {
							selectedParamIndex = a.length - 2;
						}
					}

					let paramIndex = 0;
					for (let param of params) {
						if (param) {
							if (paramsW.length) {
								paramsW.push(', ');
							}
							if (paramIndex === selectedParamIndex) {
								paramsW.push(R.b(null, param));
							} else {
								paramsW.push(param);
							}
							paramIndex++;
						}
					}
					paramsView = paramsW;
				}
				render(R.span(functionTipProps, paramsView), dataPathTipContainer);
				startTipSync(true);
				return;
			}
		}
		this.hideParamsTip();
	}

	hideParamsTip() {
		render(undefined, dataPathTipContainer);
		startTipSync();
	}

	render() {

		let val = this.props.value;

		let breakpointBtn;
		if (val && !game.__EDITOR_mode) {
			breakpointBtn = R.btn('■', this.onBreakpointClick, 'Breakpoint', 'tool-btn breakpoint-btn');
		}
		let chooseBtn;
		if (game.__EDITOR_mode) {
			chooseBtn = R.btn('...', this.onEditClicked, this.chooseButtonTip, 'tool-btn');
		}

		let gotoButton;
		if (val) {
			gotoButton = R.btn('➥', this.onGotoTargetClick, 'Find target object', 'tool-btn');
		}

		return R.div(fieldEditorWrapperProps,
			R.input({
				className: 'props-editor-callback',
				onInput: this.props.onChange,
				disabled: this.props.disabled,
				title: val,
				value: val || '',
				onFocus: this.onFocus,
				onBlur: this.onBlur
			}),
			breakpointBtn,
			chooseBtn,
			gotoButton
		);
	}

	chooseProperty(parent: KeyedObject, path: string[]) {

		let addedNames: Set<string> = new Set();

		let items: DataPathSelectItem[] = [];

		const addSceneNodeIfValid = (o: Container, pureName: string, isChild = false, order = 100000) => {
			if (o && (o instanceof DisplayObject) && this.isFieldGoodForCallbackChoose(pureName, parent, o, isChild)) {
				let item: DataPathSelectItem = {
					order,
					pureName,
					name: R.fragment(
						R.b(null, pureName + ' '),
						R.div(selectableSceneNodeProps, R.sceneNode(o))
					)
				};

				if (isChild) {
					items.forEach(i => {
						if (i.nameOfChild === pureName) {
							item.refusedBecause = i.refusedBecause = 'Refused because more that one object with that name present in container';
						}
					});
					item.nameOfChild = pureName;
				} else {
					item.pureName = pureName;
				}

				if (parent === game.currentScene.all) {
					let refuse = getAllObjectRefsCount((o as Container).name!);
					if (refuse) {
						item.refusedBecause = refuse;
					}
				}

				items.push(item);
				addedNames.add(pureName);
				return true;
			}
		};


		if (path.length === 0) {
			addSceneNodeIfValid(game.editor.selection[0], 'this', false, 1000000);
		}


		//ignore names globally
		addedNames.add('constructor');
		addedNames.add('prototype');
		addedNames.add('tempDisplayObjectParent');
		if (parent instanceof DisplayObject) {
			addedNames.add('init');
			addedNames.add('update');
			addedNames.add('onRemove');
		}
		let topPathElement = path[path.length - 1];
		if (topPathElement && topPathElement.startsWith('#')) {
			addedNames.add('parent'); // prevent to go from parent to child and back
		}

		if (path.length > 0) {
			items.push(BACK_ITEM);
		}


		if (Object.prototype.hasOwnProperty.call(parent, 'parent') && !addedNames.hasOwnProperty('parent')) {
			addSceneNodeIfValid(parent.parent, 'parent');
		}

		if (Object.prototype.hasOwnProperty.call(parent, 'children') && Array.isArray(parent.children)) {
			for (let child of parent.children) {
				if (child.name) {
					addSceneNodeIfValid(child, child.name, true);
				}
			}
		}

		const addIfGood = (name: string) => {
			if (!addedNames.has(name)) {
				Lib.__outdatedReferencesDetectionDisabled++;
				if (this.isFieldGoodForCallbackChoose(name, parent)) {
					if (!addSceneNodeIfValid(parent[name], name)) {
						let order = 0;
						let isBold;
						let refusedBecause:string|undefined;
						EDITOR_FLAGS.rememberTryTime();
						try {
							let val = parent[name];
							refusedBecause = (val as SelectableProperty).___EDITOR_rejectionReason;
							order = val.___EDITOR_ChooserOrder || 0;
							if (val.___EDITOR_isGoodForChooser || (this.itIsCallbackEditor && val.___EDITOR_isGoodForCallbackChooser) || val === game.data) {
								order += 100;
								isBold = true;
							}
						} catch (_er) { /* empty */ }
						EDITOR_FLAGS.checkTryTime();
						if (!isBold) {
							items.push({ name, refusedBecause });
						} else {
							items.push({ pureName: name, name: R.b(null, name), order, refusedBecause});
						}

						addedNames.add(name);
					}
				}
				Lib.__outdatedReferencesDetectionDisabled--;
			}
		};

		if (parent.constructor && !this.itIsCallbackEditor) {
			let props = (parent.constructor as SourceMappedConstructor).__editableProps;
			if (props && Array.isArray(props)) {
				for (let p of props as EditablePropertyDesc[]) {
					if (!p.notSerializable && !p.name.startsWith('_')) {
						let name = p.name;
						items.push({ pureName: name, name: R.b(null, name), order: 10000 });
						addedNames.add(name);
					}
				}
			}
		}


		let type = typeof parent;

		if (type === 'object' || type === 'function') {
			let props = enumProps(parent);
			if (parent !== _rootParent) {
				props.sort();
			}
			let a = props.slice();
			props = [];
			a = a.filter((p) => {
				if (!p.startsWith('_')) {
					props.push(p);
					return false;
				}
				return true;
			});
			a = a.filter((p) => {
				if (!p.startsWith('__')) {
					props.push(p);
					return false;
				}
				return true;
			});
			props = props.concat(a);

			for (let name of props) {
				if (type === 'function') {
					if (name === 'length' || name === 'name') {
						continue;
					}
				}
				addIfGood(name);
			}
		}

		let acceptNowBtn;
		if (!this.props.field || !this.props.field.isValueValid || this.props.field.isValueValid(parent)) {
			acceptNowBtn = R.btn('✔', () => {
				this.finalValueChoosed(path, parent, parentsPath[parentsPath.length - 1]);
				game.editor.ui.modal.hideModal();
			}, 'Use this path', 'main-btn');
		}
		items.sort((a, b) => {
			return (b.order || 0) - (a.order || 0);
		});

		items.forEach(i => {
			if (!i.pureName) {
				i.pureName = i.name as string;
			}
			i.name = R.span(PROPERTY_ITEM_PROPS, i.name);
		});

		game.editor.ui.modal.showListChoose(
			R.span(headerProps,
				R.span(smallHeaderProps, 'Path for ' + (this.props.title || this.props.field!.name) + ': '), path.join('.') + '.',
				R.br(),
				(parent instanceof DisplayObject) ? R.sceneNode(parent as Container) : undefined,
				acceptNowBtn
			),
			items, false, false, undefined, false, this.props.onCancel)
			.then((selected?: DataPathSelectItem) => {
				if (selected) {
					let val;
					if (selected === BACK_ITEM) {
						path.pop();
						val = parentsPath.pop();
					} else if (selected.nameOfChild) {
						path.push('#' + selected.nameOfChild);
						parentsPath.push(parent);
						val = parent.getChildByName(selected.nameOfChild);
					} else {
						let name = (selected.pureName || selected.name) as string;
						path.push(name);
						parentsPath.push(parent);
						if (name === 'this') {
							val = game.editor.selection[0];
						} else {
							val = parent[name];
						}
					}

					if (this.isItTargetValue(val)) {
						this.finalValueChoosed(path, val, parent);
					} else {
						this.chooseProperty(val, path);
					}
				}
			});
	}
}

function initSelectableProps() {
	let tmpSprite = Lib._loadClassInstanceById('Sprite') as KeyedObject;
	let spriteProps = enumProps(tmpSprite);
	for (let p of spriteProps) {
		let v = tmpSprite[p];
		if ((typeof v) === 'function') {
			hidePropertyFromEnumerationForChooser(v);
		}
	}
	unhidePropertyFromEnumerationForChooser(tmpSprite.remove);
	unhidePropertyFromEnumerationForChooser(tmpSprite.gotoLabelRecursive);
}

const BACK_ITEM = { name: '↰', noFilter: true, noAutoSelect: true, order: 10000000 };
let parentsPath: KeyedObject[];

const hiddenProps = new WeakMap();

const hidePropertyFromEnumerationForChooser = (p: any) => {
	hiddenProps.set(p, true);
};
const unhidePropertyFromEnumerationForChooser = (p: any) => {
	hiddenProps.delete(p);
};

let enumeratedProps: string[];

const enumSub = (o: KeyedObject) => {
	let op = Object.getOwnPropertyNames(o);
	for (let name of op) {
		EDITOR_FLAGS.rememberTryTime();
		try {
			if (hiddenProps.has(o[name])) {
				EDITOR_FLAGS.checkTryTime();
				continue;
			}
		} catch (_er) { /* empty */ }
		EDITOR_FLAGS.checkTryTime();
		if (enumeratedProps.indexOf(name) === -1) {
			enumeratedProps.push(name);
		}
	}
};

let _rootParent: KeyedObject;
const referenceContainer = new Container() as KeyedObject;

function enumProps(o: KeyedObject) {
	Lib.__outdatedReferencesDetectionDisabled++;
	enumeratedProps = [];
	enumSub(o);
	let cc = o.constructor;
	for (; cc && (cc !== Function) && (cc !== Object);

		(cc = (cc as any).__proto__)) {

		let p = cc.prototype;
		if (p) {
			enumSub(p);
		}
	}
	Lib.__outdatedReferencesDetectionDisabled--;

	if (o instanceof Container) {
		enumeratedProps = enumeratedProps.filter((prop) => {
			if (referenceContainer[prop] !== null) {
				return true;
			}
		});

	}
	return enumeratedProps;
}


export type { DataPathEditorProps, DataPathEditorState };
</file>

<file path="src/editor/ui/props-editor/props-editors/image-editor.ts">
import type { ComponentChild } from 'preact';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const imageEditorProps = { className: 'asset-editor' };

let assetNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy image`s name',
	onMouseDown: copyTextByClick
};

const ImageEditor = (props: EditablePropertyEditorProps): ComponentChild => {
	const file = fs.getFileByAssetName(props.value, AssetType.IMAGE);
	return R.div(imageEditorProps,
		R.btn(props.value ? R.span(assetNameProps, props.value) : '. . .', () => {
			game.editor.chooseImage('Select "' + props.field.name + '" image', props.value).then((selectedImage) => {
				if (selectedImage) {
					props.onChange(selectedImage);
					game.editor.history.scheduleHistorySave();
				}
			});
		}, props.value, (!props.value || file) ? 'choose-asset-button' : 'choose-asset-button danger'),
		props.value ? R.imageIcon(file) : undefined,
		props.value ? R.btn(R.icon('reject'), (ev: PointerEvent) => {
			showContextMenu([
				{
					name: R.fragment(R.icon('reject'), 'Clear \'' + props.field.name + '\''),
					onClick: () => {
						props.onChange(props.field.canBeEmpty === false ? props.field.default : null);
					}
				},
				{
					name: 'Cancel',
					onClick: () => { } // eslint-disable-line @typescript-eslint/no-empty-function
				}
			], ev);
		}, 'Clear', 'tool-button') : undefined
	);
};

ImageEditor.parser = (val: string) => {
	return val || null;
};

ImageEditor.contextMenuInjection = (contextMenu: ContextMenuItem[], _field:EditablePropertyDesc, _clickedValue:any, _value:any) => {
	if (_clickedValue) {
		contextMenu.splice(contextMenu.indexOf(null) + 1, 0, {
			name: 'Reveal In Explorer',
			onClick: () => {
				const file = fs.getFileByAssetName(_clickedValue, AssetType.IMAGE);
				if (file) {
					fs.showFile(file.fileName);
				}
			}
		});
	}
};

export default ImageEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/l10n-editor.ts">
import type { ComponentChild } from 'preact';
import { h } from 'preact';
import LanguageView from 'thing-editor/src/editor/ui/language-view';
import SelectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';

const L10nEditor = (props: EditablePropertyEditorProps): ComponentChild => {
	return h(SelectEditor, {
		value: props.value,
		select: LanguageView.selectableList,
		onChange: (val: string) => {
			props.onChange(val);
		},
		field: props.field
	});
};

L10nEditor.parser = (val: string) => {
	return val || null;
};

export default L10nEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/number-editor.ts">
import type { Container } from 'pixi.js';
import type { ComponentChild } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import StatusBar from 'thing-editor/src/editor/ui/status-bar';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const numberEditorProps = { className: 'number-input' };

let draggingElement: NumberEditor | undefined;
let preventClickBecauseOfDragging = false;
let downedArrow: HTMLElement | null;

function clearDownedArrayRef() {
	downedArrow = null;
}
function onMouseUp() {
	if (draggingElement) {
		document.exitPointerLock();
		draggingElement = undefined;
	}
	window.setTimeout(clearDownedArrayRef, 1);
}

document.addEventListener('mouseup', onMouseUp);

document.addEventListener('mousemove', (ev) => {
	if (!draggingElement) return;

	StatusBar.addStatus('Hold ' + CTRL_READABLE + ' - to fast scroll.', 'number-editor');

	let d = -ev.movementY;
	if (d !== 0) {
		preventClickBecauseOfDragging = true;
		d = d * (draggingElement.step);
		draggingElement.deltaValue(d, (ev.ctrlKey || ev.metaKey));
	}
});

interface NumberEditorProps extends Omit<EditablePropertyEditorProps, 'field'> {
	field?: EditablePropertyDesc;
	step?: number;
	max?: number;
	min?: number;
}

interface NumberEditorState {
	value?: number;
	o?: Container;
}

const onArrowOver = () => {
	StatusBar.addStatus('drag arrow up and down - to delta value', 'number-editor');

};
const onArrowOut = () => {
	StatusBar.removeStatus('number-editor');
};

class NumberEditor extends Component<NumberEditorProps, NumberEditorState> {

	btnUp: ComponentChild;
	btnDown: ComponentChild;
	tmpVal?: number;
	rawVal?: string;

	constructor(props: NumberEditorProps) {
		super(props);
		this.state = { value: props.value };
		this.onChange = this.onChange.bind(this);
		this.onInput = this.onInput.bind(this);
		this.onMouseDown = this.onMouseDown.bind(this);
		this.onKeyDown = this.onKeyDown.bind(this);
		this.onUpClick = this.onUpClick.bind(this);
		this.onDownClick = this.onDownClick.bind(this);
		this.onBlur = this.onBlur.bind(this);
		this.btnUp = R.span({ className: 'number-input-btn number-input-btn-up', onMouseUp: this.onUpClick, onMouseDown: this.onMouseDown, onMouseOver: onArrowOver, onMouseOut: onArrowOut }, '▲');
		this.btnDown = R.span({ className: 'number-input-btn number-input-btn-down', onMouseUp: this.onDownClick, onMouseDown: this.onMouseDown, onMouseOver: onArrowOver, onMouseOut: onArrowOut }, '▼');
	}

	componentWillUnmount() {
		onMouseUp();
	}

	onBlur() {
		if (this.state) {
			delete this.tmpVal;
			delete this.rawVal;
			this.forceUpdate();
		}
	}

	get step() {
		if (this.props.field) {
			return this.props.field.step || 1;
		}
		return this.props.step || 1;
	}

	get max(): number {
		if (this.props.field && !isNaN(this.props.field.max as number)) {
			return this.props.field.max as number;
		}
		return !isNaN(this.props.max as number) ? this.props.max as number : Number.POSITIVE_INFINITY;
	}

	get min(): number {
		if (this.props.field && !isNaN(this.props.field.min as number)) {
			return this.props.field.min as number;
		}
		return !isNaN(this.props.min as number) ? this.props.min as number : Number.NEGATIVE_INFINITY;
	}

	onUpClick(ev: PointerEvent) {
		if (!preventClickBecauseOfDragging && downedArrow === ev.target) {
			this.deltaValue(this.step, (ev.ctrlKey || ev.metaKey));
		}
	}

	onDownClick(ev: PointerEvent) {
		if (!preventClickBecauseOfDragging && downedArrow === ev.target) {
			this.deltaValue(-this.step, (ev.ctrlKey || ev.metaKey));
		}
	}

	onInput(ev: InputEvent) {
		const rawValue = (ev.target as HTMLInputElement).value;
		this.onChange(ev, true);
		this.rawVal = rawValue;

	}

	onChange(ev: InputEvent, forceFormat = false) {
		forceFormat = (forceFormat === true);
		let props = this.props;
		if (forceFormat) {
			this.tmpVal = undefined;
		} else {
			this.tmpVal = parseFloat((ev.target as HTMLInputElement).value);
		}

		let targetValue = (ev.target as HTMLInputElement).value;
		try {
			targetValue = eval((ev.target as HTMLInputElement).value);
		} catch (_er) { }

		let val = (props.field && props.field.basis) ? parseInt((ev.target as HTMLInputElement).value, props.field.basis) : parseFloat(targetValue);
		if (isNaN(val) && !forceFormat) {
			return;
		}
		if (!val) {
			val = 0;
		}
		props.onChange(this.cropVal(val));
	}


	onMouseDown(ev: PointerEvent) {
		(ev.target as HTMLInputElement).requestPointerLock();
		draggingElement = this;
		downedArrow = ev.target as HTMLInputElement;
		preventClickBecauseOfDragging = false;
	}

	onKeyDown(ev: KeyboardEvent) {
		switch (ev.keyCode) {
		case 38:
			this.deltaValue(this.step, (ev.ctrlKey || ev.metaKey));
			sp(ev);
			break;
		case 40:
			this.deltaValue(-this.step, (ev.ctrlKey || ev.metaKey));
			sp(ev);
			break;
		}
	}

	deltaValue(d: number, x10 = false) {
		if (x10) {
			d *= 10;
		}
		let step = this.step;
		let val = this.state.value as number;
		let croppedVal = this.cropVal(val + d);
		croppedVal = Math.round(croppedVal / step) * step;
		d = croppedVal - val;
		this.tmpVal = undefined;
		this.rawVal = undefined;
		this.setState({ value: croppedVal });
		this.props.onChange(croppedVal, true, d);
	}

	cropVal(val: number) {
		val = Math.max(val, this.min);
		val = Math.min(val, this.max);
		return val;
	}

	componentWillReceiveProps(props: NumberEditorProps, state: NumberEditorState) {
		if (!state) {
			state = {};
		}
		state.value = props.value;
		if (state.o !== game.editor.selection[0]) {
			this.tmpVal = undefined;
		}
		this.setState({ o: game.editor.selection[0], value: props.value });

	}

	render() {
		let props = this.props;
		let val: number = ((typeof this.tmpVal !== 'undefined') ? this.tmpVal : this.state.value) as number;
		if (props.field && props.field.notSerializable && (typeof val === 'undefined')) {
			val = props.field.default as number;
		}
		return R.span(numberEditorProps,
			R.input({
				className: 'number-input',
				suspendOnChangeWarning: true,
				onBlur: this.onBlur,
				onChange: this.onChange,
				onInput: this.onInput,
				disabled: props.disabled,
				type: 'text',
				value: this.rawVal || ((props.field && props.field.basis) ? val.toString(props.field.basis) : val),
				onKeyDown: this.onKeyDown
			}),
			props.disabled ? undefined : this.btnUp,
			props.disabled ? undefined : this.btnDown
		);
	}
}

export default NumberEditor;

export type { NumberEditorProps };
</file>

<file path="src/editor/ui/props-editor/props-editors/pow-damp-preset-selector.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes } from 'preact';
import { Component, h } from 'preact';
import type { SelectEditorItem } from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import SelectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import game from 'thing-editor/src/engine/game';

interface PowDampPreset {
	p: number;
	d: number;
}


interface PowDampPresetSelectorProps extends ClassAttributes<PowDampPresetSelector> {
	onPresetSelected: (pow: number, damp: number) => void;
	pow: number;
	damp: number;
}


export default class PowDampPresetSelector extends Component<PowDampPresetSelectorProps> {
	constructor(props: PowDampPresetSelectorProps) {
		super(props);

		this.onSelect = this.onSelect.bind(this);
	}

	onSelect(selected: PowDampPreset) {
		if (selected.p) {
			this.props.onPresetSelected(selected.p, selected.d);
		}
	}

	getPow() {
		return this.props.pow;
	}

	getDamp() {
		return this.props.damp;
	}

	render() {
		let pow = this.getPow();
		let damp = this.getDamp();
		let presetSelectedValue = presets.find((p) => {
			return pow === p.value.p && damp === p.value.d;
		}) || presets[0];

		return h(SelectEditor, { value: presetSelectedValue.value, noCopyValue: true, onChange: this.onSelect, select: presets });
	}
}

const presets: SelectEditorItem<PowDampPreset>[] = [
	{ name: 'None', value: {} as PowDampPreset },
	{
		name: 'Alive     1s', value: {
			d: 0.85,
			p: 0.02
		}
	},
	{
		name: 'Alive   0.5s', value: {
			d: 0.7,
			p: 0.06
		}
	},
	{
		name: 'Alive  0.25s', value: {
			d: 0.55,
			p: 0.16
		}
	},


	{
		name: 'Smooth    1s', value: {
			p: 0.012,
			d: 0.8
		}
	},
	{
		name: 'Smooth  0.5s', value: {
			p: 0.032,
			d: 0.7
		}
	},
	{
		name: 'Smooth 0.25s', value: {
			p: 0.1,
			d: 0.52
		}
	},
	{
		name: 'Bouncy    3s', value: {
			d: 0.95,
			p: 0.03
		}
	},
	{
		name: 'Bouncy    1s', value: {
			d: 0.85,
			p: 0.05
		}
	},
	{
		name: 'Bouncy   0.5s', value: {
			d: 0.73,
			p: 0.3
		}
	},

	{
		name: 'Balloon', value: {
			d: 0.9,
			p: 0.001
		}
	},
	{
		name: 'Inert', value: {
			d: 0.98,
			p: 0.002
		}
	},
	{
		name: 'Discrete', value: {
			d: 0,
			p: 1
		}
	}
];

interface PowDampOwner extends Container {
	pow: number;
	damp: number;
}

export class PowDampPresetEditor extends PowDampPresetSelector {

	getPow() {
		return (game.editor.selection[0] as PowDampOwner).pow;
	}

	getDamp() {
		return (game.editor.selection[0] as PowDampOwner).damp;
	}

	onSelect(selected: PowDampPreset) {
		if (selected.p) {
			game.editor.editProperty('pow', selected.p);
			game.editor.editProperty('damp', selected.d);
		}
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/prefab-property-editor.ts">
import type { ComponentChild } from 'preact';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const prefabEditorProps = { className: 'asset-editor' };

let assetNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy prefabs`s name',
	onMouseDown: copyTextByClick
};

const PrefabPropertyEditor = (props: EditablePropertyEditorProps): ComponentChild => {
	return R.div(prefabEditorProps,
		R.btn(props.value ? R.span(assetNameProps, props.value) : '. . .', () => {
			game.editor.choosePrefab('Select "' + props.field.name + '" prefab', props.value, props.field.filterAssets).then((selectedImage) => {
				if (selectedImage) {
					props.onChange(selectedImage);
					game.editor.history.scheduleHistorySave();
				}
			});
		}, props.value, (!props.value || fs.getFileByAssetName(props.value, AssetType.PREFAB)) ? 'choose-asset-button' : 'choose-asset-button danger'),
		props.value ? R.btn(R.icon('reject'), (ev: PointerEvent) => {
			showContextMenu([
				{
					name: R.fragment(R.icon('reject'), 'Clear \'' + props.field.name + '\''),
					onClick: () => {
						props.onChange(null);
					}
				},
				{
					name: 'Cancel',
					onClick: () => { } // eslint-disable-line @typescript-eslint/no-empty-function
				}
			], ev);
		}, 'Clear', 'tool-button') : undefined
	);
};

PrefabPropertyEditor.parser = (val: string) => {
	return val || null;
};


PrefabPropertyEditor.contextMenuInjection = (contextMenu: ContextMenuItem[], _field:EditablePropertyDesc, _clickedValue:any, _value:any) => {
	if (_clickedValue) {
		contextMenu.splice(contextMenu.indexOf(null) + 1, 0, {
			name: 'Reveal In Explorer',
			onClick: () => {
				const file = fs.getFileByAssetName(_clickedValue, AssetType.PREFAB);
				if (file) {
					fs.showFile(file.fileName);
				}
			}
		},
		{
			name: R.fragment(R.icon('asset-prefab'), 'Edit prefab'),
			onClick: () => {
				PrefabEditor.editPrefab(_clickedValue, true);
			}
		}
		);
	}
};

export default PrefabPropertyEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/rect-editor.ts">
import type { Container } from 'pixi.js';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import BooleanEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/boolean-editor';
import type { NumberEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-editors/number-editor';
import NumberEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/number-editor';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import ___RectGuide from 'thing-editor/src/engine/lib/assets/src/___system/___rect-guide.c';

interface RectEditorState {
	focus: boolean;
}

const rectEditorProps = { className: 'rect-editor' };
const propGroupProps = { className: 'rect-editor-group' };

const propLabelProps = { className: 'rect-prop-label' };
const xLabel = R.div(propLabelProps, 'x ');
const yLabel = R.div(propLabelProps, 'y ');
const wLabel = R.div(propLabelProps, 'w ');
const hLabel = R.div(propLabelProps, 'h ');


export default class RectEditor extends Component<EditablePropertyEditorProps, RectEditorState> {

	itIsCallbackEditor = false;

	constructor(props: EditablePropertyEditorProps) {
		super(props);
		this.onXChange = this.onXChange.bind(this);
		this.onYChange = this.onYChange.bind(this);
		this.onWChange = this.onWChange.bind(this);
		this.onHChange = this.onHChange.bind(this);
		this.onNullCheckboxChange = this.onNullCheckboxChange.bind(this);
	}

	timeout = 0;

	componentWillMount() {
		this.checkNullability();
	}

	UNSAFE_componentWillReceiveProps() {
		if (!this.timeout) {
			this.timeout = window.setTimeout(() => {
				this.checkNullability();
				clearTimeout(this.timeout);
				this.timeout = 0;
			}, 6);
		}
	}

	componentWillUnmount() {
		if (this.timeout) {
			clearTimeout(this.timeout);
			this.timeout = 0;
		}
	}

	checkNullability() {
		if (!(game.editor.selection[0] as KeyedObject)[this.props.field.name] && !this.props.field.canBeEmpty) {
			this.onNullCheckboxChange();
		}
	}

	onXChange(val: number, isDelta: boolean, delta: number) {
		this.changeRectProperty(val, isDelta, delta, 'x');
	}

	onYChange(val: number, isDelta: boolean, delta: number) {
		this.changeRectProperty(val, isDelta, delta, 'y');
	}

	onWChange(val: number, isDelta: boolean, delta: number) {
		this.changeRectProperty(val, isDelta, delta, 'w');
	}

	onHChange(val: number, isDelta: boolean, delta: number) {
		this.changeRectProperty(val, isDelta, delta, 'h');
	}

	changeRectProperty(val: number, isDelta: boolean, delta: number, name: string) {
		let fieldName = this.props.field.name;
		let updated = false;

		for (let o of game.editor.selection as KeyedObject[]) {
			if (isDelta && delta !== 0) {
				o[fieldName][name] += delta;
				Lib.__invalidateSerializationCache(o as Container);
				updated = true;
			} else if (o[fieldName][name] !== val) {
				o[fieldName][name] = val;
				Lib.__invalidateSerializationCache(o as Container);
				updated = true;
			}
			if (this.props.field.hasOwnProperty('parser')) {
				o[fieldName] = this.props.field.parser!(o[fieldName]);
			}
		}
		if (updated) {
			this.forceUpdate();
			game.editor.sceneModified();
		}
	}

	onNullCheckboxChange() {
		const field = this.props.field;
		let fieldName = field.name;
		const rectKey = '___deletedRectangle_' + field.name;
		for (let o of game.editor.selection) {
			let extData = o.__nodeExtendData as KeyedObject;
			const rect = (o as KeyedObject)[fieldName] as EditableRect;
			if (rect) {
				extData[rectKey] = rect;
				(o as KeyedObject)[fieldName] = null;
			} else {
				(o as KeyedObject)[fieldName] = extData[rectKey] || { x: 0, y: 0, w: 100, h: 50 };
			}
		}
		this.forceUpdate();
		game.editor.sceneModified();
	}

	render() {
		let f = this.props.field;

		game.editor.selection.forEach((o) => {
			let r = (o as KeyedObject)[f.name];
			___RectGuide.show(o, f, r);
		});

		let r = (game.editor.selection[0] as KeyedObject)[f.name];
		let body;
		if (r) {
			body = R.div(null,
				R.div(propGroupProps,
					xLabel,
					h(NumberEditor, { field: { min: f.rect_minX, max: f.rect_maxX }, disabled: this.props.disabled, onChange: this.onXChange, value: r.x } as NumberEditorProps)
				),
				R.div(propGroupProps,
					yLabel,
					h(NumberEditor, { field: { min: f.rect_minY, max: f.rect_maxY }, disabled: this.props.disabled, onChange: this.onYChange, value: r.y } as NumberEditorProps),
				),
				R.div(propGroupProps,
					wLabel,
					h(NumberEditor, { field: { min: f.rect_minW, max: f.rect_maxW }, disabled: this.props.disabled, onChange: this.onWChange, value: r.w } as NumberEditorProps),
				),
				R.div(propGroupProps,
					hLabel,
					h(NumberEditor, { field: { min: f.rect_minH, max: f.rect_maxH }, disabled: this.props.disabled, onChange: this.onHChange, value: r.h } as NumberEditorProps)
				)
			);
		}

		return R.div(rectEditorProps,
			f.canBeEmpty ? BooleanEditor({ disabled: this.props.disabled!, onChange: this.onNullCheckboxChange, value: r !== null } as any as EditablePropertyEditorProps) : undefined,
			body
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/refs-editor.ts">
import { Container } from 'pixi.js';
import { Component, isValidElement } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import highlightObject from 'thing-editor/src/editor/utils/highlight-object';
import game from 'thing-editor/src/engine/game';


interface RefFieldEditorState {
	toggled?: boolean;
	filter?: string;
}


export default class RefFieldEditor extends Component<EditablePropertyEditorProps, RefFieldEditorState> {

	RENDER_PROPS = { onMouseEnter: this.onMouseEnter.bind(this) };

	onMouseEnter() {
		if (this.props.value instanceof Container) {
			highlightObject(this.props.value);
		}
	}

	render() {

		let val = this.props.value;

		if (val instanceof Container) {
			return R.span(this.RENDER_PROPS, R.btn(R.sceneNode(val),
				() => {
					if (this.props.value) {
						if ((this.props.value as Container).getRootContainer().parent !== game.stage) {
							game.editor.notify('Object is not attached to stage.');
						} else {
							game.editor.selection.select(this.props.value);
						}
					}
				}
			));
		} else {

			let title;
			if (val) {
				if (typeof val === 'object') {
					title = '[object]';
				} else if (typeof val === 'function') {
					title = 'function: ' + val.name;
				} else {
					title = '' + val;
				}
			} else {
				title = '' + val;
			}
			if (!this.props.value) {
				return '' + this.props.value;
			}
			return R.btn(title, () => {
				if (this.props.value) {
					if (isValidElement(this.props.value)) {
						game.editor.ui.modal.showModal(this.props.value);
					} else if (this.props.field.onClick) {
						this.props.field.onClick(this.props.value);
					} else {
						try {
							game.editor.ui.modal.showModal(R.fragment(
								R.b({ className: '' }, (game.editor.selection[0].constructor as SourceMappedConstructor).__className + '.' + this.props.field.name + ' content:'),
								R.textarea({ readonly: true, value: JSON.stringify(this.props.value, undefined, ' ') })
							));
						} catch (_er) {
							game.editor.ui.modal.showInfo('Object has circular structures and can not be represented as text. Please check browser\'s console to see reference\'s value.', undefined, 32039);
						}
					}
					console.dir(this.props.value);
				}
			});
		}
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/resource-editor.ts">
import type { ComponentChild } from 'preact';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const resourceEditorProps = { className: 'asset-editor' };

let assetNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy resource`s name',
	onMouseDown: copyTextByClick
};

const ResourceEditor = (props: EditablePropertyEditorProps): ComponentChild => {
	const file = fs.getFileByAssetName(props.value, AssetType.RESOURCE);
	return R.div(resourceEditorProps,
		R.btn(props.value ? R.span(assetNameProps, props.value) : '. . .', () => {
			game.editor.chooseAsset(AssetType.RESOURCE, 'Select "' + props.field.name, props.value, undefined, props.field.filterAssets).then((selectedResource) => {
				if (selectedResource) {
					props.onChange(selectedResource);
					game.editor.history.scheduleHistorySave();
				}
			});
		}, props.value, (!props.value || file) ? 'choose-asset-button' : 'choose-asset-button danger'),
		props.value && (props.field.canBeEmpty !== false) ? R.btn(R.icon('reject'), (ev: PointerEvent) => {
			showContextMenu([
				{
					name: R.fragment(R.icon('reject'), 'Clear \'' + props.field.name + '\''),
					onClick: () => {
						props.onChange(props.field.canBeEmpty === false ? props.field.default : null);
					}
				},
				{
					name: 'Cancel',
					onClick: () => { } // eslint-disable-line @typescript-eslint/no-empty-function
				}
			], ev);
		}, 'Clear', 'tool-button') : undefined
	);
};

ResourceEditor.parser = (val: string) => {
	return val || null;
};

ResourceEditor.contextMenuInjection = (contextMenu: ContextMenuItem[], _field:EditablePropertyDesc, _clickedValue:any, _value:any) => {
	if (_clickedValue) {
		contextMenu.splice(contextMenu.indexOf(null) + 1, 0, {
			name: 'Reveal In Explorer',
			onClick: () => {
				const file = fs.getFileByAssetName(_clickedValue, AssetType.IMAGE);
				if (file) {
					fs.showFile(file.fileName);
				}
			}
		});
	}
};

export default ResourceEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/select-editor.ts">
import type { ComponentChild } from 'preact';
import { Component, render } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import { searchByRegexpOrText } from 'thing-editor/src/editor/utils/search-by-regexp-or-text';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const CLASS_NAME = 'select-editor-current clickable';
const CLASS_NAME_DISABLED = 'select-editor-current disabled';

let openedList: ComponentChild | null;

interface SelectEditorItem<T = any> {
	name: string;
	value: T;
	visibleName?: ComponentChild;
}

//@ts-ignore //make "field" property optional
interface SelectEditorProps extends EditablePropertyEditorProps {
	field?: EditablePropertyDesc;
	noCopyValue?: boolean;
	select: (SelectEditorItem[]) | (() => SelectEditorItem[]);
}

interface SelectEditorState {
	toggled?: boolean;
	filter?: string;
}

class SelectEditor extends Component<SelectEditorProps, SelectEditorState> {

	filterName = '';
	checkForNeedClearFilter = true;
	selectedItem?: SelectEditorItem;

	focusFilter = false;

	constructor(props: SelectEditorProps) {
		super(props);
		if (this.props.field) {
			this.filterName = (this.props.field.filterName || this.props.field.name) + '-filter';
		}
		this.state = {};

		this.onToggle = this.onToggle.bind(this);
		this.onSelect = this.onSelect.bind(this);
		this.hide = this.hide.bind(this);
		this.onFilterChange = this.onFilterChange.bind(this);
		this.renderItem = this.renderItem.bind(this);
		this.onFocus = this.onFocus.bind(this);
		this.onMouseLeave = this.onMouseLeave.bind(this);
	}

	componentWillUnmount() {
		this._hideList();
	}

	_hideList() {
		if (openedList === this) {
			render(R.fragment(), document.getElementById('select-lists-root') as HTMLElement);
			openedList = null;
		}
	}

	onFocus(event: PointerEvent) {
		(event.target as HTMLInputElement).select();
	}

	onMouseLeave() {
		this.hide();
	}

	hide() {
		if (this.state.toggled) {
			this.setState({
				toggled: false
			});
			this._hideList();
		}
	}

	onToggle() {
		if (!this.state.toggled && !this.props.disabled) {
			this.focusFilter = true;
			this.setState({
				toggled: true,
				filter: game.editor.settings.getItem(this.filterName, '')
			});
		}
	}

	onSelect(item: SelectEditorItem) {
		this.props.onChange(item.value);
		this.hide();
	}

	renderItem(i: SelectEditorItem) {
		return R.div({
			key: i.name,
			className: i === this.selectedItem ? 'select-item selected-item' : 'select-item clickable',
			onMouseDown: (ev: PointerEvent) => {
				sp(ev);
				this.onSelect(i);
			}
		}, i.visibleName || i.name);
	}

	onFilterChange(ev: InputEvent) {
		this.setFilter((ev.target as HTMLInputElement).value);
	}

	setFilter(flt: string) {
		game.editor.settings.setItem(this.filterName, flt);
		this.setState({
			filter: flt
		});
	}

	render() {

		let list = this.props.select || this.props.field!.select;
		if (typeof list === 'function') {
			list = list();
			if (list.length === 0) {
				return R.span({ className: 'danger' }, 'empty values list');
			}
		}
		let filterInput: ComponentChild;

		let item: SelectEditorItem | undefined | ComponentChild;

		if (this.props.hasOwnProperty('value')) {
			item = list.find((i) => {
				if (i.value === this.props.value) return i;
			});
			if (!item) {
				item = R.span({ className: 'danger' }, this.props.value);
				if (this.props.field && this.props.field.type !== 'l10n') {
					window.setTimeout(() => {
						game.editor.ui.status.error('Invalid enum value: ' + this.props.value + ' ▾', 32002, game.editor.selection[0], this.props.field!.name);
					}, 1);
				}
			}
		}

		if (this.state.toggled) {
			if (this.focusFilter) {
				window.setTimeout(() => {
					let input = document.querySelector('#select-lists-root .select-editor-filter') as HTMLInputElement;
					if (input) {
						try {
							input.focus();
							input.setSelectionRange(0, input.value.length);
						} catch (_er) { } // eslint-disable-line no-empty
					}
				}, 10);
			}
			let a = list;
			if (this.props.field) {
				if (this.state.filter) {
					let flt = this.state.filter.toLocaleLowerCase();
					a = a.filter((i) => {
						return i === this.selectedItem || searchByRegexpOrText(i.name, flt) || (i.name === 'EMPTY') || !i.value;
					});
				}
				a = a.slice(0, 20);

			}

			filterInput = R.input({
				autoFocus: true,
				onFocus: this.onFocus,
				className: 'select-editor-filter',
				placeholder: 'Filter',
				onInput: this.onFilterChange,
				value: this.state.filter,
				style: this.props.field ? undefined : { display: 'none' }
			});

			if (this.checkForNeedClearFilter && a.length < 1) {
				this.checkForNeedClearFilter = false;
				window.setTimeout(() => {
					this.setFilter('');
				}, 1);
			}

			this.selectedItem = item as SelectEditorItem;

			window.setTimeout(() => {
				window.setTimeout(() => {
					let b = this.base as HTMLElement;
					if (b) {
						const bounds = b.getBoundingClientRect();
						let l = document.getElementById('select-list-content') as HTMLElement;
						if (l) {
							const height = Math.min(Math.round((window.innerHeight * 0.4)), l.clientHeight);
							if (bounds.top > window.innerHeight * 0.55) {
								bounds.y -= height - 25;
							}
							l.style.left = bounds.left + 'px';
							l.style.top = bounds.top + 'px';
							l.style.maxHeight = height + 'px';
						}
					}
				}, 0);
				openedList = this;

				render(R.div({
					className: 'select-editor-list',
					id: 'select-list-content',
					onMouseLeave: this.onMouseLeave
				}, filterInput, a.map(this.renderItem)), document.getElementById('select-lists-root') as HTMLElement);
			}, 0);
		}

		this.focusFilter = false;

		if (!item) {
			item = list[0];
		}

		return R.div({
			className: 'select-editor',
			onClick: this.onToggle
		},
		R.div({
			className: this.props.disabled ? CLASS_NAME_DISABLED : CLASS_NAME
		}, R.span({
			ctrlClickCopyValue: this.props.noCopyValue ? undefined : ((typeof (item as SelectEditorItem).value === 'undefined') ? item : (item as SelectEditorItem).value),
			className: this.props.noCopyValue ? undefined : 'selectable-text',
			title: this.props.noCopyValue ? undefined : CTRL_READABLE + '+click to copy value.',
			onClick: stopPropagationIfCtrl,
			onMouseDown: copyTextByClick
		}, (item as SelectEditorItem).hasOwnProperty('name') ? (item as SelectEditorItem).name : item, ' ▾'))
		);
	}
}

const stopPropagationIfCtrl = (ev: MouseEvent) => {
	if ((ev.ctrlKey || ev.metaKey)) {
		sp(ev);
	}
};

export default SelectEditor;

export type { SelectEditorItem };
</file>

<file path="src/editor/ui/props-editor/props-editors/sound-editor.ts">
import type { ComponentChild } from 'preact';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const soundEditorProps = { className: 'asset-editor' };

let assetNameProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy sound`s name',
	onMouseDown: copyTextByClick
};

const SoundEditor = (props: EditablePropertyEditorProps): ComponentChild => {
	const file = props.value && fs.getFileByAssetName(props.value, AssetType.SOUND);
	return R.div(soundEditorProps,
		R.btn(props.value ? R.span(assetNameProps, props.value) : '. . .', () => {
			game.editor.chooseSound('Select "' + props.field.name + '" sound', props.value).then((selectedSound) => {
				if (selectedSound) {
					props.onChange(selectedSound);
					game.editor.history.scheduleHistorySave();
				}
			});
		}, props.value, (!props.value || file) ? 'choose-asset-button' : 'choose-asset-button danger'),
		props.value ? R.btn(R.icon('asset-sound'), () => {
			game.editor.previewSound(props.value);
		}, 'Play', 'tool-button') : undefined,
		props.value ? R.btn(R.icon('reject'), (ev: PointerEvent) => {
			showContextMenu([
				{
					name: R.fragment(R.icon('reject'), 'Clear \'' + props.field.name + '\''),
					onClick: () => {
						props.onChange(null);
					}
				},
				{
					name: 'Cancel',
					onClick: () => { } // eslint-disable-line @typescript-eslint/no-empty-function
				}
			], ev);
		}, 'Clear', 'tool-button') : undefined
	);
};

SoundEditor.parser = (val: string) => {
	return val || null;
};

SoundEditor.contextMenuInjection = (contextMenu: ContextMenuItem[], _field:EditablePropertyDesc, _clickedValue:any, _value:any) => {
	if (_clickedValue) {
		contextMenu.splice(contextMenu.indexOf(null) + 1, 0, {
			name: 'Reveal In Explorer',
			onClick: () => {
				const file = fs.getFileByAssetName(_clickedValue, AssetType.SOUND);
				if (file) {
					fs.showFile(file.fileName);
				}
			}
		});
	}
};

export default SoundEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/spine-sequences/spine-sequences-editor.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import game from 'thing-editor/src/engine/game';
import type Spine from 'thing-editor/src/engine/lib/assets/src/extended/spine.c';
import type { SpineSequence } from 'thing-editor/src/engine/lib/assets/src/extended/spine.c';
import Window from '../../../editor-window';
import { hideAdditionalWindow, showAdditionalWindow } from '../../../ui';
import SpineSequences from './spine-sequences';

interface SpineSequencesEditorState {
	toggled: boolean;
}

function bringTimelineForward() {
	Window.bringWindowForward('#propsEditor');
	Window.bringWindowForward('#spine-sequence', true);
}

export default class SpineSequencesEditor extends Component<ClassAttributes<SpineSequencesEditor>, SpineSequencesEditorState> {

	constructor(props: ClassAttributes<SpineSequencesEditor>) {
		super(props);
		this.state = { toggled: game.editor.settings.getItem('timeline-showed', true) };
		this.onToggleClick = this.onToggleClick.bind(this);
	}

	static search(textToSearch:string, sequences: SpineSequence[], property: EditablePropertyDesc, o:Container, addSearchEntry: (o: Container, propertyName: string) => void): boolean {
		let ret = false;
		let sequenceNum = 0;
		for (let sequence of sequences) {
			if (sequence.n.toLocaleLowerCase().includes(textToSearch)) {
				addSearchEntry(o, property.name + ',' + sequenceNum);
				ret = true;
			}
			let itemNum = 0;
			for (let item of sequence.s) {
				if (item.n && (item.n.toLowerCase().includes(textToSearch))) {
					addSearchEntry(o, property.name + ',' + sequenceNum + ',' + itemNum);
					ret = true;
				}
				if (item.actions) {
					let actionNum = 0;
					for (let action of item.actions) {
						if (action.a && (action.a.toLowerCase().includes(textToSearch))) {
							addSearchEntry(o, property.name + ',' + sequenceNum + ',' + itemNum + ',' + actionNum);
							ret = true;
						}
						actionNum++;
					}
				}
				itemNum++;
			}
			sequenceNum++;
		}
		return ret;
	}

	componentDidMount() {
		bringTimelineForward();
		this._renderWindow();
	}

	componentWillUnmount() {
		this._hideWindow();
	}

	render() {
		return R.btn(this.state.toggled ? 'Close Sequences' : 'Open Sequences', this.onToggleClick, undefined, undefined, { key: 'l', ctrlKey: true });
	}

	onToggleClick() { //show/hide timeline window
		let t = !this.state.toggled;
		this.setState({ toggled: t });
		game.editor.settings.setItem('timeline-showed', t);
		if (t) {
			bringTimelineForward();
		}
	}

	onAutoSelect(selectPath: string[]) {
		if (!this.state.toggled) {
			this.onToggleClick();
			window.setTimeout(() => {
				SpineSequences.onAutoSelect(selectPath);
			}, 1);
		} else {
			SpineSequences.onAutoSelect(selectPath);
		}
	}

	componentDidUpdate() {
		this._renderWindow();
	}

	_renderWindow() {
		if (this.state.toggled) {
			showAdditionalWindow('spine-sequence', 'Spine sequences', 'Spine sequences',
				R.div({ title: '' },
					h(SpineSequences, { spine: game.editor.selection[0] as Spine, onCloseClick: this.onToggleClick }),
				), 20, 65, 90, 95, 1120, 220);
		} else {
			this._hideWindow();
		}
	}

	_hideWindow() {
		hideAdditionalWindow('spine-sequence');
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/spine-sequences/spine-sequences.ts">
import { h, type ClassAttributes } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import { scrollInToView } from 'thing-editor/src/editor/utils/scroll-in-view';
import shakeDomElement from 'thing-editor/src/editor/utils/shake-element';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type { SpineSequenceItemAction } from 'thing-editor/src/engine/lib/assets/src/extended/spine.c';
import Spine, { spineAnimationsSelectList, type SpineSequence, type SpineSequenceItem } from 'thing-editor/src/engine/lib/assets/src/extended/spine.c';
import { getCallbackIcon } from 'thing-editor/src/engine/utils/get-value-by-path';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import ComponentDebounced from '../../../component-debounced';
import showContextMenu from '../../../context-menu';
import LabelsLogger from '../../../labels-logger';
import CallbackEditor from '../call-back-editor';
import NumberEditor from '../number-editor';
import SelectEditor from '../select-editor';
import { getWindowElement } from '../timeline/timeline';

const labelItemNameProps = {
	className: 'selectable-text class-name',
	title: CTRL_READABLE + '+click to copy name',
	onMouseDown: copyTextByClick
};


const BODY_MARGIN = 10;
const FRAME_WIDTH = 3;

const sequenceWrapperProps = {
	className: 'spine-sequence-wrapper'
};

const animationSelectWrapperProps = {
	className: 'spine-sequence-animations-select-wrapper'
};

const sequencesListBlockProps = {
	className: 'spine-sequence-headers'
};

const sequencePropsEditorProps = {
	className: 'spine-sequence-item-props-editor',
};

const loopPointProps = {
	className: 'spine-sequence-item-loop',
};

const actionsContainerProps = {
	className: 'spine-sequences-actions-body'
};

const propsFieldsProps = {className: 'props-field'};

const sortActionsByTime = (a:SpineSequenceItemAction, b:SpineSequenceItemAction) => {
	return a.t - b.t;
};

interface SpineSequencesProps extends ClassAttributes<SpineSequences> {
	onCloseClick: () => void;
	spine: Spine;
}

interface SpineSequencesState {

}

const actionTimePointer = R.div({
	className: 'spine-sequence-action-time-pointer'
});

let instance:SpineSequences|undefined;

let actionY = 0;
let lastActionTime = -10;

export default class SpineSequences extends ComponentDebounced<SpineSequencesProps, SpineSequencesState> {
	constructor(props: SpineSequencesProps) {
		super(props);
		this.onAddClick = this.onAddClick.bind(this);
		this.renderSequenceLabel = this.renderSequenceLabel.bind(this);
		this.renderSequenceItem = this.renderSequenceItem.bind(this);
		this.onMouseDown = this.onMouseDown.bind(this);
		this.onMouseMove = this.onMouseMove.bind(this);
		this.addItemClick = this.addItemClick.bind(this);
		this.sequenceBodyProps = {
			onMouseDown: this.onMouseDown,
			className: 'spine-sequence-body'
		};
		this.setActiveSequence(this.activeSequenceName);
	}

	componentDidMount(): void {
		instance = this;
	}

	onMouseDown(ev:MouseEvent) {
		const e = ev.target as HTMLDivElement;
		this.sequenceBody = e.classList.contains('spine-sequence-body') ? e : e.closest('.spine-sequence-body') as HTMLDivElement;
		window.addEventListener('mousemove', this.onMouseMove);
		this.onMouseMove(ev);
		this.setActiveItem(undefined);
		this.setActiveAction(undefined);
	}

	onMouseMove (ev:MouseEvent) {
		if (!ev.buttons) {
			window.removeEventListener('mousemove', this.onMouseMove);
			return;
		}
		const b = this.sequenceBody.getBoundingClientRect();

		let fullTimelineLength = 0;

		for (const item of this.activeSequence.s) {
			fullTimelineLength += this.spine.getItemDurationFrames(item);
		}

		const scrollLimit = fullTimelineLength * FRAME_WIDTH + 60 - this.sequenceBody.offsetWidth;

		const mouseX = ev.x - b.x - BODY_MARGIN;

		if (mouseX < 40 && this.sequenceBody.scrollLeft > 0) {
			this.sequenceBody.scrollLeft = Math.max(this.sequenceBody.scrollLeft - 20, 0);
		} else if (mouseX > (this.sequenceBody.offsetWidth - 40) && this.sequenceBody.scrollLeft < scrollLimit) {
			this.sequenceBody.scrollLeft = Math.min(this.sequenceBody.scrollLeft + 20, scrollLimit);
		}

		let time = Math.max(0, Math.round((mouseX + this.sequenceBody.scrollLeft) / FRAME_WIDTH));
		this.setCurrentTime(time);
	}

	sequenceBody!: HTMLDivElement;

	sequenceBodyProps: any;

	setAnimationViewFrame(item: SpineSequenceItem, time: number) {
		if (this.spine.spineContent) {
			this.spine.spineContent.state.setAnimation(0, item.n, false);
			this.spine.spineContent.update(Math.max(0, ((time - (item.delay || 0)) / 60 * (item.speed || 1))));
		}
	}

	setCurrentTime(time:number) {
		this.currentTime = time;
		for (const item of this.activeSequence.s) {
			const itemTime = this.spine.getItemDurationFrames(item) + (item.delay || 0);
			if (time <= itemTime) {
				this.setAnimationViewFrame(item, time);
				break;
			} else {
				time -= itemTime;
			}
		}
		this.refresh();
	}

	currentTime = 0;

	componentWillUnmount(): void {
		instance = undefined;
		window.removeEventListener('mousemove', this.onMouseMove);
	}

	askForSequenceName(defaultText = '') {
 		return game.editor.ui.modal.showPrompt('Enter sequence label', defaultText, undefined, (val:string) => {
			return this.sequences.find(s => s.n === val) ? 'Sequence with label "' + val + '" already exists' : '';
		}, false, false, Array.from(LabelsLogger.allLabels));
	}

	onAutoSelect(selectPath: string[]) {
		if (this.spine.sequences) {
			this.setActiveSequence(this.spine.sequences[parseInt(selectPath[1])].n);
			if (selectPath[2]) {
				this.setActiveItem(this.activeSequence.s[parseInt(selectPath[2])]);
			}
			if (selectPath[3]) {
				this.setActiveAction(this.activeSequenceItem?.actions![parseInt(selectPath[3])]);
			}

			getWindowElement('#sequence-item-' + selectPath[1] + '-' + selectPath[2], '#spine-sequence').then(() => {
				getWindowElement('.spine-sequence-animations-select-wrapper', '#spine-sequence').then((itemView: HTMLDivElement) => {
					shakeDomElement(itemView);
				});
			});
		}
	}

	static onAutoSelect(selectPath: string[]) {
		for (let o of game.editor.selection as any as Spine[]) {
			if (o.sequences) {
				instance?.onAutoSelect(selectPath);
			}
		}
	}

	async onAddClick() {
		const name = await this.askForSequenceName();
		if (!name) {
			return;
		}
		if (!this.spine.sequences) {
			this.spine.sequences = [];
		}
		this.sequences.push({
			n: name,
			s: [
				{
					n: this.spine.currentAnimation!
				}
			]
		});
		this.setActiveSequence(name);
		this.invalidate();
	}

	async addItemClick() {
		const list = spineAnimationsSelectList();

		let selectedAnimation = (await game.editor.ui.modal.showListChoose('Select animation to add', list))?.value;
		if (selectedAnimation) {
			const item = {
				n: selectedAnimation
			};
			this.activeSequence.s.push(item);
			this.setActiveItem(item);
			this.invalidate();
		}
	}

	invalidate(saveImmediately = false) {
		if (this.activeSequenceItem?.actions) {
			this.activeSequenceItem?.actions.sort(sortActionsByTime);
		}
		Lib.__invalidateSerializationCache(this.spine);
		game.editor.sceneModified(saveImmediately);
		this.refresh();
	}

	renderSequenceLabel(sequence: SpineSequence) {
		const isActive = sequence.n === this.activeSequence.n;
		const isPlaying = !game.__EDITOR_mode && (sequence.s.includes(this.spine.playingSequenceItem!));
		let className = isActive ? 'spine-sequence-header spine-sequence-header-active' : 'spine-sequence-header clickable';
		if (isPlaying) {
			className += ' spine-sequence-header-playing';
		}

		return R.div({
			className,
			title: CTRL_READABLE + '+click to copy label`s name',
			onMouseDown: () => {
				this.setActiveSequence(sequence.n);
				this.refresh();
			},
			onContextMenu: (ev: PointerEvent) => {
				sp(ev);
				showContextMenu([
					 {
						name: 'Rename...',
						onClick: async () => {
							const name = await this.askForSequenceName(sequence.n);
							if (name) {
								sequence.n = name;
								(this.spine.spineContent?.skeleton as any).__activeEditorSequence = name;
								this.invalidate();
							}
						}
					}, {
						name: R.fragment(R.icon('delete'), 'Delete sequence "' + sequence.n + '"'),
						onClick: () => {
							this.sequences.splice(this.sequences.indexOf(sequence), 1);
							this.setActiveSequence(this.sequences[0]?.n);
							this.invalidate();
						}
					}
				], ev);
			},
		}, R.span(labelItemNameProps, sequence.n)
		);
	}

	get activeSequenceName(): string {
		return (this.spine.spineContent?.skeleton as any)?.__activeEditorSequence!;
	}

	_activeSequence!: SpineSequence;

	set activeSequence(s: SpineSequence) {
		this._activeSequence = s;
	}

	get activeSequence():SpineSequence {
		return this.spine.playingSequence || this._activeSequence;
	}

	setActiveSequence(name?:string) {
		const isChanged = this.activeSequence?.n !== name;
		if (isChanged) {
			this.currentTime = 0;
		}
		this.activeSequence = this.sequences.find(s => s.n === name)!;
		if (!this.activeSequence) {
			this.activeSequence = this.sequences[0];
			name = this.activeSequence?.n;
		}
		if (this.activeSequence) {
			if (this.spine.spineContent && this.activeSequenceName !== name) {
				(this.spine.spineContent?.skeleton as any).__activeEditorSequence = name;
			}
			if (isChanged) {
				this.activeSequenceItem = this.activeSequence.s.find(i => i.n === this.activeSequence.___activeItemName);
				this.activeSequenceAction = this.activeSequenceItem?.actions?.find((_a, i) => i === this.activeSequence.___activeActionId);
			}
		}
		this.refresh();
	}

	get activeSequenceItemName(): string {
		return this.activeSequence.___activeItemName!;
	}

	activeSequenceItem?: SpineSequenceItem;
	activeSequenceAction?: SpineSequenceItemAction;

	setActiveItem(item?:SpineSequenceItem) {
		this.activeSequenceItem = item;
		this.activeSequence.___activeItemName = item ? item.n : '';
		this.setActiveAction();
		this.refresh();
	}

	setActiveAction(action?: SpineSequenceItemAction) {
		this.activeSequenceAction = action;
		if (action) {
			this.activeSequence.___activeActionId = this.activeSequenceItem!.actions!.indexOf(action);
			this.setAnimationViewFrame(this.activeSequenceItem!, action.t);
		} else {
			this.activeSequence.___activeActionId = -1;
		}
		this.refresh(() => {
			const e = document.querySelector('.spine-sequence-item-props-editor .props-editor-callback') as HTMLInputElement;
			if (e) {
				shakeDomElement(e);
			}
		});
	}

	renderSequenceItem(item:SpineSequenceItem, itemId:number) {

		actionY = 0;
		lastActionTime = -10;

		const duration = this.spine._getAnimationDuration(item.n);

		const mixDuration = (item.mixDuration || 0) * FRAME_WIDTH;
		const mixDurationView = mixDuration ?
			R.svg({ className: 'spine-sequence-mix-view', height: 30, width: mixDuration },
				R.polyline({ points: '0,0 0,30 ' + (mixDuration) + ',0'})
			) : undefined;

		let className = 'spine-sequence-item';
		if (typeof duration !== 'number') {
			className += ' danger';
		}
		const isActive = this.activeSequenceItem === item;
		if (isActive && !this.activeSequenceAction) {
			className += ' spine-sequence-item-active';
		} else {
			className += ' clickable';
		}

		if (!this.spine.spineContent?.state.data.skeletonData.animations.find((a) => {
			return a.name === item.n;
		})) {
			className += ' spine-sequence-item-invalid';
		}

		const randomMarker = item.delayRandom ? R.div({onMouseDown: (ev:PointerEvent) => {
			if (ev.buttons === 2) {
				delete item.delayRandom;
				this.invalidate();
			}
		}, className: 'spine-sequence-random', title: 'Random delay ' + item.delayRandom}, '?') : undefined;

		const isLoop = (this.activeSequence.l === itemId) ?
			R.div(loopPointProps, 'loop') :
			undefined;

		let playMarker;
		if (item === this.spine.playingSequenceItem && this.spine.timeToNextItem >= 0) {
			playMarker = R.div({
				className: 'timeline-play-indicator',
				style: {left: this.spine.actionsTime * FRAME_WIDTH}
			});
		}

		const delayWidth = (item.delay || 0) * FRAME_WIDTH;

		const delayView = delayWidth ? R.div({
			className: 'spine-sequence-item-delay',
			style: { width: delayWidth}
		}) : undefined;

		const width = this.spine.getItemDurationFrames(item) * FRAME_WIDTH + delayWidth;
		const id = 'sequence-item-' + this.spine.sequences!.indexOf(this.activeSequence) + '-' + itemId;

		if (isActive) {
			setTimeout(() => {
				const e = window.document.querySelector('#' + id) as HTMLDivElement;
				if (e) {
					scrollInToView(e);
				}
			}, 20);
		}

		const actions = item.actions ?
			R.div(actionsContainerProps, item.actions.map((action: SpineSequenceItemAction) => {

				let className = 'spine-sequence-action';
				if (action === this.activeSequenceAction) {
					className += ' spine-sequence-action-active';
				}
				if (!action.a) {
					className += ' spine-sequence-action-empty';
				}

				if (lastActionTime >= (action.t - 3)) {
					actionY += 20;
				} else {
					actionY = 0;
					lastActionTime = action.t;
				}

				return R.div({
					className,
					style: {
						left: action.t * FRAME_WIDTH,
						top: actionY
					},
					onContextMenu: () => {
						const actions = this.activeSequenceItem?.actions!;
						actions.splice(actions.indexOf(action), 1);
						if (!actions.length) {
							delete this.activeSequenceItem?.actions;
						}
						this.setActiveAction();
						this.invalidate();
					},
					onMouseDown: (ev:PointerEvent) => {
						sp(ev);
						if (ev.altKey) {
							action = JSON.parse(JSON.stringify(action));
							item.actions?.push(action);
						}
						this.setActiveItem(item);
						this.setActiveAction(action);

						const startTime = action.t;
						const startX = game.editor.mouseX; /// 99999 - sequence items drag left right
						const dragTimeout = () => {
							if (!game.mouse.click) {
								return;
							}

							const dragToTime = startTime + (game.editor.mouseX - startX) / FRAME_WIDTH;
							const time = Math.round(Math.max(0, Math.min(this.maxActiveActionTime(), dragToTime)));
							if (this.activeSequenceAction?.t !== time) {
								this.activeSequenceAction!.t = time;
								this.setAnimationViewFrame(this.activeSequenceItem!, time);
								this.invalidate();
							}
							setTimeout(dragTimeout, 30);
						};
						setTimeout(dragTimeout, 30);
					}
				}, getCallbackIcon(action.a, this.spine), actionTimePointer);
			})) : undefined;

		return R.div(
			{
				className: 'spine-sequence-item-wrapper',
				style: {
					width
				}
			},
			R.div({
				id,
				onMouseDown: (ev:MouseEvent) => {
					sp(ev);
					this.setActiveItem(item);

					let startX = game.editor.mouseX; /// 99999 - sequence items drag left right
					const dragTimeout = () => {
						if (!game.mouse.click) {
							return;
						}
						const d = game.editor.mouseX - startX;
						if (d < (Math.min(width / -2, -60))) {
							if (this.moveItemLeft()) {
								startX = game.editor.mouseX;
							}
						} else if (d > (Math.max(width / 2, 60))) {
							if (this.moveItemRight()) {
								startX = game.editor.mouseX;
							}
						}
						setTimeout(dragTimeout, 100);
					};
					setTimeout(dragTimeout, 100);
				},
				onContextMenu: (ev:PointerEvent) => this.onItemContextMenu(ev, item),
				title: 'Drag left right to change item priority.',
				className,

			},
			delayView,
			mixDurationView,
			isLoop,
			playMarker,
			R.span({
				className: 'spine-sequence-item-name',
				style: {left: delayWidth},
			}, item.n, ' (', duration, 'f)')
			),
			randomMarker,
			actions);
	}

	onItemContextMenu(ev: PointerEvent, item:SpineSequenceItem) {
		const clickedTime = Math.round(ev.offsetX / FRAME_WIDTH);
		this.setAnimationViewFrame(item, clickedTime);
		sp(ev);
		showContextMenu([ {
			name: 'Add event callback',
			onClick: () => {
				if (!item.actions) {
					item.actions = [];
				}
				const action = {
					t: clickedTime,
					a: ''
				};
				item.actions?.push(action);
				this.setActiveAction(action);
				this.invalidate();
			}
		}, {
			name: R.fragment(R.icon('delete'), 'Delete item "' + item.n + '"'),
			onClick: () => {
				this.activeSequence.s.splice(this.activeSequence.s.indexOf(item), 1);
				if (item === this.activeSequenceItem) {
					this.setActiveItem();
				}
				this.invalidate();
			}
		}], ev);
	}


	moveItemLeft() {
		assert(this.activeSequenceItem, 'No sequence item selected.');
		const items = this.activeSequence.s;
		const i = items.indexOf(this.activeSequenceItem!);
		if (i > 0) {
			const tmp = items[i - 1];
			items[i - 1] = items[i];
			items[i] = tmp;
			this.invalidate();
			return true;
		}
	}

	moveItemRight() {
		assert(this.activeSequenceItem, 'No sequence item selected.');
		const items = this.activeSequence.s;
		const i = items.indexOf(this.activeSequenceItem!);
		if (i >= 0 && i < items.length - 1) {
			const tmp = items[i + 1];
			items[i + 1] = items[i];
			items[i] = tmp;
			this.invalidate();
			return true;
		}
	}

	maxActiveActionTime() {
		return this.spine.getItemDurationFrames(this.activeSequenceItem!) + (this.activeSequenceItem!.delay || 0);
	}

	renderSequenceItemPropsEditor() {
		if (!this.activeSequence) {
			return undefined;
		}

		let additionalProps;

		if (this.activeSequenceAction) {
			const timeValue = this.activeSequenceAction.t;
			additionalProps = R.fragment(
				'Action time: ',
				h(NumberEditor, {
					value: timeValue,
					min: 0,
					max: this.maxActiveActionTime(),
					onChange: (time) => {
						this.activeSequenceAction!.t = time;
						this.setAnimationViewFrame(this.activeSequenceItem!, time);
						this.invalidate();
					}
				}),
				'Action callback: ',
				h(CallbackEditor, {
					value: this.activeSequenceAction.a || null,
					onChange: (val: string | InputEvent) => {
						if (val && (val as InputEvent).target) {
							val = ((val as InputEvent).target as HTMLInputElement).value;
						}
						this.activeSequenceAction!.a = val as CallBackPath;
						this.invalidate();
					},
					title: ' ' + this.activeSequenceAction.a
				})
			);

		} else {

			const mixValue = this.activeSequenceItem?.hasOwnProperty('mixDuration') ? this.activeSequenceItem?.mixDuration : 0;
			const delayValue = this.activeSequenceItem?.hasOwnProperty('delay') ? this.activeSequenceItem?.delay : 0;
			const delayRandomValue = this.activeSequenceItem?.hasOwnProperty('delayRandom') ? this.activeSequenceItem?.delayRandom : 0;
			const speedValue = this.activeSequenceItem?.hasOwnProperty('speed') ? this.activeSequenceItem?.speed : 1;

			additionalProps = R.fragment(
				this.activeSequenceItem ? R.fragment(
					R.div(propsFieldsProps,
						R.div({callsName: 'props-label'}, 'Animation:'),
						R.div({className: 'props-wrapper'},
							R.div(animationSelectWrapperProps,
								h(SelectEditor, {
									select: spineAnimationsSelectList,
									onChange: (value: string) => {
					this.activeSequenceItem!.n = value;
					this.activeSequence.___activeItemName = value;
					this.invalidate();
									}, value: this.activeSequenceItemName
								})))),
					R.div(propsFieldsProps,
						R.div({callsName: 'props-label'}, 'Mix time:'),
						R.div({className: 'props-wrapper'},
							h(NumberEditor, {
								value: mixValue,
								min: 0,
								onChange: (val) => {
									if (val > 0) {
							this.activeSequenceItem!.mixDuration = val;
									} else {
										delete this.activeSequenceItem!.mixDuration;
									}
									this.invalidate();
								}
							}))),
					R.div({className: 'props-field'},
						R.div({callsName: 'props-label'}, 'Delay:'),
						R.div({className: 'props-wrapper'},
							h(NumberEditor, {
								value: delayValue,
								min: 0,
								onChange: (val) => {
									if (val > 0) {
										this.activeSequenceItem!.delay = val;
									} else {
										delete this.activeSequenceItem!.delay;
									}
									this.invalidate();
								}
							}))),
					R.div({className: 'props-field'},
						R.div({callsName: 'props-label'}, 'Delay random:'),
						R.div({className: 'props-wrapper'},
							h(NumberEditor, {
								value: delayRandomValue,
								min: 0,
								onChange: (val) => {
									if (val > 0) {
										this.activeSequenceItem!.delayRandom = val;
									} else {
										delete this.activeSequenceItem!.delayRandom;
									}
									this.invalidate();
								}
							}))),
					R.div({className: 'props-field'},
						R.div({callsName: 'props-label'}, 'Speed:'),
						R.div({className: 'props-wrapper'},
							h(NumberEditor, {
								value: speedValue,
								min: 0,
								step: 0.01,
								onChange: (val) => {
									if (val !== 1) {
							this.activeSequenceItem!.speed = val;
									} else {
										delete this.activeSequenceItem!.speed;
									}
									this.invalidate();
								}
							}))),
				) : undefined
			);
		}

		const loopValue = this.activeSequence.hasOwnProperty('l') ? this.activeSequence.l : -1;

		return R.div(sequencePropsEditorProps,
			'Loop item (-1 to disable): ',
			h(NumberEditor, {
				value: loopValue,
				min: -1,
				max: this.activeSequence.s.length - 1,
				onChange: (val) => {
					if (val >= 0) {
						this.activeSequence.l = val;
					} else {
						delete this.activeSequence.l;
					}
					this.invalidate();
				}
			}),
			R.hr(),
			additionalProps
		);
	}

	get sequences ():SpineSequence[] {
		return (game.editor.selection[0] as Spine)?.sequences || [];
	}

	get spine ():Spine {
		return this.props.spine;
	}

	render() {
		if (!(game.editor.selection[0] instanceof Spine)) {
			return 'No Spine element elected.';
		}
		if (!(game.editor.selection[0] as Spine)?.spineData) {
			return R.btn('spineData is not set.', () => {
				game.editor.ui.propsEditor.selectField('spineData');
			});
		}

		this.setActiveSequence(this.activeSequenceName);

		let sequenceView;
		if (this.activeSequence) {

			const timeMarker = R.div(
				{
					className: 'time-marker',
					style: {left: this.currentTime * FRAME_WIDTH + BODY_MARGIN}
				},
				R.div({className: 'time-marker-v-line'}),
				R.div({className: 'time-marker-label'},
					R.b(null, this.currentTime),
					R.span({className: 'time-marker-label'}, ' frames (' + (this.currentTime / 60).toFixed(2) + ' seconds)')
				)
			);

			sequenceView = R.div(this.sequenceBodyProps,
				this.activeSequence?.s.length ?
				 this.activeSequence?.s.map(this.renderSequenceItem) :
				 R.div({className: 'spine-sequence-item semi-transparent', style: {width: 340}}, R.div({className: 'spine-sequence-item-name'}, 'Empty sequence (initial pose).')),
				R.btn('+', this.addItemClick, 'Add animation item to sequence'),
				timeMarker
			);
		}

		return R.fragment(
			R.btn('×', this.props.onCloseClick, 'Hide timeline', 'close-window-btn', { key: 'Escape' }),
			R.div(sequenceWrapperProps,
				R.div(sequencesListBlockProps,
					this.sequences.map(this.renderSequenceLabel),
					R.btn('+', this.onAddClick, 'Add sequence')
				),
				sequenceView,
				this.renderSequenceItemPropsEditor()
			)
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/string-editor.ts">
import R from 'thing-editor/src/editor/preact-fabrics';
import type { EditablePropertyEditorProps } from 'thing-editor/src/editor/ui/props-editor/props-field-wrapper';

const StringEditor = (props: EditablePropertyEditorProps) => {
	const elementProps = {
		onInput: (ev: InputEvent) => {
			props.onChange((ev.target as HTMLInputElement).value);
		}, onBlur: props.onBlur, disabled: props.disabled, title: props.value, value: props.value || ''
	};
	if (props.field.multiline) {
		return R.textarea(elementProps);
	}
	return R.input(elementProps);
};

StringEditor.parser = (val: string) => {
	return val || null;
};

export default StringEditor;
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/get-keyframe-types-for-field.ts">
import type { Container } from 'pixi.js';
import game from 'thing-editor/src/engine/game';
import type MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import { TimelineKeyFrameType } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

function getDefaultKeyframeTypeForField(o: MovieClip, propertyName: string): TimelineKeyFrameType {
	switch (propertyName) {
	case 'x':
	case 'y':
	case 'rotation':
		return TimelineKeyFrameType.SMOOTH;
	case 'alpha':
	case 'tintR':
	case 'tintG':
	case 'tintB':
		return TimelineKeyFrameType.LINEAR;
	default:
		return getKeyframeTypesForField([o], propertyName)[0];
	}
}

const keyframeTypesForNumber: TimelineKeyFrameType[] = [
	TimelineKeyFrameType.SMOOTH,
	TimelineKeyFrameType.LINEAR,
	TimelineKeyFrameType.DISCRETE,
	TimelineKeyFrameType.BOUNCE_BOTTOM,
	TimelineKeyFrameType.BOUNCE_TOP
];
const keyframeTypesDiscreteOnly = [TimelineKeyFrameType.DISCRETE];

function getKeyframeTypesForField(objects: Container[], propertyName: string): TimelineKeyFrameType[] {
	for (let o of objects) {
		let fieldDesc = game.editor.getObjectField(o, propertyName);
		if (!fieldDesc) {
			window.setTimeout(() => {
				game.editor.ui.status.warn('Property \'' + propertyName + '\' is not exists anymore, but movieClip have animation for it.', 32040, o);
			}, 0);
			return [];
		}
		if (fieldDesc.type !== 'number') {
			return keyframeTypesDiscreteOnly;
		}
	}
	return keyframeTypesForNumber;
}

export { getDefaultKeyframeTypeForField, getKeyframeTypesForField };
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/keyframe-property-editor.ts">
import type { ClassAttributes } from 'preact';
import { h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import CallbackEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/call-back-editor';
import NumberEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/number-editor';
import PowDampPresetSelector from 'thing-editor/src/editor/ui/props-editor/props-editors/pow-damp-preset-selector';
import SelectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import { getKeyframeTypesForField } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/get-keyframe-types-for-field';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import type TimelineKeyframeView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-keyframe-view';
import type { TimelineSelectable } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-selectable';
import game from 'thing-editor/src/engine/game';
import { TimelineKeyFrameType } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

const READABLE_KEYFRAME_TYPES = ['SMOOTH', 'LINEAR', 'DISCRETE', 'BOUNCE ⬇', 'BOUNCE ⬆'];

let instance: KeyframePropertyEditor;

interface KeyframePropertyEditorProps extends ClassAttributes<KeyframePropertyEditor> {
	keyframesGetter: () => TimelineSelectable[];
	owner: Timeline;
}

interface KeyframePropertyEditorState {
	toggled?: boolean;
}

export default class KeyframePropertyEditor extends ComponentDebounced<KeyframePropertyEditorProps, KeyframePropertyEditorState> {

	constructor(props: KeyframePropertyEditorProps) {

		super(props);
		this.onActionChange = this.onActionChange.bind(this);
		this.onGravityChange = this.onGravityChange.bind(this);
		this.onBouncingChange = this.onBouncingChange.bind(this);
		this.onSetSpeedExistsChanged = this.onSetSpeedExistsChanged.bind(this);
		this.onSetRandomExistsChanged = this.onSetRandomExistsChanged.bind(this);
		this.onSpeedChanged = this.onSpeedChanged.bind(this);
		this.onRandomChanged = this.onRandomChanged.bind(this);
		this.onJumpChanged = this.onJumpChanged.bind(this);
		this.resetJumpTime = this.resetJumpTime.bind(this);
		this.onDampChanged = this.onDampChanged.bind(this);
		this.onPowChanged = this.onPowChanged.bind(this);
		this.onPresetSelected = this.onPresetSelected.bind(this);
		this.onTypeSelect = this.onTypeSelect.bind(this);
		instance = this;
	}

	static refresh() {
		if (instance) {
			instance.refresh();
		}
	}

	onKeyframeChanged() {
		for (let k of this.keyframes) {
			let kf = k.props.keyFrame;
			if (kf.hasOwnProperty('a')) {
				if (!kf.a) {
					delete kf.a;
				}
			}
			kf.___view!.onChanged();
		}
		this.refresh();
	}

	onObjectChanged() {
		for (let k of this.keyframes) {
			let objectTimelineEditor = k.props.owner.props.owner.props.owner;
			Timeline.allFieldDataChanged(objectTimelineEditor.props.node);
			objectTimelineEditor.forceUpdate();
		}
		this.forceUpdate();
	}

	onGravityChange(value: number) {
		for (let k of this.keyframes) {
			if (k.props.keyFrame.m > TimelineKeyFrameType.DISCRETE) {
				k.props.keyFrame.g = value;
			}
		}
		this.onKeyframeChanged();
	}

	onBouncingChange(val:number) {
		for (let k of this.keyframes) {
			if (k.props.keyFrame.m > TimelineKeyFrameType.DISCRETE) {
				k.props.keyFrame.b = -val;
			}
		}
		this.onKeyframeChanged();
	}

	onActionChange(val: string | InputEvent) {
		if (val && (val as InputEvent).target) {
			val = ((val as InputEvent).target as HTMLInputElement).value;
		}
		for (let k of this.keyframes) {
			k.props.keyFrame!.a = val as string;
		}
		this.onKeyframeChanged();
	}

	get keyframes(): TimelineKeyframeView[] {
		return this.props.keyframesGetter() as TimelineKeyframeView[];
	}

	onSpeedChanged(val: number) {
		for (let k of this.keyframes) {
			let p = k.props.owner.props.owner.props;
			if ((typeof (p.owner.props.node as KeyedObject)[p.field.n]) === 'number') {
				k.props.keyFrame.s = val;
			}
		}
		this.onKeyframeChanged();
	}

	onRandomChanged(val: number) {
		for (let k of this.keyframes) {
			let kf = k.props.keyFrame;
			kf.r = Math.min(val, kf.n.t - kf.j - 1);
		}
		this.onKeyframeChanged();
	}

	onSetSpeedExistsChanged(ev: InputEvent) {
		for (let k of this.keyframes) {
			let p = k.props.owner.props.owner.props;
			if (((typeof (p.owner.props.node as KeyedObject)[p.field.n]) === 'number') && ((ev.target as HTMLInputElement).checked)) {
				k.props.keyFrame.s = 0;
			} else {
				delete k.props.keyFrame.s;
			}
		}
		this.onKeyframeChanged();
	}

	onSetRandomExistsChanged(ev: InputEvent) {
		for (let k of this.keyframes) {
			if ((ev.target as HTMLInputElement).checked) {
				k.props.keyFrame.r = -10;
			} else {
				delete k.props.keyFrame.r;
			}
		}
		this.onKeyframeChanged();
	}

	onJumpChanged(val: number) {
		for (let k of this.keyframes) {
			k.props.keyFrame.j = val;
		}
		this.onKeyframeChanged();
	}

	resetJumpTime() {
		for (let k of this.keyframes) {
			k.props.keyFrame.___loopPointView!.deleteLoopPoint();
		}
		this.onKeyframeChanged();
	}

	onDampChanged(val: number) {
		for (let k of this.keyframes) {
			let o = k.props.owner.props.owner.props.owner.props.node;
			o._timelineData.d = val;
		}
		this.onObjectChanged();
	}

	onPowChanged(val: number) {
		for (let k of this.keyframes) {
			let o = k.props.owner.props.owner.props.owner.props.node;
			o._timelineData.p = val;
		}
		this.onObjectChanged();
	}

	onPresetSelected(pow: number, damp: number) {
		for (let k of this.keyframes) {
			let o = k.props.owner.props.owner.props.owner.props.node;
			o._timelineData.p = pow;
			o._timelineData.d = damp;
		}
		this.onObjectChanged();
	}

	onTypeSelect(val: TimelineKeyFrameType) {
		for (let kfView of this.keyframes) {
			kfView.setKeyframeType(val);
		}
		this.onKeyframeChanged();
		this.forceUpdate();
	}

	render() {

		let keyframes = this.keyframes;
		let kfView = keyframes[0];
		if (!kfView) {
			return R.fragment();
		}
		let kf = kfView.props.keyFrame;

		let availableKeyframeTypes: TimelineKeyFrameType[] | undefined;


		let speedSetPossible = true;
		let speedVal: false | number = false;

		let keyframeTypes:TimelineKeyFrameType[];
		for (let k of keyframes) {

			let fieldsProps = k.props.owner.props.owner.props;
			speedSetPossible = speedSetPossible && ((typeof (fieldsProps.owner.props.node as KeyedObject)[fieldsProps.field.n]) === 'number');
			if (speedVal === false && k.props.keyFrame.hasOwnProperty('s')) {
				speedVal = k.props.keyFrame.s!;
			}

			keyframeTypes = getKeyframeTypesForField(game.editor.selection, fieldsProps.field.n);
			if (!availableKeyframeTypes || (availableKeyframeTypes.length > keyframeTypes.length)) {
				availableKeyframeTypes = keyframeTypes;
			}
		}

		let selectableKeyframeTypes: ({
			name: string;
			value: TimelineKeyFrameType;
		}[]) = availableKeyframeTypes!.map((type) => {
			return { name: READABLE_KEYFRAME_TYPES[type], value: type };
		});

		let body;

		let selectedObjectsTimeline = kfView.props.owner.props.owner.props.owner.props.node._timelineData;
		if ((!kf) || (!selectedObjectsTimeline)) {
			return R.div();
		}

		let extendEditor;
		if (kf.m > 2) { //BOUNCE ⬆, BOUNCE ⬇
			extendEditor = R.fragment(
				'Gravity', h(NumberEditor, { value: kf.g as number, step: 0.0001, min: 0.0001, max: 10, onChange: this.onGravityChange }),
				R.smallSpace(),
				'Bouncing', h(NumberEditor, { value: -(kf.b as number), step: 0.01, min: 0.01, max: 10, onChange: this.onBouncingChange })
			);
		} else if (kf.m === TimelineKeyFrameType.SMOOTH) {

			extendEditor = R.fragment(
				'Power', h(NumberEditor, { value: selectedObjectsTimeline.p, step: 0.001, min: 0.00001, max: 1, onChange: this.onPowChanged }),
				R.smallSpace(),
				'Damp', h(NumberEditor, { value: selectedObjectsTimeline.d, step: 0.01, min: 0.00, max: 1, onChange: this.onDampChanged }),
				R.smallSpace(),
				'Preset', h(PowDampPresetSelector, {
					pow: selectedObjectsTimeline.p,
					damp: selectedObjectsTimeline.d,
					onPresetSelected: this.onPresetSelected
				})
			);
		}


		let speedEditor;
		if (speedSetPossible) {
			let hasSpeed = kf.hasOwnProperty('s');
			let edField = game.editor.getObjectField(game.editor.selection[0], kf.___view!.props.owner.props.owner.props.field.n);
			speedEditor = R.fragment(
				R.label({ htmlFor: 'speed-set-checkbox' }, 'Set speed'),
				R.input({ className: 'clickable', id: 'speed-set-checkbox', type: 'checkbox', onChange: this.onSetSpeedExistsChanged, checked: hasSpeed }),
				hasSpeed ? h(NumberEditor, { value: speedVal, step: (edField.step || 1) / 10, min: -1000, max: 1000, onChange: this.onSpeedChanged }) : undefined,
				R.space()
			);
		}
		let hasRandom = kf.hasOwnProperty('r');
		let randomEditor;
		if (hasRandom) {
			randomEditor = h(NumberEditor, { value: kf.r, step: 1, min: -1000, max: -1, onChange: this.onRandomChanged });
		}

		let jumpReset;
		if (kf.j !== kf.t) {
			jumpReset = R.btn('x', this.resetJumpTime, 'Remove loop point');
		}
		let jumpEditor = h(NumberEditor, { value: kf.j, step: 1, min: -99999999, max: 99999999, onChange: this.onJumpChanged });

		body = R.fragment(
			'Action',
			R.span({ className: 'keyframe-callback-editor' },
				h(CallbackEditor, {
					value: kf.a || null,
					onChange: this.onActionChange,
					title: 'Callback for keyframe ' + kf.t
				})
			),
			R.space(),
			R.span({ title: 'Keyframe type' }, h(SelectEditor, { onChange: this.onTypeSelect, noCopyValue: true, value: kf.m, select: selectableKeyframeTypes })),
			R.space(),
			speedEditor,
			R.label({ htmlFor: 'random-set-checkbox', title: 'Next frame will be reached for random time longer or faster' }, 'Time random'),
			R.input({ className: 'clickable', id: 'random-set-checkbox', type: 'checkbox', onChange: this.onSetRandomExistsChanged, checked: hasRandom }),
			randomEditor,
			R.space(),
			R.label({ htmlFor: 'jump-time-checkbox' }, 'Loop'),
			jumpEditor,
			jumpReset,
			R.space(),
			extendEditor
		);

		return R.div({ className: 'bottom-panel'},
			body
		);
	}
}


export { READABLE_KEYFRAME_TYPES };
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/objects-timeline.ts">
import type { ClassAttributes } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import FieldsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-field';
import TimelineLabelView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-label-view';
import TimelineLineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-line-view';
import StatusBar from 'thing-editor/src/editor/ui/status-bar';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineFieldData, TimelineLabelData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const objectsTimelineProps = { className: 'objects-timeline' };


interface ObjectsTimelineViewProps extends ClassAttributes<ObjectsTimelineView> {
	node: MovieClip;
	owner: Timeline;
	widthZoom: number;
	heightZoom: number;
}

export default class ObjectsTimelineView extends Component<ObjectsTimelineViewProps> {


	componentDidMount() {
		this.props.owner.applyCurrentTimeValuesToFields([this.props.node]);
	}

	renderTimeLabel(labelName: string, labelsNamesList: string[]) {
		const label = this.props.node._timelineData.l[labelName];
		if (!label.___key) {
			label.___key = MovieClip.__generateKeyframeId();
		}
		return h(TimelineLabelView, {
			key: label.___key,
			owner: this,
			label: label,
			labelsNamesList
		});
	}

	onLabelChange(label: TimelineLabelData) {
		let o = this.props.node;
		TimelineLabelView.reNormalizeLabel(label, this.props.node);
		Timeline.allFieldDataChanged(o);
		this.forceUpdate();
	}

	createKeyframeWithTimelineValue(fieldData: TimelineFieldData, time: number) { //used for toggle keyframe
		this.props.owner.setTime(time);
		this.props.owner.createKeyframeWithCurrentObjectsValue(this.props.node, fieldData.n, time);
		Timeline.fieldDataChanged(fieldData, this.props.node);
	}

	deleteAnimationField(fieldData: TimelineFieldData) {
		let timelineData = this.props.node._timelineData;
		let i = timelineData.f.indexOf(fieldData);
		for (let k of fieldData.t) {
			Timeline.unselectKeyframe(k);
		}
		assert(i >= 0, 'Can\'t find field in timeline');
		timelineData.f.splice(i, 1);
		this.props.node._disposePlayers();
		TimelineLineView.invalidateChartsRenderCache(fieldData);
		this.props.node.__invalidateSerializeCache();
		game.editor.sceneModified();
		this.forceUpdate();
	}

	cloneLabel(newName:string, oldName:string) {
		const oldLabel = this.props.node._timelineData.l[oldName];
		this.addLabel(newName, oldLabel.t);
		const newLabel = this.props.node._timelineData.l[newName];
		this.props.node._timelineData.l[oldName] = newLabel;
		this.props.node._timelineData.l[newName] = oldLabel;
		newLabel.___name = oldName;
		oldLabel.___name = newName;
	}

	addLabel(name:string, time:number) {
		let label: TimelineLabelData = { t: time, ___name: name } as TimelineLabelData;
		this.props.node._timelineData.l[name] = label;
		TimelineLabelView.reNormalizeLabel(label, this.props.node);
		this.onLabelChange(label);
	}

	render() {
		let tl = this.props.node._timelineData;

		let labelsNames = tl ? Object.keys(tl.l) : [];
		let width = 0;
		if (tl) {
			for (let f of tl.f) {
				if (f.t[f.t.length - 1].t > width) {
					width = f.t[f.t.length - 1].t;
				}
			}
		}
		width += 3500;
		width *= this.props.widthZoom;

		let previewMarker;
		if (this.props.node.__previewFrame) {
			previewMarker = R.div({
				className: 'preview-frame-marker', style: {
					left: this.props.node.__previewFrame * this.props.widthZoom
				}
			}, 'Preview frame');
		}

		let labelsPanel = R.div({
			onMouseDown: (ev: PointerEvent) => { //create new label by right click
				if (tl && ev.buttons === 2) {
					let time = Timeline.mouseEventToTime(ev);

					TimelineLabelView.askForLabelName(labelsNames, 'Create new label:').then((name) => {
						if (name) {
							this.addLabel(name, time);
						}
					});
				} else if ((ev.ctrlKey || ev.metaKey)) {
					game.editor.onObjectsPropertyChanged(this.props.node, '__previewFrame', Timeline.mouseEventToTime(ev));
				} else {
					this.props.owner.setTime(Timeline.mouseEventToTime(ev));
					this.props.owner.startTimeDragging();
				}
			},
			style: { width },
			onMouseOver: () => {
				StatusBar.addStatus('Right click to add time label. ' + CTRL_READABLE + ' + click to set preview frame', 'timeline-header', 1);
			},
			onMOuseOut: () => {
				StatusBar.removeStatus('timeline-header');
			},
			title: tl && 'Right click to add time label\n' + CTRL_READABLE + ' + click to set preview frame',
			className: 'timeline-labels-panel'
		}, previewMarker, labelsNames
			.sort((l1, l2) => {
				const t1 = this.props.node._timelineData.l[l1].t;
				const t2 = this.props.node._timelineData.l[l2].t;
				return t1 === t2 ? l2.length - l1.length : t2 - t1;
			})
			.map((labelName) => {
				return this.renderTimeLabel(labelName, labelsNames);
			}));


		return R.div(objectsTimelineProps,
			labelsPanel,
			tl && tl.f.map((field, i) => {
				return h(FieldsTimelineView, { field, fieldIndex: i, key: field.n, owner: this });
			})
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/time-marker.ts">
import type { ClassAttributes } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';

const timeMarkerLineProps = { className: 'time-marker-v-line' };
const timeMarkerLabelProps = { className: 'time-marker-label' };
const smallTextProps = { className: 'small-text' };

interface TimeMarkerProps extends ClassAttributes<TimeMarker> {
	owner: Timeline;
}

interface TimeMarkerState {
	time: number;
}

export default class TimeMarker extends Component<TimeMarkerProps, TimeMarkerState> {
	constructor(props: TimeMarkerProps) {
		super(props);
		this.state = { time: 0 };
		this.onMouseDown = this.onMouseDown.bind(this);
	}

	onMouseDown() {
		this.props.owner.startTimeDragging();
	}

	setTime(time: number, scrollInToView = false) {
		this.setState({ time });
		if (scrollInToView) {
			this.scrollInToView(time);
		}
	}

	scrollInToView(time: number) {
		let hw = Timeline.timelineDOMElement!.clientWidth / 2;
		let x = time * this.props.owner.state.widthZoom - hw;
		if (Math.abs(Timeline.timelineDOMElement!.scrollLeft - x) > hw) {
			Timeline.timelineDOMElement!.scrollLeft = x;
		} else {
			let s = Timeline.timelineDOMElement!.scrollLeft;
			if (s < (x + 150 - hw)) {
				Timeline.timelineDOMElement!.scrollLeft = (x + 150 - hw);
			} else if (s > (x - 40 + hw)) {
				Timeline.timelineDOMElement!.scrollLeft = (x - 40 + hw);
			}
		}
	}

	render() {
		const timeNumbers = [];
		for (let i = 60; i < 1500; i += 60) {
			timeNumbers.push(R.div({className: 'timeline-time-number', style: { left: i * this.props.owner.state.widthZoom}}, i));
		}
		return R.div({ className: 'time-marker-body', onMouseDown: this.onMouseDown },
			timeNumbers,
			R.div({ className: 'time-marker', style: { left: this.state.time * this.props.owner.state.widthZoom } },
				R.div(timeMarkerLineProps),
				R.div(timeMarkerLabelProps,
					R.b(null, this.state.time), R.span(smallTextProps, ' frames (' + (this.state.time / 60).toFixed(2) + ' seconds)')
				)
			)
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-editor.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import Window from 'thing-editor/src/editor/ui/editor-window';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import { hideAdditionalWindow, showAdditionalWindow } from 'thing-editor/src/editor/ui/ui';
import makePathForKeyframeAutoSelect from 'thing-editor/src/editor/utils/movie-clip-keyframe-select-path';
import game from 'thing-editor/src/engine/game';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

function bringTimelineForward() {
	Window.bringWindowForward('#propsEditor');
	Window.bringWindowForward('#timeline', true);
}

interface TimelineEditorState {
	toggled: boolean;
}

export default class TimelineEditor extends Component<ClassAttributes<TimelineEditor>, TimelineEditorState> {

	constructor(props: ClassAttributes<TimelineEditor>) {
		super(props);
		this.state = { toggled: game.editor.settings.getItem('timeline-showed', true) };
		this.onToggleClick = this.onToggleClick.bind(this);
	}

	static search(textToSearch:string, timeline: TimelineData, property: EditablePropertyDesc, o:Container, addSearchEntry: (o: Container, propertyName: string) => void): boolean {
		let ret = false;
		for (let field of timeline.f) {
			for (let k of field.t) {
				if (k.a && (k.a.toLowerCase().indexOf(textToSearch) >= 0)) {
					addSearchEntry(o, makePathForKeyframeAutoSelect(property, field, k));
					ret = true;
				}
			}
		}
		for (let label in timeline.l) {
			if (label.toLowerCase().indexOf(textToSearch) >= 0) {
				addSearchEntry(o, property.name + ',,' + label);
				ret = true;
			}
		}
		return ret;
	}

	componentDidMount() {
		bringTimelineForward();
		this._renderWindow();
	}

	componentWillUnmount() {
		this._hideWindow();
	}

	onToggleClick() { //show/hide timeline window
		let t = !this.state.toggled;
		this.setState({ toggled: t });
		game.editor.settings.setItem('timeline-showed', t);
		if (t) {
			bringTimelineForward();
		}
	}

	onAutoSelect(selectPath: string[]) {
		if (!this.state.toggled) {
			this.onToggleClick();
			window.setTimeout(() => {
				Timeline.onAutoSelect(selectPath);
			}, 1);
		} else {
			Timeline.onAutoSelect(selectPath);
		}
	}

	render() {
		return R.btn(this.state.toggled ? 'Close Timeline' : 'Open Timeline', this.onToggleClick, undefined, undefined, { key: 'l', ctrlKey: true });
	}

	componentDidUpdate() {
		this._renderWindow();
	}

	_renderWindow() {
		if (this.state.toggled) {
			showAdditionalWindow('timeline', 'Timeline', 'Timeline',
				R.div({ title: '' },
					h(Timeline, { onCloseClick: this.onToggleClick }),
				), 0, 70, 100, 100, 1120, 200);
		} else {
			this._hideWindow();
		}
	}

	_hideWindow() {
		hideAdditionalWindow('timeline');
		if (game.currentContainer && game.__EDITOR_mode) {
			for (let m of game.currentContainer.findChildrenByType(MovieClip)) {
				m.resetTimeline();
			}
		}
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-field-controls.ts">
import type { ClassAttributes } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type FieldsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-field';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineFieldData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import showContextMenu from '../../../context-menu';
import Timeline from './timeline';
import TimelineKeyframeView from './timeline-keyframe-view';

interface TimelineFieldControlsProps extends ClassAttributes<TimelineFieldControls> {
	owner: FieldsTimelineView;
}


export default class TimelineFieldControls extends Component<TimelineFieldControlsProps> {

	render() {
		let fieldTimeline = this.props.owner;
		return R.div({ className: 'objects-timeline-labels timeline-fixed-block', onMouseDown: sp, style: { height: this.props.owner.props.owner.props.heightZoom } },
			R.span({ className: 'timeline-field-name',
				onContextMenu: (ev:PointerEvent) => {
					showContextMenu([
						{
							name: R.fragment(R.icon('clone'), 'Clone field animation to...'),
							onClick: async () => {
								const movieClip = fieldTimeline.props.owner.props.node;
								const srcField = fieldTimeline.props.field;
								const srcName = srcField.n;
								const type = typeof (movieClip as KeyedObject)[srcName];
								const names = (MovieClip as SourceMappedConstructor).__editableProps.filter((field) => {
									return field.animate && !movieClip.timeline!.f.some(f => f.n === field.name) && type === typeof (movieClip as KeyedObject)[field.name];
								});

								if (!names.length) {
									game.editor.ui.modal.notify('No other properties with type: ' + type);
									return;
								}
								const chosen = await game.editor.ui.modal.showListChoose('Select field to copy animation to', names.map(f => { return {name: f.name, value: f.name}; }));
								if (chosen) {
									const newField = {
										n: chosen?.value,
										t: srcField.t.map(src => {
											return TimelineKeyframeView.cloneKeyFrame(src);
										})
									} as TimelineFieldData;
									movieClip._timelineData!.f.splice(movieClip.timeline!.f.findIndex(f => srcField.n === f.n) + 1, 0, newField);
									Timeline._invalidateNodeCache(movieClip);
									fieldTimeline.props.owner.props.owner.refresh();
								}
							}
						},
						{
							name: R.fragment(R.icon('delete'), 'Delete field animation'),
							onClick: fieldTimeline.onRemoveFieldClick
						}
					], ev);
				}
			 },
			R.span({ className: 'props-label selectable-text' },
				fieldTimeline.props.field.n
			)
			)
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-field.ts">
import type { ClassAttributes } from 'preact';
import { h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import type ObjectsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/objects-timeline';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import TimelineFieldControls from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-field-controls';
import TimelineLineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-line-view';
import assert from 'thing-editor/src/engine/debug/assert';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineFieldData, TimelineKeyFrame } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';


interface FieldsTimelineViewProps extends ClassAttributes<FieldsTimelineView> {
	owner: ObjectsTimelineView;
	field: TimelineFieldData;
	fieldIndex: number;
}


export default class FieldsTimelineView extends ComponentDebounced<FieldsTimelineViewProps> {
	constructor(props: FieldsTimelineViewProps) {
		super(props);
		this.onRemoveFieldClick = this.onRemoveFieldClick.bind(this);
		this.toggleKeyframe = this.toggleKeyframe.bind(this);
		props.field.___view = this;
	}

	componentWillReceiveProps(props: FieldsTimelineViewProps) {
		let k1 = this.props.field;
		let k2 = props.field;
		if (k1.___view === this) {
			k1.___view = null;
		}
		k2.___view = this;
	}

	componentWillUnmount() {
		if (this.props.field.___view === this) {
			this.props.field.___view = null;
		}
	}

	toggleKeyframe(time: number) {
		let field = this.props.field;
		let currentKeyframe = MovieClip._findNextKeyframe(field.t, time - 1);
		if (currentKeyframe.t !== time) {
			this.props.owner.createKeyframeWithTimelineValue(field, time);
			this.refresh();
		} else {
			this.deleteKeyframe(currentKeyframe);
		}
	}

	deleteKeyframe(keyFrame: TimelineKeyFrame) {
		let f = this.props.field;
		let i = f.t.indexOf(keyFrame);
		assert(i >= 0, 'can\'t delete keyFrame.');
		if (i > 0) {
			Timeline.unselectKeyframe(keyFrame);
			f.t.splice(i, 1);
			this.onChanged();
			this.refresh();
		}
	}

	onRemoveFieldClick() {
		this.props.owner.deleteAnimationField(this.props.field);
	}

	gotoNextKeyframe(direction: number) {
		let field = this.props.field;
		let timeline = this.props.owner.props.owner;
		let currentTime = timeline.getTime();
		let currentKeyframe = MovieClip._findNextKeyframe(field.t, currentTime - 1);

		let i = field.t.indexOf(currentKeyframe);

		let moved = (currentKeyframe.t - currentTime);

		if (!(((direction > 0) === (moved > 0)) && ((direction < 0) === (moved < 0)))) {
			i += direction;
			if (i < 0) {
				i = field.t.length - 1;
			}
			else if (i >= field.t.length) {
				i = 0;
			}
		}
		timeline.selectKeyframe(field.t[i]);
	}

	onChanged() {
		let node = this.props.owner.props.node;
		let field = this.props.field;
		Timeline.fieldDataChanged(field, node);
		this.refresh();
		node.__applyValueToMovieClip(field, this.props.owner.props.owner.getTime());
	}

	render() {
		let p = this.props.owner.props;
		let height = p.heightZoom;
		return R.div({
			className: 'field-timeline',
			style: {
				backgroundSize: (60 * p.widthZoom) + 'px ' + (height - 10) + 'px',
				height
			}
		}, h(TimelineFieldControls, { owner: this }), h(TimelineLineView, { owner: this })
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-keyframe-view.ts">
import type { ClassAttributes } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import { getKeyframeTypesForField } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/get-keyframe-types-for-field';
import KeyframePropertyEditor, { READABLE_KEYFRAME_TYPES } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/keyframe-property-editor';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import type TimelineLineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-line-view';
import type { TimelineSelectable } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-selectable';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineKeyFrame, TimelineKeyFrameType } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import { getCallbackIcon } from 'thing-editor/src/engine/utils/get-value-by-path';

const keyframesClasses = [
	'timeline-keyframe-smooth',
	'timeline-keyframe-linear',
	'timeline-keyframe-discrete',
	'timeline-keyframe-jump-floor',
	'timeline-keyframe-jump-roof'
];

const DEFAULT_GRAVITY = 1; //BOUNCE ⬆, BOUNCE ⬇ default gravity and bouncing
const DEFAULT_BOUNCING = -0.4;

const SPEED_SET_MARK = R.img({ className: 'timeline-speed-set-marker', src: '/thing-editor/img/timeline/speed-set.png' });

interface TimelineKeyframeViewProps extends ClassAttributes<TimelineKeyframeView> {
	keyFrame: TimelineKeyFrame;
	owner: TimelineLineView;

}

interface TimelineKeyframeViewState {
	isSelected: boolean;
}

export default class TimelineKeyframeView extends Component<TimelineKeyframeViewProps, TimelineKeyframeViewState> implements TimelineSelectable {

	onDraggableMouseDown: (ev: PointerEvent) => void;
	isSelected = false;

	constructor(props: TimelineKeyframeViewProps) {
		super(props);
		this.getTime = this.getTime.bind(this);
		this.setTime = this.setTime.bind(this);
		this.onKeyframeMouseDown = this.onKeyframeMouseDown.bind(this);
		this.onDraggableMouseDown = Timeline.onDraggableMouseDown.bind(this);
		props.keyFrame.___view = this;
	}

	componentDidMount() {
		Timeline._justModifiedSelectable(this);
	}

	componentWillReceiveProps(props: TimelineKeyframeViewProps) {
		let k1 = this.props.keyFrame;
		let k2 = props.keyFrame;
		if (k1.___view === this) {
			k1.___view = null;
		}
		k2.___view = this;
		if (
			k1.t !== k2.t ||
			k1.v !== k2.v ||
			k1.m !== k2.m ||
			k1.a !== k2.a ||
			k1.s !== k2.s ||
			k1.g !== k2.g ||
			k1.b !== k2.b
		) {
			Timeline._justModifiedSelectable(this);
		}
	}

	componentWillUnmount() {
		if (this.props.keyFrame.___view === this) {
			this.props.keyFrame.___view = null;
		}
		Timeline.unregisterDraggableComponent(this);
	}

	getTime() {
		const keyFrame = this.props.keyFrame;
		return keyFrame.t;
	}

	setTime(time: number) {
		assert(!isNaN(time), 'valid number expected');
		const keyFrame = this.props.keyFrame;
		if (keyFrame.t === 0) { //initial keyframe is locked for dragging
			let t = this.props.owner.props.owner.props.field.t;
			if (!t.find((k) => { return k.t === 0 && k !== keyFrame; })) { // but only if no cloned keyframe with 0 time
				return;
			}
		}
		if (keyFrame.t !== time) {
			if (keyFrame.j === keyFrame.t && !keyFrame.___keepLoopPoint) {
				keyFrame.j = time;
			}
			keyFrame.t = time;
			this.onChanged();
		}
	}

	setKeyframeType(type: TimelineKeyFrameType) {
		let keyFrame = this.props.keyFrame;
		/// #if EDITOR
		let types = getKeyframeTypesForField([this.props.owner.props.owner.props.owner.props.node], this.props.owner.props.owner.props.field.n);
		assert(types.indexOf(type) >= 0, 'Type ' + READABLE_KEYFRAME_TYPES[type] + 'is invalid for field \'' + this.props.owner.props.owner.props.field.n);
		/// #endif

		if (keyFrame.m !== type) {
			keyFrame.m = type;
			if (keyFrame.m < 3) {
				delete keyFrame.b; //BOUNCE ⬆, BOUNCE ⬇  gravity and bouncing delete
				delete keyFrame.g;
			} else {
				if (!keyFrame.hasOwnProperty('b')) {
					let fieldView = keyFrame.___view!.props.owner.props.owner;
					let fieldName = fieldView.props.field.n;
					let node = fieldView.props.owner.props.node;
					let fieldDesc = game.editor.getObjectField(node, fieldName);
					let step = fieldDesc.step || 1;

					keyFrame.b = DEFAULT_BOUNCING;
					keyFrame.g = DEFAULT_GRAVITY * step;
				}
			}
			this.onChanged();
		}
	}

	onChanged() {
		this.props.owner.props.owner.onChanged();
	}

	deleteKeyframe() {
		this.props.owner.props.owner.deleteKeyframe(this.props.keyFrame);
	}

	clone() {
		let timeLineData = this.props.owner.props.owner.props.field.t;
		let keyFrame = this.props.keyFrame;
		let cloneKeyframe = TimelineKeyframeView.cloneKeyFrame(keyFrame);
		timeLineData.push(cloneKeyframe);
	}

	static cloneKeyFrame (srcKeyFrame:TimelineKeyFrame) {
		const ret = {} as TimelineKeyFrame;
		Object.assign(ret, srcKeyFrame);
		ret.___react_id = MovieClip.__generateKeyframeId();
		return ret;
	}

	onKeyframeMouseDown(ev: PointerEvent) {
		if (ev.buttons === 2) {
			if (this.props.keyFrame.hasOwnProperty('a')) { /// 99999
				delete this.props.keyFrame.a;
				this.onChanged();
				KeyframePropertyEditor.refresh();
			} else {
				this.deleteKeyframe();
			}
			sp(ev);
		} else {
			this.onDraggableMouseDown(ev);
		}
	}

	render() {
		const keyFrame = this.props.keyFrame;

		let loopArrow;
		let randomMeter;
		let props = this.props.owner.props.owner.props;
		const field = props.field;
		const p = props.owner.props;
		const width = p.widthZoom;
		const height = p.heightZoom - 16;
		if (keyFrame.j !== keyFrame.t) {
			let len = Math.abs(keyFrame.j - keyFrame.t);
			len *= width;

			let className = 'loop-arrow';
			if (keyFrame.j > keyFrame.t) {
				className += ' loop-arrow-front';
			}
			loopArrow = R.svg({ className, height: 11, width: len },
				R.polyline({ points: '0,0 6,6 3,8 0,0 6,9 ' + (len / 2) + ',10 ' + (len - 3) + ',7 ' + len + ',0' })
			);
		}
		if (keyFrame.hasOwnProperty('r')) {
			let len = Math.abs(keyFrame.r! * width);
			randomMeter = R.svg({ className: 'keyframe-random-meter', height: 4, width: len },
				R.polyline({ points: '0,3 1,1 ' + (len - 2) + ',1 ' + (len) + ',3' })
			);
		}

		let className = 'timeline-keyframe ' + keyframesClasses[keyFrame.m];
		if (this.state && this.state.isSelected) {
			className += ' timeline-keyframe-selected';
		}

		let isUnreachable = (typeof keyFrame.v === 'number') && isNaN(MovieClip.__getValueAtTime(field, keyFrame.t) as number);
		if (isUnreachable) {
			className += ' timeline-keyframe-unreachable';
		}

		let mark;
		if (keyFrame.hasOwnProperty('a')) {
			mark = getCallbackIcon(keyFrame.a!, p.node);
		}

		return R.div({
			className: className,
			title: isUnreachable ? 'Keyframe is unreachable because of loop or "this.stop" action' : keyFrame.a,
			onMouseDown: this.onKeyframeMouseDown,
			style: { height, width: (width < 8) ? 8 : width, left: keyFrame.t * width }
		}, keyFrame.hasOwnProperty('s') ? SPEED_SET_MARK : undefined, mark, loopArrow, randomMeter
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-label-view.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import type ObjectsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/objects-timeline';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import type { TimelineSelectable } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-selectable';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineLabelData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import LabelsLogger from '../../../labels-logger';

let labelNamesProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy field`s name',
	onMouseDown: copyTextByClick
};

const labelStartMarkerProps = {
	className: 'timeline-label-pointer'
};

interface TimelineLabelViewProps extends ClassAttributes<TimelineLabelView> {
	label: TimelineLabelData;
	owner: ObjectsTimelineView;
	labelsNamesList: string[];
}

interface TimelineLabelViewState {
	isSelected?: boolean;
}

export default class TimelineLabelView extends Component<TimelineLabelViewProps, TimelineLabelViewState> implements TimelineSelectable {

	onDraggableMouseDown: (ev: PointerEvent) => void;
	isSelected = false;

	constructor(props: TimelineLabelViewProps) {
		super(props);
		this.onDoubleClick = this.onDoubleClick.bind(this);
		this.onLabelMouseDown = this.onLabelMouseDown.bind(this);
		this.onDraggableMouseDown = Timeline.onDraggableMouseDown.bind(this);
	}

	componentDidMount() {
		Timeline._justModifiedSelectable(this);
		this.props.label.___view = this;
	}

	componentWillReceiveProps(props: TimelineLabelViewProps) {

		let k1 = this.props.label;
		let k2 = props.label;
		if (k1.___view === this) {
			k1.___view = null;
		}
		k2.___view = this;

		if (this.props.label.t !== props.label.t) {
			Timeline._justModifiedSelectable(this);
		}
	}


	componentWillUnmount() {
		Timeline.unregisterDraggableComponent(this);
	}

	getTime() {
		return this.props.label.t;
	}

	setTime(time: number) {
		const label = this.props.label;

		if (label.t !== time) {
			label.t = time;
			this.onChanged();
		}
	}

	clone(newName:string) {
		this.props.owner.cloneLabel(newName, this.props.label.___name);
	}

	onChanged() {
		this.props.owner.onLabelChange(this.props.label);
	}

	deleteLabel() {
		let name = this.props.label.___name;
		Timeline.unselectComponent(this);
		let tl = this.props.owner.props.node._timelineData;
		delete tl.l[name];
		this.onChanged();
	}

	onLabelMouseDown(ev: PointerEvent) {
		if (ev.buttons === 2) {
			this.deleteLabel();
			sp(ev);
		} else {
			this.onDraggableMouseDown(ev);
		}
	}

	static reNormalizeLabel(label: TimelineLabelData, movieClip: MovieClip) { //re find keyframes for modified label
		label.n = movieClip._timelineData.f.map((fieldTimeline) => {
			return MovieClip._findNextKeyframe(fieldTimeline.t, label.t - 1);
		});
		movieClip.__invalidateSerializeCache();
	}

	static reNormalizeAllLabels(movieClip: MovieClip) {
		for (let key in movieClip._timelineData.l) {
			if (!movieClip._timelineData.l.hasOwnProperty(key)) continue;
			TimelineLabelView.reNormalizeLabel(movieClip._timelineData.l[key], movieClip);
		}
	}

	static askForLabelName(existingLabelsNames: string[], title: ComponentChild, defaultName = '', allowedDuplicateName?: string) {
		return game.editor.ui.modal.showPrompt(title, defaultName, undefined, (nameToCheck: string) => {
			if (nameToCheck === allowedDuplicateName) {
				return;
			}
			if (existingLabelsNames.includes(nameToCheck)) {
				return 'Label with that name already exists.';
			}
		}, false, false, Array.from(LabelsLogger.allLabels));
	}

	onDoubleClick(ev: PointerEvent) { //rename label by double click
		let tl = this.props.owner.props.node._timelineData;
		let label = this.props.label;
		let name = label.___name;

		TimelineLabelView.askForLabelName(this.props.labelsNamesList, name.startsWith('__') ? 'Change comment' : 'Rename label (or start with __ to turn label to a comment)', name, name).then((enteredName) => {
			if (enteredName && (name !== enteredName)) {
				tl.l[enteredName] = label;
				label.___name = enteredName;
				delete tl.l[name];
				this.onChanged();
			}
		});
		sp(ev);
	}

	render() {

		let className = 'timeline-label';
		if (this.state && this.state.isSelected) {
			className += ' timeline-label-selected';
		}

		let label = this.props.label;
		let name = this.props.label.___name;

		const isComment = name.startsWith('__');
		if (isComment) {
			className += ' timeline-label-tip';
			name = name.substring(2).trimStart();
		}

		return R.div({
			className, id: 'timeline-label-' + name.replace('.', '-').replace('#', '-'), style: { left: label.t * this.props.owner.props.widthZoom },
			onMouseDown: this.onLabelMouseDown,
			onDblClick: this.onDoubleClick
		}, R.div(labelStartMarkerProps), R.span(isComment ? undefined : labelNamesProps, name)
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-line-view.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component, h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import type FieldsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-field';
import TimelineKeyframeView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-keyframe-view';
import TimelineLoopPoint from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-loop-point';
import assert from 'thing-editor/src/engine/debug/assert';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type FieldPlayer from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import type { TimelineFieldData, TimelineKeyFrame } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

let _scale = 1;
let _shift = 0;

const scale = (val: number) => {
	//assert(!isNaN(val), 'nan');
	return (_shift - val) * _scale;
};

let widthZoom = 1;
let heightZoom = 1;

let chartsCache: WeakMap<TimelineFieldData, ComponentChild> = new WeakMap();


interface TimelineLineViewProps extends ClassAttributes<TimelineLineView> {
	owner: FieldsTimelineView;

}


export default class TimelineLineView extends Component<TimelineLineViewProps> {
	constructor(props: TimelineLineViewProps) {
		super(props);
		this.onMouseDown = this.onMouseDown.bind(this);
		this.renderKeyframe = this.renderKeyframe.bind(this);
	}

	renderKeyframe(keyFrame: TimelineKeyFrame) {
		return h(TimelineKeyframeView, { key: keyFrame.___react_id, keyFrame, owner: this });
	}

	static invalidateChartsRenderCache(field?: TimelineFieldData) {
		if (field) {
			chartsCache.delete(field);
		} else {
			chartsCache = new WeakMap();
		}
	}

	onMouseDown(ev: PointerEvent) {
		if (ev.buttons === 2 && !(ev.ctrlKey || ev.metaKey)) {
			this.props.owner.toggleKeyframe(Timeline.mouseEventToTime(ev));
		}
	}

	render() {
		widthZoom = this.props.owner.props.owner.props.widthZoom;
		heightZoom = this.props.owner.props.owner.props.heightZoom;
		const ownerProps = this.props.owner.props;
		let field = ownerProps.field;

		let lastKeyframe = field.t[field.t.length - 1];
		assert(lastKeyframe, 'Animated field with no keyframes detected.', 90001);
		let width = Math.max(lastKeyframe.t, lastKeyframe.j);

		width += 3300;
		width *= widthZoom;
		let height = heightZoom;

		MovieClip.__getValueAtTime(field, lastKeyframe.t); //cache timeline's values
		_scale = field.___cacheTimeline!.max - field.___cacheTimeline!.min;
		if (_scale === 0) {
			_scale = 1;
		}
		_scale = (heightZoom - 10) / _scale;
		_shift = field.___cacheTimeline!.max + 1 / _scale;

		if (!chartsCache.has(field)) {
			if (isNaN(field.___cacheTimeline!.max)) {
				chartsCache.set(field, R.span());
			} else {
				let currentPoints: number[] = [];
				const lines = [currentPoints];
				const values = field.___cacheTimeline!;
				for (let i = 0; i < values!.length; i++) {
					if (isNaN(values[i])) {
						if (currentPoints.length) {
							currentPoints = [];
							lines.push(currentPoints);
						}
					} else {
						if (field.___discretePositionsCache![i] && i > 0) {
							if ((i - 1) in values) {
								currentPoints.push(i * widthZoom, scale(values[i - 1]));
							}
						}
						currentPoints.push(i * widthZoom, scale(values[i]));
					}
				}
				chartsCache.set(field,
					R.svg({ className: 'timeline-chart', height, width },
						lines.map(points => R.polyline({ points: points.join(' ') }))
					)
				);
			}
		}

		let keyframes = [];
		let loopPoints = [];

		for (let k of field.t) {
			keyframes.push(this.renderKeyframe(k));
			if (k.t !== k.j || k.___keepLoopPoint) {
				loopPoints.push(
					h(TimelineLoopPoint, { key: k.___react_id, owner: this, keyFrame: k, widthZoom })
				);
			}
		}


		return R.div(
			{
				style: { width, height }, onMouseDown: this.onMouseDown
			},
			keyframes,
			loopPoints,
			chartsCache.get(field),
			h(PlayingDisplay, this.props)
		);
	}
}

class PlayingDisplay extends Component<TimelineLineViewProps> {

	interval!: number;
	fieldPlayer!: FieldPlayer;
	renderedTime = -1;

	componentDidMount() {
		this.interval = window.setInterval(this.update.bind(this), 35);
	}

	componentWillUnmount() {
		clearInterval(this.interval);
	}

	update() {
		let fieldPlayer = this.props.owner.props.owner.props.node.fieldPlayers[this.props.owner.props.fieldIndex];
		this.fieldPlayer = fieldPlayer;
		if (fieldPlayer && fieldPlayer.time !== this.renderedTime) {
			this.renderedTime = fieldPlayer.time;
			this.forceUpdate();
		}
	}

	render() {
		if (!this.fieldPlayer || typeof this.fieldPlayer.__processedTime === 'undefined') {
			return R.div();
		} else {
			let firedFrame;
			if (this.fieldPlayer.__lastFiredKeyframe) {
				firedFrame = R.div({ className: 'timeline-fire-indicator', style: { left: this.fieldPlayer.__lastFiredKeyframe.t * widthZoom } });
			}
			return R.fragment(
				R.div({ className: 'timeline-play-indicator', style: { left: (this.fieldPlayer.__processedTime) * widthZoom } }),
				firedFrame
			);
		}

	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-loop-point.ts">
import type { ClassAttributes } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import type TimelineLineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-line-view';
import type { TimelineSelectable } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-selectable';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import type { TimelineKeyFrame } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';


interface TimelineLoopPointProps extends ClassAttributes<TimelineLoopPoint> {
	keyFrame: TimelineKeyFrame;
	owner: TimelineLineView;
	widthZoom: number;
}

interface TimelineLoopPointState {
	isSelected: boolean;
}

export default class TimelineLoopPoint extends Component<TimelineLoopPointProps, TimelineLoopPointState> implements TimelineSelectable {

	onDraggableMouseDown: (ev: PointerEvent) => void;
	isSelected = false;

	constructor(props: TimelineLoopPointProps) {
		super(props);
		this.onLoopPointMouseDown = this.onLoopPointMouseDown.bind(this);
		this.onDraggableMouseDown = Timeline.onDraggableMouseDown.bind(this);
	}

	componentDidMount() {
		Timeline._justModifiedSelectable(this);
		this.props.keyFrame.___loopPointView = this;
	}

	componentWillReceiveProps(props: TimelineLoopPointProps) {
		let t1 = this.props.keyFrame;
		let t2 = props.keyFrame;
		if (t1 !== t2) {
			delete t1.___loopPointView;
			t2.___loopPointView = this;
			Timeline._justModifiedSelectable(this);
		}
	}

	getTime() {
		const keyFrame = this.props.keyFrame;
		return keyFrame.j;
	}

	setTime(time: number) {
		const keyFrame = this.props.keyFrame;
		if (keyFrame.j !== time) {
			keyFrame.j = time;
			this.onChanged();
		}
	}

	onLoopPointMouseDown(ev: PointerEvent) {
		if (ev.buttons === 2) {
			this.deleteLoopPoint();
			sp(ev);
		} else {
			this.onDraggableMouseDown(ev);
		}
	}

	deleteLoopPoint() {
		Timeline.unselectComponent(this);
		let keyFrame = this.props.keyFrame;
		delete keyFrame.___keepLoopPoint;
		delete keyFrame.___loopPointView;
		keyFrame.j = keyFrame.t;
		this.onChanged();
		this.props.owner.forceUpdate();
	}

	onChanged() {
		this.props.owner.props.owner.onChanged();
	}

	componentWillUnmount() {
		delete this.props.keyFrame.___loopPointView;
		Timeline.unregisterDraggableComponent(this);
	}

	render() {
		let width = this.props.widthZoom;
		let keyFrame = this.props.keyFrame;

		let className = 'timeline-loop-point';
		if (this.state && this.state.isSelected) {
			className += ' timeline-loop-point-selected';
		}
		else if (keyFrame.___view!.state && keyFrame.___view!.state.isSelected) {
			className += ' timeline-loop-point-owner-selected';
		}

		let w = (width < 8) ? 8 : width;
		let l = keyFrame.j * width;
		if (keyFrame.j > keyFrame.t) {
			l = l - w;
		}
		return R.div({
			className: className,
			title: 'Loop point',
			onMouseDown: this.onLoopPointMouseDown,
			style: { width: w, left: l }
		},
		);
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-select-frame.ts">
import type { ClassAttributes } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import Window from 'thing-editor/src/editor/ui/editor-window';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import game from 'thing-editor/src/engine/game';

let timelineRect: DOMRect;
let isDragging = false;

let x = 0;
let y = 0;
let w = 0;
let h = 0;

let isFullHeightDrag = false;

export default class TimelineSelectFrame extends Component<ClassAttributes<TimelineSelectFrame>> {

	onMouseDown(ev: MouseEvent, _isFullHeightDrag = false) {
		timelineRect = Timeline.timelineDOMElement!.getBoundingClientRect();
		isDragging = true;
		let s = Window.all.timeline.renderedScale;
		x = (ev.clientX - timelineRect.x) / s;
		isFullHeightDrag = _isFullHeightDrag; /// 99999 shift + timeHeader drag selects all height
		y = isFullHeightDrag ? 0 : ((ev.clientY - timelineRect.y) / s);
		w = 0;
		h = 0;
		this.forceUpdate();
	}

	onMouseMove(ev: MouseEvent) {
		if (isDragging) {
			let s = Window.all.timeline.renderedScale;
			w = (ev.clientX - timelineRect.x) / s - x;
			h = isFullHeightDrag ? 40000 : ((ev.clientY - timelineRect.y) / s - y);
			this.forceUpdate();
		}
	}

	cancelSelection() {
		if (isDragging) {
			isDragging = false;
			this.forceUpdate();
		}
	}

	getRectAndFinishDragging() {
		if (isDragging) {
			isDragging = false;

			let a = document.querySelector('.timeline-select-frame');
			if (!a) {
				return;
			}
			let ret = a.getBoundingClientRect();
			this.forceUpdate();
			if (isFullHeightDrag) {
				ret.height = Number.MAX_SAFE_INTEGER;
			}
			return ret;
		}
	}

	render() {
		if (isDragging) {
			return R.div({
				className: game.__EDITOR_mode ? 'timeline-select-frame' : 'timeline-select-frame disabled',
				style: {
					left: (w >= 0) ? x : x + w,
					top: (h >= 0) ? y : y + h,
					width: Math.abs(w),
					height: Math.abs(h)
				}
			});
		}
		return R.span();
	}
}
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline-selectable.ts">
interface TimelineSelectable {
	onDraggableMouseDown: (ev: PointerEvent) => void;
	getTime(): number;
	setTime(time: number): void;
}

export type { TimelineSelectable };
</file>

<file path="src/editor/ui/props-editor/props-editors/timeline/timeline.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes } from 'preact';
import { h } from 'preact';

import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Window from 'thing-editor/src/editor/ui/editor-window';
import { getDefaultKeyframeTypeForField } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/get-keyframe-types-for-field';
import KeyframePropertyEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/keyframe-property-editor';
import ObjectsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/objects-timeline';
import TimeMarker from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/time-marker';
import TimelineKeyframeView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-keyframe-view';
import TimelineLabelView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-label-view';
import TimelineLineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-line-view';
import TimelineLoopPoint from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-loop-point';
import TimelineSelectFrame from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-select-frame';
import type { TimelineSelectable } from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-selectable';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import increaseNumberInName from 'thing-editor/src/editor/utils/increase-number-in-name';
import { scrollInToView } from 'thing-editor/src/editor/utils/scroll-in-view';
import shakeDomElement from 'thing-editor/src/editor/utils/shake-element';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineFieldData, TimelineKeyFrame, TimelineLabelData, TimelineSerializedKeyFrame, TimelineSerializedLabelsData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

interface TimelineCopyPasteData {
	fields: KeyedMap<TimelineSerializedKeyFrame[]>;
	labels: KeyedMap<number>;
	p: number;
	d: number;
}

let widthZoom = 1;
let heightZoom = 1;

let timeMarker: TimeMarker;
function timeMarkerRef(ref: TimeMarker | null) {
	timeMarker = ref!;
}

let selectionFrame: TimelineSelectFrame;

function selectionFrameRef(ref: TimelineSelectFrame | null) {
	selectionFrame = ref!;
}

let fieldLabelTimelineProps = { className: 'timeline-settings objects-timeline-labels timeline-fixed-block' };

const buttonsGroupProps = { className: 'timeline-buttons-group' };


let beforeChangeValueRemember: WeakMap<MovieClip, number>;

let isTimeDragging = false;

let recordingIsDisabled = false;

let timelineInstance!: Timeline;

const justModifiedKeyframes: Set<TimelineSelectable> = new Set();

const selectedComponents: TimelineSelectable[] = [];

function clearSelection() {
	while (selectedComponents.length > 0) {
		unselect(selectedComponents[selectedComponents.length - 1]);
	}
}

function select(component: TimelineSelectable) {
	let k = (component as TimelineKeyframeView).props.keyFrame;
	if (k) {
		k.___keepLoopPoint = (k.t !== k.j);
	}
	assert(selectedComponents.indexOf(component) < 0, 'Component already selected');
	(component as TimelineKeyframeView).setState({ isSelected: true });
	selectedComponents.push(component);
	KeyframePropertyEditor.refresh();
}

function unselect(component: TimelineSelectable) {
	let k = (component as TimelineKeyframeView).props.keyFrame;
	if (k) {
		delete k.___keepLoopPoint;
	}
	let i = selectedComponents.indexOf(component);
	assert(i >= 0, 'Component is not selected');
	(component as TimelineKeyframeView).setState({ isSelected: false });
	selectedComponents.splice(i, 1);
	KeyframePropertyEditor.refresh();
}


interface TimelineProps extends ClassAttributes<Timeline> {
	onCloseClick: () => void;
}

interface TimelineState {
	widthZoom: number;
	heightZoom: number;
}

export default class Timeline extends ComponentDebounced<TimelineProps, TimelineState> {
	constructor(props: TimelineProps) {
		super(props);


		heightZoom = game.editor.settings.getItem('timeline-height-zoom', 41);
		widthZoom = game.editor.settings.getItem('timeline-width-zoom', 3);
		this.state = {
			heightZoom,
			widthZoom
		};
		this.deleteSelectedKeyframes = this.deleteSelectedKeyframes.bind(this);
		this.prevKeyFrame = this.prevKeyFrame.bind(this);
		this.nextKeyFrame = this.nextKeyFrame.bind(this);
		this.prevFrame = this.prevFrame.bind(this);
		this.nextFrame = this.nextFrame.bind(this);
		this.renderObjectsTimeline = this.renderObjectsTimeline.bind(this);
		this.onMouseDown = this.onMouseDown.bind(this);
		this.onMouseMove = this.onMouseMove.bind(this);
		this.onMouseUp = this.onMouseUp.bind(this);
		this.verticalZoomIn = this.verticalZoomIn.bind(this);
		this.verticalZoomOut = this.verticalZoomOut.bind(this);
		this._afterHistoryJump = this._afterHistoryJump.bind(this);
		this.horizontalZoomIn = this.horizontalZoomIn.bind(this);
		this.horizontalZoomOut = this.horizontalZoomOut.bind(this);
	}

	static get isElementsSelected() {
		return selectedComponents.length > 0;
	}

	static get isPasteAvailable() {
		return game.editor.settings.getItem('__EDITOR-clipboard-data-timeline-name');
	}

	static copySelection() {
		let keyframesCount = 0;
		let labels: TimelineSerializedLabelsData = {};
		let fields: KeyedMap<TimelineSerializedKeyFrame[]> = {};
		let fieldsByName: KeyedMap<KeyedMap<TimelineSerializedKeyFrame>[]> = {};

		selectedComponents.forEach((c) => {
			if (c instanceof TimelineKeyframeView) {
				let k: KeyedObject = {};
				for (let name in c.props.keyFrame) {
					if ((name.length === 1) && (name !== 'n')) {
						k[name] = (c.props.keyFrame as KeyedObject)[name];
					}
				}
				keyframesCount++;
				let fieldName = c.props.owner.props.owner.props.field.n;
				fieldsByName[fieldName] = fieldsByName[fieldName] || [];

				fieldsByName[fieldName].push(k);
			} else if (c instanceof TimelineLabelView) {
				labels[c.props.label.___name] = c.props.label.t;
			}
		});
		for (let name in fieldsByName) {
			fields[name] = fieldsByName[name];
		}

		const labelsList = Object.keys(labels);
		if ((labelsList.length > 0) || (keyframesCount > 0)) {
			let bufferData: TimelineCopyPasteData = {
				fields,
				labels,
				p: (game.editor.selection[0] as MovieClip)._timelineData.p,
				d: (game.editor.selection[0] as MovieClip)._timelineData.d
			};
			game.editor.settings.setItem('__EDITOR-clipboard-data-timeline', bufferData);
			let name = '';
			if (keyframesCount) {
				name += 'Keyframes: ' + keyframesCount;
			}
			if (labelsList.length) {
				if (name) {
					name += '\n';
				}
				name += 'Labels: ' + labelsList.length;
			}
			game.editor.settings.removeItem('__EDITOR-clipboard-data');
			game.editor.settings.setItem('__EDITOR-clipboard-data-timeline-name', 'Paste: \n' + name + '\n');
			game.editor.ui.modal.notify('Copied: ' + name);
			game.editor.refreshTreeViewAndPropertyEditor();
		}
	}

	static pasteSelection() {
		let data: TimelineCopyPasteData = game.editor.settings.getItem('__EDITOR-clipboard-data-timeline');
		if (data) {
			let allKeyframesToSelect: TimelineKeyFrame[] = [];
			for (let o of game.editor.selection as any as MovieClip[]) {

				if (!o._timelineData) {
					o._timelineData = { l: {}, f: [], p: data.p, d: data.d };
				}
				let tl = o._timelineData;

				for (let labelName in data.labels) {
					let labelTime = data.labels[labelName];
					if (!tl.l[labelName]) {
						let l = { t: labelTime, ___name: labelName } as TimelineLabelData;
						tl.l[labelName] = l;
					} else {
						game.editor.ui.status.warn('Could not paste label "' + labelName + '". Already exists.', 99999, o, 'timeline');
					}
					allKeyframesToSelect.push(tl.l[labelName] as any as TimelineKeyFrame);
				}
				for (let fieldName in data.fields) {
					const keyframes = data.fields[fieldName];
					getFrameAtTimeOrCreate(o, fieldName, 0);
					for (let keyframeData of keyframes) {
						let k = getFrameAtTimeOrCreate(o, fieldName, keyframeData.t!, true);
						Object.assign(k, keyframeData);
						allKeyframesToSelect.push(k as TimelineKeyFrame);
					}
				}
				TimelineLabelView.reNormalizeAllLabels(o);
				Timeline.allFieldDataChanged(o);
			}
			timelineInstance.refresh(() => {
				clearSelection();
				allKeyframesToSelect.forEach((kf) => {
					select(kf.___view!);
				});
			});
			game.editor.sceneModified();
		}
	}

	static unselectKeyframe(keyframe: TimelineKeyFrame) {
		for (let c of selectedComponents as TimelineKeyframeView[]) {
			if (c.props.keyFrame === keyframe) {
				unselect(c);
				return;
			}
		}
	}

	static unselectComponent(loopPointView: TimelineSelectable) {
		if (selectedComponents.indexOf(loopPointView) >= 0) {
			unselect(loopPointView);
		}
	}

	selectKeyframe(kf: TimelineKeyFrame) {
		clearSelection();
		select(kf.___view!);
		this.setTime(kf.t, true);
	}

	componentDidMount() {
		clearSelection();
		Timeline.timelineDOMElement = document.querySelector('.timeline');
		timelineInstance = this;
		window.addEventListener('mousemove', this.onMouseMove);
		window.addEventListener('mouseup', this.onMouseUp);
		game.editor.history.events.on('beforeHistoryJump', this._beforeHistoryJump);
		game.editor.history.events.on('afterHistoryJump', this._afterHistoryJump);
		this._syncOtherMovieClips(this.getTime());
	}

	static deselectMovieClip(o: MovieClip) {
		for (let i = selectedComponents.length - 1; i >= 0; i--) {
			let c = selectedComponents[i];
			if (c instanceof TimelineKeyframeView) {
				if (c.props.owner.props.owner.props.owner.props.node === o) {
					unselect(c);
				}
			}
		}
	}

	componentWillReceiveProps() {
		this._syncOtherMovieClips(this.getTime());
	}

	static timelineDOMElement: HTMLDivElement | null = null;

	componentWillUnmount() {
		Timeline.timelineDOMElement = null;
		timelineInstance = null!;
		game.editor.history.events.off('beforeHistoryJump', this._beforeHistoryJump);
		game.editor.history.events.off('afterHistoryJump', this._afterHistoryJump);
		window.removeEventListener('mousemove', this.onMouseMove);
		window.removeEventListener('mouseup', this.onMouseUp);
	}

	verticalZoomIn() {
		this.verticalZoom(1.5);
	}

	verticalZoomOut() {
		this.verticalZoom(0.66666666);
	}

	deleteSelectedKeyframes() {
		let i = selectedComponents.length - 1;
		if (i < 0) {
			return;
		}
		while (i >= 0) {
			let c = selectedComponents[i];
			if (c instanceof TimelineKeyframeView) {
				c.props.owner.props.owner.deleteKeyframe(c.props.keyFrame);
			} else if (c instanceof TimelineLabelView) {
				c.deleteLabel();
			} else if (c instanceof TimelineLoopPoint) {
				c.deleteLoopPoint();
			}
			i--;
		}
		this.refresh();
	}

	verticalZoom(delta: number) {

		heightZoom = this.state.heightZoom;
		let tmp = heightZoom;

		heightZoom *= delta;
		if (heightZoom < 18) {
			heightZoom = 18;
		} else if (heightZoom > 135) {
			heightZoom = 135;
		}
		if (tmp !== heightZoom) {
			heightZoom = Math.round(heightZoom);
			game.editor.settings.setItem('timeline-height-zoom', heightZoom);
			TimelineLineView.invalidateChartsRenderCache();
			this.setState({ heightZoom });
			this.centralizeSelection();
		}
	}

	horizontalZoomIn() {
		this.horizontalZoom(1.5);
	}

	horizontalZoomOut() {
		this.horizontalZoom(0.66666666);
	}

	horizontalZoom(delta: number) {
		widthZoom = this.state.widthZoom;
		let tmp = widthZoom;
		widthZoom *= delta;
		if (widthZoom < 0.5) {
			widthZoom = 0.5;
		} else if (widthZoom > 28.5) {
			widthZoom = 28.5;
		}
		if (tmp !== widthZoom) {
			game.editor.settings.setItem('timeline-width-zoom', widthZoom);
			if (widthZoom < 1.00001) {
				widthZoom = Math.round(widthZoom * 20) / 20.0;
			} else {
				widthZoom = Math.round(widthZoom);
			}
			TimelineLineView.invalidateChartsRenderCache();
			this.setState({ widthZoom });
			this.centralizeSelection();
		}
	}

	centralizeSelection() {
		window.setTimeout(() => {
			if (selectedComponents.length > 0) {
				timeMarker.scrollInToView(selectedComponents[0].getTime());
			}
		}, 0);
	}

	nextKeyFrame() {
		let time = this.getTime();
		let allKeyframes = this._getAllKeyframes();
		for (let k of allKeyframes) {
			if (k.t > time) {
				this.selectKeyframe(k);
				return;
			}
		}
		this.selectKeyframe(allKeyframes[0]);
	}

	_getAllKeyframes() {
		let allKeyframes: TimelineKeyFrame[] = [];
		for (let m of game.editor.selection) {
			if (m instanceof MovieClip && m._timelineData) {
				for (let f of m._timelineData.f) {
					allKeyframes = allKeyframes.concat(f.t);
				}
			}
		}
		allKeyframes.sort(sortFieldsByTime);
		return allKeyframes;
	}

	prevKeyFrame() {
		let time = this.getTime();
		let allKeyframes = this._getAllKeyframes();
		if (allKeyframes.length > 0) {
			if (time === 0) {
				this.selectKeyframe(allKeyframes[allKeyframes.length - 1]);
			} else {
				let reClosestKeyframe = allKeyframes[0];
				for (let k of allKeyframes) {
					if (k.t >= time) {
						this.selectKeyframe(reClosestKeyframe);
						return;
					}
					reClosestKeyframe = k;
				}
			}
		}
	}

	prevFrame() {
		this.setTime(Math.max(0, this.getTime() - 1), true);
	}

	nextFrame() {
		this.setTime(this.getTime() + 1, true);
	}

	renderObjectsTimeline(node: MovieClip) {
		let key = node.___id;
		if (node instanceof MovieClip) {
			return h(ObjectsTimelineView, {
				owner: this, node, key,
				heightZoom,
				widthZoom
			});
		} else {
			return R.div({ key });
		}
	}

	getTime() {
		return timeMarker.state.time;
	}

	setTime(time: number, scrollInToView = false) {
		timeMarker.setTime(time, scrollInToView);
		this._syncOtherMovieClips(time);
		game.editor.refreshPropsEditor();
	}

	_syncOtherMovieClips(time: number) {
		let movieClips: MovieClip[] = game.editor.selection as any as MovieClip[];

		if (!game.__EDITOR_mode || !(movieClips[0])._timelineData) {
			return;
		}

		this.applyCurrentTimeValuesToFields(movieClips, time);

		// apply same animation state to all movieClips around
		let nextLeftLabel;
		let nextLeftLabelName;

		for (let labelName in movieClips[0]._timelineData.l) {
			let label = movieClips[0]._timelineData.l[labelName];
			if ((label.t <= time) && (!nextLeftLabel || nextLeftLabel.t < label.t)) {
				nextLeftLabel = label;
				nextLeftLabelName = labelName;
			}
		}
		if (nextLeftLabel && game.currentContainer) {
			let labelShift = time - nextLeftLabel.t;
			let a = game.currentContainer.findChildrenByType(MovieClip);
			if (game.currentContainer instanceof MovieClip) {
				a.push(game.currentContainer);
			}
			for (let m of a) {
				if (!m.__nodeExtendData.isSelected) {
					if (m.hasLabel(nextLeftLabelName as string)) {
						let time = m._timelineData.l[nextLeftLabelName as string].t + labelShift;
						m.__applyCurrentTimeValuesToFields(time);
					} else {
						m.resetTimeline();
					}
				}
			}
		}
	}

	applyCurrentTimeValuesToFields(nodes: MovieClip[], time?: number) {
		if (game.__EDITOR_mode) {
			if (time === undefined) {
				time = this.getTime();
			}
			nodes.forEach((o) => {
				o.__applyCurrentTimeValuesToFields(time!);
			});
		}
	}

	startTimeDragging() {
		isTimeDragging = true;

	}

	render() {
		return R.fragment(
			(selectedComponents.length > 0) ? R.btn('', this.deleteSelectedKeyframes, undefined, 'hidden', { key: 'Delete' }) : undefined,
			R.btn('×', this.props.onCloseClick, 'Hide timeline', 'close-window-btn', {key: 'Escape'}),
			R.div(
				{
					onScroll: onTimelineScroll,
					onMouseDown: this.onMouseDown,
					className: 'timeline'
				},
				R.div(fieldLabelTimelineProps,
					R.span(buttonsGroupProps,
						'\u00A0↕',
						R.btn('-', this.verticalZoomOut, 'Vertical Zoom Out'),
						R.btn('+', this.verticalZoomIn, 'Vertical Zoom In')
					),
					R.span(buttonsGroupProps,
						' ↔',
						R.btn('-', this.horizontalZoomOut, 'Horizontal Zoom Out', undefined, { key: 'Minus', ctrlKey: true }),
						R.btn('+', this.horizontalZoomIn, 'Horizontal Zoom In', undefined, { key: 'Equal', ctrlKey: true })
					),
					R.span(buttonsGroupProps,
						R.btn('copy', Timeline.copySelection, 'Copy selected keyframes and labels', undefined, { key: 'c', ctrlKey: true }, !Timeline.isElementsSelected),
						R.btn('paste', Timeline.pasteSelection, Timeline.isPasteAvailable + '', undefined, { key: 'v', ctrlKey: true }, !Timeline.isPasteAvailable)
					)
				),
				h(TimeMarker, {
					owner: this,
					ref: timeMarkerRef
				}),
				(game.editor.selection as any as MovieClip[]).map(this.renderObjectsTimeline),
				R.div({ className: 'timeline-fixed-block timeline-labels-background' })
			),
			h(KeyframePropertyEditor, {
				owner: this,
				keyframesGetter: getSelectedKeyframes
			}),
			h(TimelineSelectFrame, {
				ref: selectionFrameRef
			}),
			R.span(
				{
					style: {
						display: 'none'
					}
				},
				R.btn('<', this.prevFrame, undefined, undefined, { key: 'Comma' }),
				R.btn('>', this.nextFrame, undefined, undefined, { key: 'Period' }),
				R.btn('<<', this.prevKeyFrame, undefined, undefined, { key: 'Comma', ctrlKey: true }),
				R.btn('>>', this.nextKeyFrame, undefined, undefined, { key: 'Period', ctrlKey: true })
			)
		);
	}

	onMouseUp(ev: MouseEvent) {
		isTimeDragging = false;
		if (draggingComponent) {
			if (reduceRepeatingKeyframesInSelected()) {
				this.refresh();
			}
			if ((ev.clientX > 0) && !(ev.ctrlKey || ev.metaKey) && (Math.abs(draggingStartX - ev.clientX) < 2)) {
				if (selectedComponents.length > 1) {
					clearSelection();
					select(draggingComponent);
				}

			}
			draggingXShift = 0;
			draggingComponent = null;
		} else {
			let selectedRect = selectionFrame.getRectAndFinishDragging();
			if (selectedRect) {
				selectElementsInRectangle(selectedRect, ev.shiftKey);
			}
		}
	}

	onMouseDown(ev: MouseEvent) {
		isDragging = true;
		this.onMouseMove(ev);

		if (!draggingComponent && !(ev.ctrlKey || ev.metaKey) && (!isTimeDragging || ev.shiftKey)) {
			selectionFrame.onMouseDown(ev, isTimeDragging && ev.shiftKey);
		}
	}

	onMouseMove(ev: MouseEvent) {
		if (!Window.all.timeline) {
			return;
		}
		if (Math.abs(draggingStartX - ev.clientX) > 20) {
			draggingStartX = -10000;
		}

		isDragging = isDragging && ev.buttons > 0;

		let time = Timeline.mouseEventToTime(ev);
		if (isDragging) {
			if (draggingComponent) {
				if (ev.buttons === 1) {
					let delta = time - prevDragTime;
					if (delta !== 0) {
						for (let c of selectedComponents) {
							let t = c.getTime();
							delta = Math.max(0, t + delta) - t;
							if (delta === 0) {
								return;
							}
						}
						for (let c of selectedComponents) {
							c.setTime(c.getTime() + delta);
						}

						prevDragTime += delta;
					}
					this.setTime(prevDragTime, true);
				}
			} else {
				if (ev.ctrlKey || ev.metaKey) {
					for (let c of selectedComponents) {
						if (c instanceof TimelineKeyframeView || c instanceof TimelineLoopPoint) {
							let kf = c.props.keyFrame;
							if (kf.j !== time) {
								kf.j = time;
								c.onChanged();
								c.props.owner.forceUpdate();
								KeyframePropertyEditor.refresh();
							}
						}
					}
				}
			}
		}
		if (isTimeDragging) {
			this.setTime(time);
		}
		selectionFrame.onMouseMove(ev);
	}

	static unregisterDraggableComponent(component: TimelineSelectable) {
		let i = selectedComponents.indexOf(component);
		if (i >= 0) {
			selectedComponents.splice(i, 1);
		}
	}

	static allFieldDataChanged(movieClip: MovieClip) {
		for (let f of movieClip._timelineData.f) {
			Timeline.fieldDataChanged(f, movieClip);
		}
		Timeline._invalidateNodeCache(movieClip);
	}

	static fieldDataChanged(fieldData: TimelineFieldData, node: MovieClip) { //invalidate cache
		assert(node instanceof MovieClip, 'Movieclip expected');
		assert(node._timelineData.f.indexOf(fieldData) >= 0, 'field data is not beyond this movieclip.');
		let timeLineData = fieldData.t;

		timeLineData.sort(sortFieldsByTime);
		for (let field of timeLineData) {
			field.n = MovieClip._findNextKeyframe(timeLineData, field.j);
		}

		fieldData.___cacheTimeline = undefined;
		TimelineLineView.invalidateChartsRenderCache(fieldData);
		Timeline._invalidateNodeCache(node);
	}

	static _invalidateNodeCache(node: MovieClip) {
		node.__invalidateSerializeCache();
		TimelineLabelView.reNormalizeAllLabels(node);
		game.editor.sceneModified();
	}

	static _justModifiedSelectable(keyFrame: TimelineSelectable) {
		justModifiedKeyframes.add(keyFrame);
	}

	_beforeHistoryJump() {
		justModifiedKeyframes.clear();
	}

	_afterHistoryJump() {
		window.setTimeout(() => {
			let v = Array.from(justModifiedKeyframes.values());
			if (v.length > 0) {
				clearSelection();
				for (let c of v) {
					select(c);
				}
				if (timeMarker) {
					this.setTime(v[0].getTime(), true);
				}
			}
		}, 2);
	}

	static onBeforePropertyChanged(o: Container, fieldName: string, _field: EditablePropertyDesc, _val: any, _isDelta?: boolean) {
		if ((!Timeline.timelineDOMElement) || recordingIsDisabled) {
			beforeChangeValueRemember = new WeakMap();
		}

		if (o instanceof MovieClip) {
			if (Timeline.timelineDOMElement && !recordingIsDisabled) {
				if (timelineInstance.isNeedAnimateProperty(o, fieldName)) {
					getFrameAtTimeOrCreate(o, fieldName, 0);
				}
			} else {
				let editableField = game.editor.getObjectField(o, fieldName);

				if (editableField.type === 'number') {
					beforeChangeValueRemember.set(o, (o as KeyedObject)[fieldName]);
				} else if (game.__EDITOR_mode && getFieldByName(o, fieldName)) {
					game.editor.ui.modal.showInfo('Could not change \'' + fieldName + '\' field`s  value, because \'' + fieldName + '\' field is animated and it`s type is not numeric', 'Could not change \'' + fieldName + '\' value', 30016);
				}
			}
		}
	}

	static onAfterPropertyChanged(o: Container, fieldName: string, field: EditablePropertyDesc, val: any, isDelta?: boolean) {

		if (o instanceof MovieClip) {
			if (Timeline.timelineDOMElement && !recordingIsDisabled) {
				if (timelineInstance.isNeedAnimateProperty(o, fieldName)) {
					timelineInstance.createKeyframeWithCurrentObjectsValue(o, fieldName, undefined, isDelta, val);
				}
			} else { //shift all keyframes instead of add keyframe
				let editableField = game.editor.getObjectField(o, fieldName);
				if (editableField.type === 'number') {
					let val = (o as KeyedObject)[fieldName];
					let oldVal = beforeChangeValueRemember.get(o) as number;
					if (oldVal !== val) {
						let delta = val - oldVal;
						let fld = getFieldByName(o, fieldName);
						if (fld) {
							for (let kf of fld.t) {
								let changedVal = (kf.v as number) + delta;
								if (field.hasOwnProperty('min')) {
									changedVal = Math.max(field.min!, changedVal);
								}
								if (field.hasOwnProperty('max')) {
									changedVal = Math.min(field.max!, changedVal);
								}
								kf.v = changedVal;
							}
							Timeline.fieldDataChanged(fld, o);
						}
					}
				}
				if (game.__EDITOR_mode) {
					o.resetTimeline();
				}
			}
		}

		if (timelineInstance) {
			timelineInstance.refresh();
		}
	}

	isNeedAnimateProperty(o: MovieClip, fieldName: string) {
		return (this.getTime() > 0 && game.editor.getObjectField(o, fieldName).animate) ||
			getFieldByName(o, fieldName);
	}

	static disableRecording() {
		recordingIsDisabled = true;
	}

	static enableRecording() {
		recordingIsDisabled = false;
	}

	createKeyframeWithCurrentObjectsValue(o: MovieClip, fieldName: string, time?: number, isDelta = false, deltaValue?: number) {
		let keyFrame = getFrameAtTimeOrCreate(o, fieldName, time || this.getTime());
		if (isDelta && !getFrameAtTimeOrCreateReturnedNewKeyframe) {
			let editableField = game.editor.getObjectField(o, fieldName);
			let step = editableField.step || 1;
			keyFrame.v = Math.round(((keyFrame.v as number) + deltaValue!) / step) * step;

		} else {
			keyFrame.v = (o as KeyedObject)[fieldName];
		}
		let field = getFieldByNameOrCreate(o, fieldName);
		Timeline.fieldDataChanged(field, o);
		if (isDelta && keyFrame.___view) {
			let timelineVal = MovieClip.__getValueAtTime(field, keyFrame.t) as number;
			if (!isNaN(timelineVal)) {
				(o as KeyedObject)[fieldName] = timelineVal;
			}
		}
	}

	static mouseEventToTime(ev: MouseEvent) {
		let tl = Timeline.timelineDOMElement as HTMLDivElement;
		let b = tl.getBoundingClientRect();
		let s = Window.all.timeline.renderedScale;

		let x = ev.clientX - 110 * s - b.x - draggingXShift;
		return Math.max(0, Math.round((x + tl.scrollLeft * s) / widthZoom / s));
	}

	static onAutoSelect(selectPath: string[]) {
		for (let o of game.editor.selection as any as MovieClip[]) {
			if (o._timelineData) {
				if (selectPath[2]) { // select label or keyframe.
					if (!selectPath[1]) { //label
						clearSelection();
						select(o._timelineData.l[selectPath[2]].___view!);
						getWindowElement('#timeline-label-' + selectPath[2].replace('.', '-').replace('#', '-')).then((labelView: HTMLDivElement) => {
							scrollInToView(labelView);
							shakeDomElement(labelView);
						});
						return;
					} else {
						for (let f of o._timelineData.f) {
							if (f.n === selectPath[1]) {
								let time = parseInt(selectPath[2]);
								for (let kf of f.t) {
									if (kf.t == time) {
										if (!kf.___view!.state || !kf.___view!.state.isSelected) {
											clearSelection();
											select(kf.___view!);
											let kfNode = kf.___view!.base as HTMLDivElement;
											if (kfNode) {
												scrollInToView(kfNode);
												shakeDomElement(kfNode);
											}
											timelineInstance.refresh();
										}

										getWindowElement('.bottom-panel').then((w) => {
											let actionEditField = w.querySelector('.props-editor-callback') as HTMLDivElement;
											shakeDomElement(actionEditField);
										});

										return;
									}
								}
							}
						}
					}
				} else { //select timeline property. Shake whole timeline window.
					shakeDomElement(window.document.querySelector('#timeline') as HTMLDivElement);
				}
			}
		}
	}

	static onDraggableMouseDown(this: TimelineSelectable, ev: PointerEvent) {
		draggingStartX = ev.clientX;
		game.editor.blurPropsInputs();
		if (!(this as TimelineKeyframeView).state || !(this as TimelineKeyframeView).state.isSelected) {
			if (!(ev.ctrlKey || ev.metaKey) && !ev.shiftKey) {
				clearSelection();
			}
			select(this);
		} else {
			if (!ev.shiftKey && (ev.ctrlKey || ev.metaKey)) {
				unselect(this);
			}
		}

		if (ev.altKey) {
			cloneSelectedKeyframes();
		}

		draggingComponent = this;
		let isInvertedShift;
		if (this instanceof TimelineLoopPoint) {
			prevDragTime = this.props.keyFrame.j;
			isInvertedShift = this.props.keyFrame.j > this.props.keyFrame.t;
		} else {
			prevDragTime = ((this as TimelineLabelView).props.label || (this as TimelineKeyframeView).props.keyFrame).t;
		}

		let bounds = (ev.currentTarget as HTMLDivElement).getBoundingClientRect();
		if (isInvertedShift) {
			draggingXShift = ev.clientX - bounds.x - bounds.width;
		} else {
			draggingXShift = ev.clientX - bounds.x;
		}
	}
}

export function getWindowElement(childSelector: string, windowId = '#timeline'): Promise<HTMLDivElement> {
	return new Promise((resolve) => {
		let interval = window.setInterval(() => {
			let w = document.querySelector(windowId) as HTMLDivElement;
			if (w) {
				if (childSelector) {
					w = w.querySelector(childSelector) as HTMLDivElement;
				}
			}
			if (w) {
				clearInterval(interval);
				resolve(w);
			}
		}, 1);
	});
}

function getFieldByName(o: MovieClip, name: string) {
	if (o._timelineData) {
		let fields = o._timelineData.f;
		for (let field of fields) {
			if (field.n === name) {
				return field;
			}
		}
	}
}

function getFieldByNameOrCreate(o: MovieClip, name: string) {
	let field: TimelineFieldData = getFieldByName(o, name) as TimelineFieldData;
	if (!field) {
		if (!o._timelineData) {
			o.__initTimeline();
		}
		field = {
			n: name,
			t: [],
			/// #if EDITOR
			___timelineData: o._timelineData,
			___fieldIndex: o._timelineData.f.length
			/// #endif
		};

		o._timelineData.f.push(field);
	}
	return field;
}

let getFrameAtTimeOrCreateReturnedNewKeyframe = false;

function getFrameAtTimeOrCreate(o: MovieClip, name: string, time: number, doNotModifyEarlyKeyframes = false): TimelineKeyFrame {
	let field = getFieldByNameOrCreate(o, name);
	for (let keyFrame of field.t) {
		if (keyFrame.t === time) {
			getFrameAtTimeOrCreateReturnedNewKeyframe = false;
			return keyFrame;
		}
	}
	getFrameAtTimeOrCreateReturnedNewKeyframe = true;
	return createKeyframe(o, name, time, field, false, doNotModifyEarlyKeyframes);
}


function createKeyframe(o: MovieClip, name: string, time: number, field: TimelineFieldData, isAutomaticCreation = false, doNotModifyEarlyKeyframes = false): TimelineKeyFrame {

	let mode;
	let jumpTime = time;
	let prevField = MovieClip.__findPreviousKeyframe(field.t, time);
	if (prevField) {
		mode = prevField.m;
		if (mode === 3 || mode === 4) {
			mode = 0;
		}
		if (!doNotModifyEarlyKeyframes) {
			if (prevField.j !== prevField.t) { //takes loop point from previous keyframe if it is exists;
				let labelBetweenKeyframes = null;
				for (let lName in o.timeline!.l) {
					let lTime = o.timeline!.l[lName];
					if (lTime >= prevField.t && lTime <= time) {
						labelBetweenKeyframes = true;
						break;
					}
				}
				if (!labelBetweenKeyframes) {
					jumpTime = prevField.j;
					prevField.j = prevField.t;
				}
			}
		}
	} else {
		mode = getDefaultKeyframeTypeForField(o, name);
	}

	let keyFrame: TimelineKeyFrame = {
		v: (o as KeyedObject)[name], //target Value
		t: time, //frame triggering Time
		m: mode,
		j: jumpTime, //Jump to time. If no jump need - equal to 't'
		___react_id: MovieClip.__generateKeyframeId()
	} as any;

	if (!isAutomaticCreation && (name === 'image') && prevField) {
		let step = time - prevField.t;
		let nameStep = increaseNumberInName(prevField.v as string, 1) === o.image ? 1 : -1;
		let nextName = increaseNumberInName(prevField.v as string, nameStep);
		if ((nextName !== prevField.v) && (nextName === o.image)) {
			if (Lib.hasTexture(increaseNumberInName(o.image, nameStep)!)) {
				game.editor.ui.modal.showEditorQuestion('Animation generator', 'Do you want to create keyframes for all same images?',
					() => {
						let image = o.image;
						while (true) {
							image = increaseNumberInName(image, nameStep)!;
							if (Lib.hasTexture(image)) {
								time += step;
								o[name] = image;
								createKeyframe(o, name, time, field, true);
							} else {
								break;
							}
						}
						timelineInstance.refresh();
					}
				);
			}
		}
	}
	field.t.push(keyFrame);
	Timeline.fieldDataChanged(field, o);
	return keyFrame;
}

let draggingComponent: TimelineSelectable | null;
let draggingStartX = 0;
let draggingXShift = 0;
let prevDragTime = -1;

function cloneSelectedKeyframes() {
	for (let c of selectedComponents) {
		if (c instanceof TimelineKeyframeView) {
			c.clone();
		} else if (c instanceof TimelineLabelView) {
			let newName!:string;
			if (/\d/.test(c.props.label.___name)) {
				newName = increaseNumberInName(c.props.label.___name)!;
			} else {
				newName = c.props.label.___name + '-2';
			}
			while (c.props.owner.props.node._timelineData.l[newName]) {
				newName = increaseNumberInName(newName)!;
			}
			c.clone(newName);
		}
	}
}

const sortFieldsByTime = (a: TimelineKeyFrame, b: TimelineKeyFrame) => {
	if (a.t !== b.t) {
		return a.t - b.t;
	}
	return ((a.___view && a.___view.state && a.___view.state.isSelected) ? 0 : 1) -
		((b.___view && b.___view.state && b.___view.state.isSelected) ? 0 : 1);
};

function onTimelineScroll(ev: Event) {
	selectionFrame.cancelSelection();
	for (const element of (document.querySelectorAll('.timeline-fixed-block') as any as HTMLDivElement[])) {
		element.style.left = (ev.target as HTMLDivElement).scrollLeft + 'px';
	}
	(document.querySelector('.timeline-labels-background') as HTMLDivElement).style.top = (ev.target as HTMLDivElement).scrollTop + 'px';
	(document.querySelector('.time-marker-body') as HTMLDivElement).style.top = (ev.target as HTMLDivElement).scrollTop + 'px';
}

let isDragging = false;

function getSelectedKeyframes(): TimelineKeyframeView[] {
	return selectedComponents.filter((c) => {
		return c instanceof TimelineKeyframeView;
	}) as TimelineKeyframeView[];
}

function reduceRepeatingKeyframesInSelected() {
	let isModified = false;
	for (let keyframeComponent of getSelectedKeyframes()) {
		let timeLineKeyframes = keyframeComponent.props.owner.props.owner.props.field.t;
		for (let i = 0; i < timeLineKeyframes.length; i++) {
			let kf = timeLineKeyframes[i];
			for (let j = i + 1; j < timeLineKeyframes.length; j++) {
				let keyFrame = timeLineKeyframes[j];
				if ((kf !== keyFrame) && (kf.t === keyFrame.t)) {
					timeLineKeyframes.splice(j, 1);
					j--;
					isModified = true;
					Timeline.fieldDataChanged(
						keyframeComponent.props.owner.props.owner.props.field,
						keyframeComponent.props.owner.props.owner.props.owner.props.node
					);
				}
			}
		}
	}
	return isModified;
}

function selectIfInRect(rect: DOMRect, obj: TimelineKeyFrame) {
	selectViewIfInRect(rect, obj.___view!);
}

function selectViewIfInRect(rect: DOMRect, view: TimelineSelectable) {
	if (selectedComponents.indexOf(view) >= 0) {
		return;
	}
	let domElement = (view as TimelineKeyframeView).base as HTMLDivElement;
	if (!domElement) {
		return;
	}
	let r = domElement.getBoundingClientRect();

	if (r.right > rect.left && r.left < rect.right) {
		if (r.bottom > rect.top && r.top < rect.bottom) {
			select(view);
		}
	}
}

function selectElementsInRectangle(rect: DOMRect, shiftKey = false) {
	if (!shiftKey) {
		clearSelection();
	}

	for (let o of game.editor.selection) {
		if ((o instanceof MovieClip) && (o._timelineData)) {
			for (let f of o._timelineData.f) {
				for (let kf of f.t) {
					selectIfInRect(rect, kf);
					if (kf.___loopPointView) {
						selectViewIfInRect(rect, kf.___loopPointView as any as TimelineSelectable);
					}
				}
			}
			for (let labelName in o._timelineData.l) {
				let label = o._timelineData.l[labelName];
				selectIfInRect(rect, label as any);
			}
		}
	}

	timelineInstance.onMouseUp({} as any);
	timelineInstance.refresh();
}

editorEvents.on('beforePropertyChanged', Timeline.onBeforePropertyChanged);
editorEvents.on('afterPropertyChanged', Timeline.onAfterPropertyChanged);
</file>

<file path="src/editor/ui/props-editor/props-field-wrapper.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes, ComponentChild } from 'preact';
import { Component, h } from 'preact';

import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import PropsEditor from 'thing-editor/src/editor/ui/props-editor/props-editor';
import ArrayEditableProperty from 'thing-editor/src/editor/ui/props-editor/props-editors/array-editable-property';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const wrapperProps = { className: 'props-wrapper' };
const defaultValueProps = {
	className: 'default-value selectable-text',
	title: CTRL_READABLE + '+click to copy default value',
	onMouseDown: copyTextByClick
};

const nameValueProps = {
	className: 'selectable-text context-menu-item-hotkey'
};

interface EditablePropertyEditorProps extends ClassAttributes<PropsFieldWrapper> {
	field: EditablePropertyDesc;
	value: any;
	disabled?: boolean;
	onBlur?: () => void;
	onChange: (val: any, isDelta?: boolean, deltaVal?: number) => void;
}

interface PropsFieldWrapperProps extends ClassAttributes<PropsFieldWrapper> {
	field: EditablePropertyDesc;
	onChange: (field: EditablePropertyDesc, val: any, isDelta?: boolean) => void;
	propsEditor: PropsEditor;
	defaultValue: any;
}

const CAN_COPY_VALUES_OF_TYPE: EditablePropertyType[] = [
	'data-path',
	'callback',
	'color',
	'string',
	'prefab',
	'number'
];

const onContextMenu = async (fieldEditor: PropsFieldWrapper, value: any, ev: PointerEvent) => {
	const field: EditablePropertyDesc = fieldEditor.props.field;
	const defaultValue: any = fieldEditor.props.defaultValue;

	let clickedArrayItemIndex = -1;

	if (field.arrayProperty) {
		const items = Array.from((fieldEditor.base as HTMLDivElement)!.querySelectorAll('.array-prop-item'));
		clickedArrayItemIndex = items.findIndex(i => i.contains(ev!.target as HTMLDivElement) || i === ev!.target);
	}

	let clipboardText = await navigator.clipboard.readText();

	let clickedValue = value;
	if (field.arrayProperty) {
		clickedValue = value && value.length && value.join('\n');
		const items = Array.from((fieldEditor.base as HTMLDivElement)!.querySelectorAll('.array-prop-item'));

		let i = items.findIndex(i => i.contains(ev!.target as HTMLDivElement) || i === ev!.target);
		if (i >= 0) {
			clickedValue = value[i];
		}
	}

	let colorSampleCopy: any;
	let colorSample: any;
	let hexValue: any;
	if (field.type === 'color') {
		if (Array.isArray(clickedValue)) {
			hexValue = clickedValue.map((v) => {
				if (typeof v === 'number') {
					return v.toString(16).padStart(6, '0');
				} else {
					return '000000';
				}
			});
		} else {
			if (typeof clickedValue === 'number') {
				hexValue = clickedValue.toString(16).padStart(6, '0');
			}
			if (clipboardText) {
				clipboardText = clipboardText.replace('#', '');
				if (clipboardText.length <= 9) {
					colorSample = R.fragment(R.span({className: 'semi-transparent'}, '#' + clipboardText), R.span({
						style: {background: '#' + clipboardText},
						className: 'color-sample'
					}));
				}
			}
			colorSampleCopy = R.fragment(R.span({className: 'semi-transparent'}, '#' + clickedValue.toString(16).padStart(6, '0')), R.span({
				style: {background: '#' + clickedValue.toString(16).padStart(6, '0')},
				className: 'color-sample'
			}));
		}

	}

	const contextMenu = [
		{
			name: R.fragment(R.icon('copy'), 'Copy value', R.span(nameValueProps, clickedValue)),
			onClick: () => {
				game.editor.copyToClipboard(clickedValue);
			},
			disabled: () => CAN_COPY_VALUES_OF_TYPE.indexOf(field.type) < 0
		},
		{
			hidden: () => field.type !== 'color' || Array.isArray(clickedValue),
			name: R.fragment(R.icon('copy'), R.fragment('Copy HEX', colorSampleCopy)),
			onClick: () => {
				game.editor.copyToClipboard(hexValue);
			}
		},
		{
			name: R.fragment(R.icon('paste'), R.fragment('Paste value')),
			onClick: () => {

				let val: any;

				let a = clipboardText.split('\n');
				if (field.type === 'color' || field.type === 'number') {
					a = a.map(v => parseFloat(v) || 0) as any;
				}
				if (field.arrayProperty) {
					if (clickedArrayItemIndex < 0) {
						val = a;
					} else {
						val = ((game.editor.selection[0] as any as KeyedMap<any[]>)[field.name] || []).slice();
						val[clickedArrayItemIndex] = a[0];
					}
				} else {
					val = a[0];
				}
				game.editor.editProperty(field, val);
			},
			disabled: () => CAN_COPY_VALUES_OF_TYPE.indexOf(field.type) < 0
		},
		{
			hidden: () => field.type !== 'color' || !colorSample,
			name: R.fragment(R.icon('paste'), R.fragment('Paste HEX', colorSample)),
			onClick: () => {
				let val: any;

				clipboardText = clipboardText.replace('#', '');

				let a = clipboardText.split(',');
				if (field.type === 'color' || field.type === 'number') {
					a = a.map(v => parseInt(v, 16) || 0) as any;
				}
				if (field.arrayProperty) {
					if (clickedArrayItemIndex < 0) {
						val = a;
					} else {
						val = ((game.editor.selection[0] as any as KeyedMap<any[]>)[field.name] || []).slice();
						val[clickedArrayItemIndex] = a[0];
					}
				} else {
					val = a[0];
				}
				game.editor.editProperty(field, val);
			},
			disabled: () => CAN_COPY_VALUES_OF_TYPE.indexOf(field.type) < 0
		},
		{
			name: R.fragment(R.icon('copy'), 'Copy property name', R.span(nameValueProps, field.name)),
			onClick: () => { game.editor.copyToClipboard(field.name); }
		},
		{
			name: 'Why disabled?..',
			onClick: () => { game.editor.ui.modal.showInfo(R.fragment(R.b(null, field.name), R.br(), game.editor.ui.propsEditor.disableReasons[field.name]), 'Property is disabled.'); },
			disabled: () => !game.editor.ui.propsEditor.disableReasons[field.name]
		},
		(clickedArrayItemIndex >= 0) ? {
			name: '➦ Insert item upper',
			onClick: () => {
				const val = ((game.editor.selection[0] as any as KeyedMap<any[]>)[field.name] || []).slice();
				val.splice(clickedArrayItemIndex, 0, field.defaultArrayItemValue || PropsEditor.getDefaultForType(field));
				game.editor.editProperty(field, val);
			}

		} : null,
		(clickedArrayItemIndex >= 0) ? {
			name: '➥ Insert item lower',
			onClick: () => {
				const val = ((game.editor.selection[0] as any as KeyedMap<any[]>)[field.name] || []).slice();
				val.splice(clickedArrayItemIndex + 1, 0, field.defaultArrayItemValue || PropsEditor.getDefaultForType(field));
				game.editor.editProperty(field, val);
			}

		} : null,
		(clickedArrayItemIndex > 0) ? {
			name: '↑ Move item up',
			onClick: () => {
				const val = ((game.editor.selection[0] as any as KeyedMap<any[]>)[field.name] || []).slice();
				let item = val[clickedArrayItemIndex];
				val.splice(clickedArrayItemIndex, 1);
				val.splice(clickedArrayItemIndex - 1, 0, item);
				game.editor.editProperty(field, val);
			}

		} : null,
		(clickedArrayItemIndex >= 0) ? {
			name: '↓ Move item down',
			onClick: () => {
				const val = ((game.editor.selection[0] as any as KeyedMap<any[]>)[field.name] || []).slice();
				if (clickedArrayItemIndex < (val.length - 1)) {
					let item = val[clickedArrayItemIndex];
					val.splice(clickedArrayItemIndex, 1);
					val.splice(clickedArrayItemIndex + 1, 0, item);
					game.editor.editProperty(field, val);
				}
			}

		} : null,
		null,
		{
			name: 'Go to property definition >>',
			onClick: () => {
				game.editor.editSource(field.__src);
			}
		},
		null,
		{
			name: R.fragment(R.icon('reject'), 'Reset "' + field.name + '" value to default: ', R.span(defaultValueProps, defaultValue)),
			onClick: () => {
				game.editor.editProperty(field, defaultValue);
			},
			disabled: () => defaultValue === undefined || value === defaultValue || !game.editor.ui.propsEditor.editableProps[field.name]
		},

	] as ContextMenuItem[];

	if (field.renderer.contextMenuInjection) {
		field.renderer.contextMenuInjection(contextMenu, field, clickedValue, value);
	}

	showContextMenu(contextMenu, ev);
};

export default class PropsFieldWrapper extends Component<PropsFieldWrapperProps> {

	propertyEditor: ComponentChild;

	ownerContainer!: Container;

	constructor(props: PropsFieldWrapperProps) {
		super(props);
		this.state = {};
		this.onChange = this.onChange.bind(this);
		this.editorRef = this.editorRef.bind(this);
		this._onBlur = this._onBlur.bind(this);
		props.propsEditor.refs.set(this.props.field.name, this);
	}

	_onBlur() {
		if (this.props.field.onBlur) {
			this.props.field.onBlur();
		}
	}

	componentWillUnmount(): void {
		this.props.propsEditor.refs.delete(this.props.field.name);
	}

	componentWillReceiveProps() {
		if (this.ownerContainer !== game.editor.selection[0]) {
			this.ownerContainer = game.editor.selection[0];
			this.setState({ value: undefined });
		}
	}

	onChange(val: any, isDelta = false, deltaVal?: number) {
		if (val && val.target) {
			val = val.target.value;
		}
		assert(!(val instanceof Event), 'Pure value expected. Event received.');
		assert((!isDelta) || (typeof isDelta === 'boolean'), 'Delta expected to be boolean');
		let field = this.props.field;

		if (field.hasOwnProperty('parser')) {
			val = (field.parser as (val: any) => any)(val);
		}

		if (field.renderer.hasOwnProperty('parser')) {
			val = (field.renderer.parser as (val: any) => any)(val);
		}

		if (field.hasOwnProperty('min')) {
			if (Array.isArray(val)) {
				val = val.map(v => Math.max(field.min!, v));
			} else {
				val = Math.max(field.min!, val);
			}
		}
		if (field.hasOwnProperty('max')) {
			if (Array.isArray(val)) {
				val = val.map(v => Math.min(field.max!, v));
			} else {
				val = Math.min(field.max!, val);
			}
		}
		if ((this.state as any).value !== val) {
			if (isDelta) {
				this.props.onChange(field, deltaVal, true);
			} else {
				this.props.onChange(field, val);
			}

			this.setState({ value: val });
		}
	}

	onAutoSelect(selectPath: string[]) {
		if (this.propertyEditor && (this.propertyEditor as any).onAutoSelect) {
			(this.propertyEditor as any).onAutoSelect(selectPath);
		}
	}

	editorRef(ref: ComponentChild | null) {
		this.propertyEditor = ref;
	}

	render() {
		let field = this.props.field;
		let node: Container = game.editor.selection[0];
		if (!node) {
			return R.fragment();
		}
		let value = (node as KeyedObject)[field.name];

		let disabled = !this.props.propsEditor.editableProps[field.name];

		let className = field.important ? 'props-field props-field-important props-field-' + field.type : 'props-field props-field-' + field.type;

		if (field.notSerializable) {
			if (value == field.default || !field.hasOwnProperty('default')) {
				className += ' props-wrapper-default-value';
			}
		} else {
			if (value == this.props.defaultValue) {
				className += ' props-wrapper-default-value';
			}
		}

		if (field.separator) {
			className += ' props-wrapper-separator';
		}

		let tip;
		if (field.hasOwnProperty('tip')) {
			tip = ((typeof field.tip === 'function') ? field.tip() : field.tip);
			if (tip) {
				tip = R.tip(field.name,
					'Field "' + field.name + '" description:',
					tip
				);
			}
		}

		(this.state as any).value = value;

		return R.div({
			className, id: 'property-editor-' + field.name.replace('.', '_'),
			title: field.name,
			'data-help': field.helpUrl,
			onContextMenu: (ev: PointerEvent) => {
				if ((ev.target as HTMLElement).tagName !== 'button') {
					onContextMenu(this, value, ev);
				}
			}
		},
		tip,
		R.div({
			className: field.name.startsWith('__') ? 'props-label props-label-helper selectable-text' : 'props-label selectable-text',
			title: 'Double click - go to definition, ' + CTRL_READABLE + '+click to copy field`s name',
			onMouseDown: copyTextByClick,
			onDblClick: () => {
				game.editor.editSource(field.__src);
			}
		}, field.name),
		R.div(wrapperProps,
			field.arrayProperty ?
				h(ArrayEditableProperty, {
					ref: this.editorRef,
					value,
					onChange: this.onChange as any,
					onBlur: this._onBlur,
					field,
					disabled
				}) :
				h(field.renderer, {
					ref: this.editorRef,
					value,
					onChange: this.onChange as any,
					onBlur: this._onBlur,
					field,
					disabled
				})
		));
	}
}

export type { EditablePropertyEditorProps };
</file>

<file path="src/editor/ui/sound-profiler.ts">
import type { ClassAttributes, ComponentChild } from 'preact';
import { h } from 'preact';

import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Window from 'thing-editor/src/editor/ui/editor-window';
import MainMenu from 'thing-editor/src/editor/ui/main-menu';
import { hideAdditionalWindow, showAdditionalWindow } from 'thing-editor/src/editor/ui/ui';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import type { DebugStack } from 'thing-editor/src/editor/utils/stack-utils';
import { getCurrentStack, showStack } from 'thing-editor/src/editor/utils/stack-utils';
import type HowlSound from 'thing-editor/src/engine/HowlSound';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import BgMusic from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music.c';
import MusicFragment from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music/music-fragment';

const profilerProps = { className: 'music-profiler' };
const PROFILER_COLORS = [
	{
		background: '#ffeacf',
		borderColor: '#ffbea2'
	},
	{
		background: '#ffcfea',
		borderColor: '#ffa2be'
	},
	{
		background: '#cfffea',
		borderColor: '#a2ffbe'
	},
	{
		background: '#eacfff',
		borderColor: '#bea2ff'
	},
	{
		background: '#eaffcf',
		borderColor: '#beffa2'
	},
	{
		background: '#cfeaff',
		borderColor: '#a2beff'
	}
];

interface SoundProfilerProps extends ClassAttributes<SoundProfiler> {
	onCloseClick: () => void;
}

interface SoundProfilerState {
	widthZoom: number;
	heightZoom: number;
}

interface ProfilerEntry {
	soundId: string;
	stack: DebugStack;
	title: string;
	sound: HowlSound;
	durationFrames: number;
	startFrame: number;
	y: number;
	background: string;
	borderColor: string;

}

export default class SoundProfiler extends ComponentDebounced<SoundProfilerProps, SoundProfilerState> {

	static soundsProfilerColorsCache: KeyedMap<typeof PROFILER_COLORS[0]> = {};
	static soundsProfilerArray: ProfilerEntry[] = [];
	static soundsProfilerLane = 0;
	static ignoreSoundProfile = 0;

	interval = 0;

	componentDidMount() {
		this.interval = window.setInterval(() => {
			this.refresh();
		}, 1000 / 60);
	}

	componentWillUnmount() {
		clearInterval(this.interval);
	}

	renderMusicItem(m: BgMusic, i: number) {
		let state;
		const fragment = m.__currentFragment || MusicFragment.__getFragment(m.musicFragmentHash);
		if (fragment) {
			state = R.div({ className: 'sound-vol-bar-bg' },
				R.div({ className: 'sound-vol-bar', title: 'Volume: ' + fragment.getVolume(), style: { width: fragment.getVolume()! * 100 } })
			);

		} else {
			state = R.div({ className: 'sound-vol-bar-bg' },
				'stopped'
			);
		}
		return R.div({
			className: 'clickable music-profiler-row', key: i, onClick: () => {
				if (m.getRootContainer() === game.currentContainer) {
					game.editor.ui.sceneTree.selectInTree(m);
				} else {
					let root = m.getRootContainer();
					if (!root) {
						root = m;
						while (root.parent) {
							root = root.parent;
						}
					}
					game.editor.ui.modal.notify('Cant select music object');
				}
			}
		}, R.span({ className: (m.__currentFragment?.source?.loop === false) ? 'music-profiler-row-text music-profiler-row-text-active' : 'music-profiler-row-text', title: 'Intro sound: ' + (m.intro || 'NONE') }, m.intro), R.span({ className: (m.__currentFragment?.source?.loop === true) ? 'music-profiler-row-text music-profiler-row-text-active' : 'music-profiler-row-text', title: 'Loop sound: ' + (m.loop || 'NONE') }, m.loop), state
		);
	}

	render(): ComponentChild {
		let soundsLanes = [];
		SoundProfiler.soundsProfilerArray = SoundProfiler.soundsProfilerArray.filter(i => (i.startFrame + i.durationFrames) > (game.time - 200) && (i.startFrame <= game.time));

		for (let soundEntry of SoundProfiler.soundsProfilerArray) {
			soundsLanes.push(R.div({
				onClick: () => {
					soundEntry.sound.lastPlayStartFrame = -1000;
					SoundProfiler.ignoreSoundProfile++;
					game.Sound.play(soundEntry.soundId);
					SoundProfiler.ignoreSoundProfile--;
					showStack(soundEntry.stack);
				}, className: 'sound-profiler-sound-entry clickable', title: soundEntry.title, style: { background: soundEntry.background, borderColor: soundEntry.borderColor, top: soundEntry.y, right: (game.time - soundEntry.startFrame - soundEntry.durationFrames) * 2 - 10, width: soundEntry.durationFrames * 2 }
			}, soundEntry.soundId));
		}

		let bgMusicsList;
		let profilerBody;

		if (game.__EDITOR_mode) {
			profilerBody = R.fragment(R.btn('Start', () => {
				game.editor.ui.viewport.onTogglePlay();
			}), ' game execution to profile sounds.');
		} else {
			bgMusicsList = BgMusic.__allActiveMusics.map(this.renderMusicItem);
			profilerBody = R.div(profilerProps, bgMusicsList, R.div({ className: 'sound-profiler-lane' }, soundsLanes));
		}
		return R.fragment(
			R.btn('×', this.props.onCloseClick, 'Hide timeline', 'close-window-btn', {key: 'Escape'}),
			profilerBody
		);
	}


	static onSoundPlay(soundId: string, volume: number) {
		if (SoundProfiler.ignoreSoundProfile) {
			return;
		}
		let sound = Lib.getSound(soundId);
		let durationFrames = Math.round(sound.preciseDuration * 60);

		let colors = SoundProfiler.soundsProfilerColorsCache[soundId];
		if (!colors) {
			let hash = 0;
			for (let i = 0; i < soundId.length; i++) {
				hash += soundId.charCodeAt(i);
			}
			colors = PROFILER_COLORS[hash % PROFILER_COLORS.length];
			SoundProfiler.soundsProfilerColorsCache[soundId] = colors;
		}

		SoundProfiler.soundsProfilerArray.push({
			soundId,
			stack: getCurrentStack(soundId),
			title: soundId + ' Vol: ' + volume,
			sound,
			durationFrames,
			startFrame: game.time,
			y: SoundProfiler.soundsProfilerLane,
			background: colors.background,
			borderColor: colors.borderColor
		});
		SoundProfiler.soundsProfilerLane += 18;
		if (SoundProfiler.soundsProfilerLane >= 61) {
			SoundProfiler.soundsProfilerLane -= 60;
		}
	}

	static toggle() {
		game.editor.settings.setItem('sound-profiler-shown', !game.editor.settings.getItem('sound-profiler-shown'));
		SoundProfiler.renderWindow();
	}

	static renderWindow() {
		if (game.editor.settings.getItem('sound-profiler-shown')) {
			SoundProfiler.show();
		} else {
			SoundProfiler.hide();
		}
	}

	static show() {
		showAdditionalWindow('sound-profiler', 'SoundProfiler', 'SoundProfiler',
			R.div({ title: '' },
				h(SoundProfiler, { onCloseClick: SoundProfiler.toggle }),
			), 50, 50, 80, 80, 300, 200);
		Window.bringWindowForward('#sound-profiler');
	}

	static hide() {
		hideAdditionalWindow('sound-profiler');
	}
}

window.setTimeout(SoundProfiler.renderWindow, 100,);

editorEvents.on('soundPlay', SoundProfiler.onSoundPlay);

MainMenu.injectMenu('settings', [{
	name: () => {
		return R.span(null, R.span({ className: '.menu-icon' }, game.editor.settings.getItem('sound-profiler-shown') ? '☑' : '☐'), ' Sound profiler');
	},
	onClick: () => {
		SoundProfiler.toggle();
	},
	stayAfterClick: true
}], 'sound-profiler', -1);
</file>

<file path="src/editor/ui/status-bar.ts">
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';

const transparentProps = { className: 'transparent' };
const statusProps = { className: 'status-entry' };

const statusEntries: { text: string; id: string; priority: number }[] = [];

export default class StatusBar extends Component {

	interval!: number;

	componentDidMount(): void {
		this.interval = window.setInterval(() => {
			this.forceUpdate();
		}, 50);
	}

	static addStatus(text: string, id: string, priority = 0) {
		for (const e of statusEntries) {
			if (e.id === id) {
				e.text = text;
				return;
			}
		}
		statusEntries.push({ text, id, priority });
		statusEntries.sort((a, b) => { return b.priority - a.priority; });
	}

	static removeStatus(id: string) {
		const i = statusEntries.findIndex(e => e.id === id);
		if (i >= 0) {
			statusEntries.splice(i, 1);
		}
	}

	componentWillUnmount() {
		clearInterval(this.interval);
	}


	render() {

		if (game.editor.selection.length) {
			StatusBar.addStatus('Right click on viewport to move object to clicked point', 'right-click-to-move', -1);
		} else {
			StatusBar.removeStatus('right-click-to-move');
		}

		const status = statusEntries.length ?
			statusEntries.map((statusEntry) => {
				if (statusEntry.priority < 0 && statusEntries.some(e => e.priority >= 0)) {
					return undefined;
				}
				return R.span(statusProps, '(' + statusEntry.text + ')');
			}) : undefined;

		if (game && game.stage) {
			let txt = ' x: ' + game.__mouse_uncropped.x + ' y: ' + game.__mouse_uncropped.y;

			if (game.editor.selection.length > 0) {
				let p = game.editor.selection[0].toLocal(game.mouse, game.currentContainer);
				if (!isNaN(p.x)) {
					txt += ' (x: ' + Math.round(p.x - game.editor.selection[0].pivot.x) + '; y: ' + Math.round(p.y - game.editor.selection[0].pivot.y) + ')';
				}
			}

			let resetZoomBtn;
			if (game.pixiApp) {
				if (game.stage.scale.x !== 1) {
					txt += ' zoom: ' + game.stage.scale.x;
				}

				const defaultCameraX = PrefabEditor.currentPrefabName ? game.W / 2 : 0;
				const defaultCameraY = PrefabEditor.currentPrefabName ? game.H / 2 : 0;

				if (game.stage.scale.x !== 1 || game.stage.x !== defaultCameraX || game.stage.y !== defaultCameraY) {
					resetZoomBtn = R.btn('x', game.editor.ui.viewport.resetZoom, 'Reset zoom and viewport position (' + CTRL_READABLE + ' + double-click on viewport)', 'reset-zoom-btn');
				}
			}
			return R.span(null, resetZoomBtn, R.span(game.editor.isCurrentContainerModified ? null : transparentProps, '●'), txt, status);
		}
		return R.span();
	}
}
</file>

<file path="src/editor/ui/status-clearing-condition.ts">
export const enum StatusClearingCondition {
	NONE = -1,
	ASSETS_REFRESH = 0,
	LAUNCH_GAME = 1,
	TEXT_EDITOR_CLOSE = 2,
	BUILD_PROJECT = 3,
	CLASSES_RELOAD = 4
}
</file>

<file path="src/editor/ui/status.ts">
import { Container } from 'pixi.js';
import type { ClassAttributes, ComponentChild } from 'preact';
import { h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics.js';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Help from 'thing-editor/src/editor/ui/help';
import { hideAdditionalWindow, showAdditionalWindow } from 'thing-editor/src/editor/ui/ui';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import shakeDomElement from 'thing-editor/src/editor/utils/shake-element';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import { EMPTY_NODE_EXTEND_DATA } from 'thing-editor/src/engine/lib';
import waitForCondition from 'thing-editor/src/engine/lib/assets/src/utils/wait-for-condition';
import fs from '../fs';
import { scrollInToView } from '../utils/scroll-in-view';
import type { GroupFolderData } from './group';
import group from './group';
import { preactComponentChildToString } from './modal';
import { StatusClearingCondition } from './status-clearing-condition';

const errorIcon = R.icon('error-icon');
const warnIcon = R.icon('warn-icon');

type StatusItemsOwnersMap = WeakMap<NodeExtendData, Container | KeyedMap<true>>
type StatusListItemOwner = Container | ((ev?: PointerEvent) => void) | SourceMappedConstructor;
interface StatusListItem {
	message: string | ComponentChild;
	owner?: StatusListItemOwner;
	ownerId?: number;
	clearingCondition?: StatusClearingCondition;
	fieldName?: string;
	fieldArrayItemNumber: number;
	errorCode?: number;
	val?: any;
}

let lastClickedItem: StatusListItem | undefined;
let lastClickedList: InfoList | undefined;

const needAddInToList = (map: StatusItemsOwnersMap, owner?: StatusListItemOwner, fieldName?: string, errorCode?: number) => {
	waitForCondition(() => {
		return game.projectDesc;
	});
	if (game.projectDesc && game.projectDesc.__suspendWarnings && (game.projectDesc.__suspendWarnings.indexOf(errorCode!) >= 0)) {
		return;
	}
	if (!(owner instanceof Container)) {
		return true;
	} else {
		let exData = owner.__nodeExtendData;
		if (exData !== EMPTY_NODE_EXTEND_DATA) {
			exData.statusWarnOwnerId = owner.___id;
		}

		if (!fieldName) {
			fieldName = '_no_field_name_';
		}
		if (!map.has(exData)) {
			let o: KeyedMap<true> = {};
			o[fieldName] = true;
			map.set(exData, o);
			return true;
		} else {
			let o = map.get(exData) as KeyedMap<true>;
			let ret = !o[fieldName];
			o[fieldName] = true;
			return ret;
		}
	}
};


interface StatusState {
	toggled?: boolean;
}

export default class Status extends ComponentDebounced<ClassAttributes<Status>, StatusState> {

	private errorsMap: StatusItemsOwnersMap;
	private warnsMap: StatusItemsOwnersMap;
	private errors: StatusListItem[];
	private warns: StatusListItem[];

	private errorsList!: InfoList;
	private warnsList!: InfoList;


	constructor(props: ClassAttributes<Status>) {
		super(props);
		this.errorsMap = new WeakMap();
		this.warnsMap = new WeakMap();

		this.state = {};
		this.errors = [];
		this.warns = [];


		this.warnsListRef = this.warnsListRef.bind(this);
		this.errorsListRef = this.errorsListRef.bind(this);
		this.clear = this.clear.bind(this);
	}

	private errorsListRef(ref: InfoList | null) {
		this.errorsList = ref as InfoList;
	}

	private warnsListRef(ref: InfoList | null) {
		this.warnsList = ref as InfoList;
	}

	error(message: string, errorCode?: number, owner?: StatusListItemOwner, fieldName?: string, fieldArrayItemNumber = -1) {
		if (EDITOR_FLAGS.isTryTime) {
			return Promise.resolve();
		}

		if (game.editor.buildProjectAndExit) {
			message = preactComponentChildToString(message);
			fs.exitWithResult(undefined, 'Build failed: ' + game.editor.buildProjectAndExit + '\n' + message +
			'; Error code: ' + errorCode + (owner instanceof Container ?
				'; owner: ' + owner.___info : '') +
				(fieldName ? '; Field name: ' + fieldName : '')
			);
			return Promise.resolve();
		}

		assert((!errorCode) || (typeof errorCode === 'number'), 'Error code expected.');
		console.error(errorCode + ': ' + message + getErrorDetailsUrl(errorCode));
		let item: StatusListItem = { owner, ownerId: owner && (owner as Container).___id, message, fieldName, errorCode, fieldArrayItemNumber };
		if (owner && fieldName) {
			item.val = (owner as KeyedObject)[fieldName];
		}

		if (needAddInToList(this.errorsMap, owner, fieldName, errorCode)) {
			this.errors.push(item);
			if (this.errorsList) {
				this.errorsList.refresh();
			} else {
				this.show();
			}
			game.editor.pauseGame();
		}

		showLastInfoLine();
		shakeDomElement(document.querySelector('#window-info') as HTMLElement);
	}

	warn(message: ComponentChild, errorCode?: number, owner?: StatusListItemOwner, fieldName?: string, doNoFilterRepeats = false, fieldArrayItemNumber = -1, clearingCondition: StatusClearingCondition = StatusClearingCondition.NONE) {
		if (EDITOR_FLAGS.isTryTime) {
			return Promise.resolve();
		}
		assert((!errorCode) || (typeof errorCode === 'number'), 'Error code expected.');
		console.warn(message + getErrorDetailsUrl(errorCode));
		if (doNoFilterRepeats || needAddInToList(this.warnsMap, owner, fieldName, errorCode)) {
			let item: StatusListItem = { owner, clearingCondition, ownerId: owner && (owner as Container).___id, message, fieldName, errorCode, fieldArrayItemNumber };
			if (owner && fieldName) {
				item.val = (owner as KeyedObject)[fieldName];
			}

			this.warns.push(item);
			if (this.errorsList) {
				this.warnsList.forceUpdate();
			} else {
				this.show();
			}
			showLastInfoLine();
		}
	}

	clearLastClickedItem() {
		assert(lastClickedItem, 'lastClickedItem already cleared.');
		lastClickedList!.clearItem(lastClickedItem!);
		lastClickedItem = undefined;
	}

	clearByCondition(condition:StatusClearingCondition) {
		this.warns = this.warns.filter(w => w.clearingCondition !== condition);
		if (!this.warns.length && !this.errors.length) {
			this.hide();
		}
	}

	clear() {
		this.errors.length = 0;
		this.warns.length = 0;

		this.errorsMap = new WeakMap();
		this.warnsMap = new WeakMap();

		this.hide();
	}

	private show() {
		this.setState({ toggled: true });
	}

	private hide() {
		this.setState({ toggled: false });
	}

	render() {
		if (this.state.toggled && ((this.errors.length > 0) || (this.warns.length > 0))) {
			showAdditionalWindow('window-info', 'Notifications', 'Notifications', R.fragment(
				R.btn('×', this.clear, 'Hide all', 'close-window-btn'),
				R.div({ className: 'status-body' },
					h(InfoList, { ref: this.errorsListRef, id: 'errors-list', title: 'Errors:', icon: errorIcon, className: 'info-errors-list info-list', list: this.errors, itemsMap: this.errorsMap }),
					h(InfoList, { ref: this.warnsListRef, id: 'warns-list', title: 'Warnings:', icon: warnIcon, className: 'info-warns-list info-list', list: this.warns, itemsMap: this.warnsMap })
				)
			), 40, 70, 100, 100, 400, 100);
		} else {
			hideAdditionalWindow('window-info');
		}
		return R.span();
	}
}

function getErrorDetailsUrl(errorCode?: number) {
	if (errorCode && (errorCode < 90000)) {
		return ' DETAILS: ' + Help.getUrlForError(errorCode);
	}
	return '';
}

function showLastInfoLine() {
	setTimeout(() => {
		const elements = document.querySelectorAll('.status-body .info-item');
		const element = elements[elements.length - 1];
		if (element) {
		 scrollInToView(element as HTMLElement);
		}
	}, 10);
}

const selectableSceneNodeProps = { className: 'selectable-scene-node' };

interface InfoListProps extends ClassAttributes<InfoList> {
	list: StatusListItem[];
	itemsMap: StatusItemsOwnersMap;
	id: string;
	title: string;
	icon: ComponentChild;
	className: string;
}

class InfoList extends ComponentDebounced<InfoListProps> {

	constructor(props: InfoListProps) {
		super(props);
		this.renderItem = this.renderItem.bind(this);
	}

	clearItem(item: StatusListItem) {
		let i = this.props.list.indexOf(item);
		assert(i >= 0, 'info list is corrupted');
		this.props.list.splice(i, 1);
		if (item.owner instanceof Container) {
			let exData = item.owner.__nodeExtendData;
			this.props.itemsMap.delete(exData);
		}
		game.editor.ui.status.refresh();
	}

	renderItem(item: StatusListItem, i: number) {

		let node;
		if (item.owner && item.owner instanceof Container) {
			node = R.div(selectableSceneNodeProps, R.sceneNode(item.owner));
		}
		return R.div({
			key: i, className: 'info-item clickable', title: 'Click line to go problem.', onClick: async (ev: PointerEvent) => {
				lastClickedItem = item;
				lastClickedList = this;

				if (typeof item.owner === 'function') {
					(item.owner as (ev: PointerEvent) => void)(ev);
				} else if (item.owner && (item.owner instanceof Container)) {
					let extendData = item.owner.__nodeExtendData;
					if ((item.owner.___id !== item.ownerId) || (extendData.statusWarnOwnerId !== item.ownerId)) {
						let newOwnerFinded = false;

						game.forAllChildrenEverywhere((o) => {
							if (o.constructor === (item.owner as Container).constructor && o.___id === item.ownerId) {
								if (!newOwnerFinded) {
									item.owner = o;
									newOwnerFinded = true;
								}
							}
						});

						if (!newOwnerFinded) {
							game.editor.ui.modal.showInfo('Object already removed form stage, or problem was solved.', undefined, 32042);
							return;
						}
					}
					game.editor.ui.sceneTree.selectInTree(item.owner, false, item.fieldName, item.fieldArrayItemNumber);
					shakeDomElement(document.querySelector('#sceneTree .item-selected') as HTMLElement);
				}
			}
		}, this.props.icon, item.message, node, R.btn('?', () => {
			Help.openErrorCodeHelp(item.errorCode);
		}, 'Open description for this notification (F1)', 'error-status-help-button', { key: 'F1' }), R.btn('×', () => {
			this.clearItem(item);
		}, 'Hide notification', 'clear-item-btn danger-btn')
		);
	}

	render() {
		if (this.props.list.length <= 0) {
			return R.div();
		}
		const items = this.props.list.map(this.renderItem) as GroupFolderData;
		items.__subFolderName = items.__folderName = this.props.title;
		return R.div(null,
			R.div({ className: 'info-badge' }, this.props.list.length),
			group.renderGroup(items, this.props.id)
		);
	}
}
</file>

<file path="src/editor/ui/tip.ts">
import type { ClassAttributes } from 'preact';
import { Component } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import game from 'thing-editor/src/engine/game';

const tipProps = { className: 'tip-container' };

function renderTextBlock(t: string, i: number) {
	return R.div({ className: 'tip-paragraph', key: i, dangerouslySetInnerHTML: { __html: t } });
}

interface TipProps extends ClassAttributes<Tip> {
	id: string;
	text: string;
	header: string;
}

export default class Tip extends Component<TipProps> {

	constructor(props: TipProps) {
		super(props);
		this.onDiscardClick = this.onDiscardClick.bind(this);
		this.onMouseDown = this.onMouseDown.bind(this);
	}

	onDiscardClick() {
		game.editor.settings.setItem('tip-discard-' + this.props.id, true);
		game.editor.ui.modal.hideModal();
		game.editor.ui.refresh();
	}

	onMouseDown() {
		game.editor.ui.modal.showModal(R.span(tipProps, R.btn('× discard', this.onDiscardClick, 'Discard this tooltip permanently', 'tip-discard-btn'),
			this.props.text.split('\n').map(renderTextBlock)
		), this.props.header);
	}

	render() {
		if (game.editor.settings.getItem('tip-discard-' + this.props.id)) {
			return R.span();
		}
		return R.span({ className: 'tip-icon', onMouseDown: this.onMouseDown }, '?');
	}
}
</file>

<file path="src/editor/ui/tree-view/tree-node-context-menu.ts">
import type { Container } from 'pixi.js';
import { Sprite } from 'pixi.js';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ContextMenuItem } from 'thing-editor/src/editor/ui/context-menu';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import { toggleIsolation } from 'thing-editor/src/editor/ui/isolation';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import PrefabEditor from '../../utils/prefab-editor';


const selectInvisibleParent = (node: Container) => {
	let o = editorUtils.findInvisibleParent(node);
	if (o) {
		if (!o.visible) {
			game.editor.selection.select(o);
			game.editor.ui.propsEditor.selectField('visible', true);
		} else if (o.alpha < 0.01) {
			game.editor.selection.select(o);
			game.editor.ui.propsEditor.selectField('alpha', true);
		} else if (Math.abs(o.scale.x) < 0.001) {
			game.editor.selection.select(o);
			game.editor.ui.propsEditor.selectField('scale.x', true);
		} else if (Math.abs(o.scale.y) < 0.001) {
			game.editor.selection.select(o);
			game.editor.ui.propsEditor.selectField('scale.y', true);
		} else if (o.__hideInEditor) {
			game.editor.selection.select(o);
			game.editor.ui.propsEditor.selectField('__hideInEditor', true);
		} else if ((o instanceof Sprite) && (o.image === 'EMPTY') && (o === game.editor.selection[0])) {
			game.editor.ui.propsEditor.selectField('image', true);
		} else {
			selectInvisibleParent(o);
		}
	}
};

const TREE_NODE_CONTEXT_MENU: ContextMenuItem[] = [
	{
		name: R.fragment(R.icon('copy'), 'Copy'),
		onClick: editorUtils.onCopyClick,
		disabled: () => {
			return game.editor.selection.length === 0;
		},
		hotkey: { key: 'c', ctrlKey: true }
	},
	{
		name: R.fragment(R.icon('copy'), 'Copy name'),
		onClick: () => {
			if (game.editor.selection[0]?.name) {
				game.editor.copyToClipboard(game.editor.selection[0].name as string);
			}
		},
		disabled: () => !game.editor.selection[0]?.name
	},
	{
		name: R.fragment(R.icon('cut'), 'Cut'),
		onClick: editorUtils.onCutClick,
		disabled: () => !editorUtils.canDelete(),
		hotkey: { key: 'x', ctrlKey: true }
	},
	{
		name: R.fragment(R.icon('paste'), 'Paste'),
		onClick: editorUtils.onPasteClick,
		disabled: () => !editorUtils.canPaste(),
		hotkey: { key: 'v', ctrlKey: true }
	},
	{
		name: R.fragment(R.icon('paste-wrap'), 'Paste wrap'),
		tip: 'Wrap selected content with clipboard container.',
		onClick: editorUtils.onPasteWrapClick,
		hotkey: { key: 'v', ctrlKey: true, altKey: true }
	},
	null,
	{
		name: R.fragment(R.icon('clone'), 'Clone'),
		onClick: editorUtils.clone,
		hotkey: { key: 'd', ctrlKey: true },
		disabled: () => !game.editor.selection.length || game.editor.selection[0] === game.currentContainer
	},
	{
		name: R.fragment(R.icon('export-selected'), 'Export as PNG...'),
		onClick: () => editorUtils.onExportAsPngClick(game.editor.selection[0])
	},
	{
		name: 'Arrange ❯',
		onClick: (ev?: PointerEvent) => {
			showContextMenu(TREE_NODE_CONTEXT_ARRANGE_MENU, ev!);
		}
	},
	null,
	{
		name: 'Change type...',
		onClick: () => { game.editor.ui.propsEditor.onChangeClassClick(); },
	},
	{
		name: 'Go to Source code >>>',
		tip: 'Double click on tree node to go to it`s source code.',
		onClick: () => {
			const Class = game.editor.selection[0].constructor as SourceMappedConstructor;
			game.editor.editClassSource(Class, Class.__className);
		}
	},
	{
		name: 'Why invisible? >>>',
		onClick: () => selectInvisibleParent(game.editor.selection[0]),
		disabled: () => {
			return !editorUtils.findInvisibleParent(game.editor.selection[0]);
		}
	},
	{
		name: R.fragment(R.icon('asset-prefab'), 'Save as prefab...'),
		onClick: () => {
			editorUtils.savePrefab(game.editor.selection[0]);
		},
		disabled: () => game.editor.selection.length !== 1 || game.editor.selection[0] instanceof Scene
	},
	{
		name: R.fragment(R.icon('asset-prefab'), 'Edit prefab'),
		hidden: () => {
			return game.__EDITOR_mode ? !game.editor.selection[0].__nodeExtendData.isPrefabReference : !game.editor.selection[0].__nodeExtendData.__deserializedFromPrefab;

		},
		onClick: () => {
			const prefabName = game.__EDITOR_mode ? game.editor.selection[0].__nodeExtendData.isPrefabReference! : game.editor.selection[0].__nodeExtendData.__deserializedFromPrefab!;
			if (!game.__EDITOR_mode) {
				game.editor.ui.viewport.stopExecution();
			}
			PrefabEditor.editPrefab(prefabName, true);
		}
	},
	{
		name: R.fragment(R.icon('asset-prefab'), 'Unreference'),
		onClick: () => {
			const reference = game.editor.selection[0];
			delete reference.__nodeExtendData.isPrefabReference;
			for (const c of reference.children) {
				delete c.__nodeExtendData.hidden;
			}
			Lib.__savePrefab(reference, '___tmp', undefined, false);
			const notReference = Lib.__loadPrefabNoInit('___tmp');
			notReference.name = reference.name;

			reference.parent.addChildAt(notReference, reference.parent.children.indexOf(reference));
			reference.remove();
			game.editor.ui.sceneTree.selectInTree(notReference);
			Lib.__invalidateSerializationCache(notReference);
			game.editor.refreshTreeViewAndPropertyEditor();
			game.editor.sceneModified(false);
		},
		disabled: () => game.editor.selection.length !== 1 || !game.editor.selection[0].__nodeExtendData.isPrefabReference
	},
	null,
	{
		name: R.fragment(R.icon('isolate-selected'), 'Isolate'),
		tip: 'Temporary hides other content to focus on current selection.',
		onClick: toggleIsolation,
		disabled: () => EDITOR_FLAGS.isolationEnabled || game.editor.selection.indexOf(game.currentContainer) >= 0,
		hotkey: { key: 'i', ctrlKey: true }
	},
	{
		name: R.fragment(R.icon('exit-isolation'), 'Exit isolation'),
		tip: 'Unhide temporary hidden objects.',
		onClick: toggleIsolation,
		disabled: () => !EDITOR_FLAGS.isolationEnabled,
		hotkey: { key: 'i', ctrlKey: true }
	},
	{
		name: R.fragment(R.icon('delete'), 'Delete'),
		onClick: editorUtils.deleteSelected,
		disabled: () => !editorUtils.canDelete(),
		hotkey: { key: 'Delete' }
	},
	{
		name: R.fragment(R.icon('unwrap'), 'Unwrap'),
		tip: 'Remove selected contaner but keeps children.',
		onClick: editorUtils.onUnwrapClick,
		disabled: () => !editorUtils.isCanBeUnwrapped(),
		hotkey: { key: 'Delete', ctrlKey: true }
	}
];

const TREE_NODE_CONTEXT_ARRANGE_MENU: ContextMenuItem[] = [
	{
		name: R.fragment(R.icon('bring-up'), 'Bring top'),
		onClick: editorUtils.onBringUpClick,
		disabled: () => game.editor.selection.length < 1,
		stayAfterClick: true,
		hotkey: { key: 'ArrowUp', altKey: true, ctrlKey: true }
	},
	{
		name: R.fragment(R.icon('move-up'), 'Move top'),
		onClick: editorUtils.onMoveUpClick,
		disabled: () => game.editor.selection.length < 1,
		stayAfterClick: true,
		hotkey: { key: 'ArrowUp', altKey: true }
	},
	{
		name: R.fragment(R.icon('move-down'), 'Move bottom'),
		onClick: editorUtils.onMoveDownClick,
		disabled: () => game.editor.selection.length < 1,
		stayAfterClick: true,
		hotkey: { key: 'ArrowDown', altKey: true }
	},
	{
		name: R.fragment(R.icon('bring-down'), 'Bring bottom'),
		onClick: editorUtils.onBringDownClick,
		disabled: () => game.editor.selection.length < 1,
		stayAfterClick: true,
		hotkey: { key: 'ArrowDown', altKey: true, ctrlKey: true }
	},
	null,
	{
		name: '← shift left',
		onClick: () => {
			game.editor.editProperty('x', -1, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.x,
		stayAfterClick: true,
		hotkey: { key: 'ArrowLeft' }
	},
	{
		name: '→ shift right',
		onClick: () => {
			game.editor.editProperty('x', 1, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.x,
		stayAfterClick: true,
		hotkey: { key: 'ArrowRight' }
	},
	{
		name: '↑ shift up',
		onClick: () => {
			game.editor.editProperty('y', -1, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.y,
		stayAfterClick: true,
		hotkey: { key: 'ArrowUp' }
	},
	{
		name: '↓ shift down',
		onClick: () => {
			game.editor.editProperty('y', 1, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.y,
		stayAfterClick: true,
		hotkey: { key: 'ArrowDown' }
	},
	{
		name: '⬅ shift left x10',
		onClick: () => {
			game.editor.editProperty('x', -10, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.x,
		stayAfterClick: true,
		hotkey: { key: 'ArrowLeft', ctrlKey: true }
	},
	{
		name: '⮕ shift right x10',
		onClick: () => {
			game.editor.editProperty('x', 10, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.x,
		stayAfterClick: true,
		hotkey: { key: 'ArrowRight', ctrlKey: true }
	},
	{
		name: '⬆ shift up x10',
		onClick: () => {
			game.editor.editProperty('y', -10, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.y,
		stayAfterClick: true,
		hotkey: { key: 'ArrowUp', ctrlKey: true }
	},
	{
		name: '⬇ shift down x10',
		onClick: () => {
			game.editor.editProperty('y', 10, true);
		},
		disabled: () => !game.editor.ui.propsEditor.editableProps.y,
		stayAfterClick: true,
		hotkey: { key: 'ArrowDown', ctrlKey: true }
	}
];

export { TREE_NODE_CONTEXT_ARRANGE_MENU, TREE_NODE_CONTEXT_MENU };
</file>

<file path="src/editor/ui/tree-view/tree-node.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes } from 'preact';
import { h } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import { TREE_NODE_CONTEXT_MENU } from 'thing-editor/src/editor/ui/tree-view/tree-node-context-menu';
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';

let caretClosed = R.img({ className: 'tree-caret', src: '/thing-editor/img/caret.png' });
let caretOpened = R.img({ className: 'tree-caret', src: '/thing-editor/img/caret-open.png' });

let lastClickedItem: TreeNode | null;

interface TreeNodeProps extends ClassAttributes<TreeNode> {
	node: Container;

}

class TreeNode extends ComponentDebounced<TreeNodeProps> {

	constructor(props: TreeNodeProps) {
		super(props);

		this.onClick = this.onClick.bind(this);
	}

	onClick(ev: PointerEvent) { // == select nodes
		sp(ev);

		window.getSelection()?.empty();

		let extendData = this.props.node.__nodeExtendData;

		if (extendData.treeNodeView !== this) { // object was removed but tree is outdated yet
			return;
		}

		if ((isClickedAtRightEdge(ev)) && nodeHasExpandableChildren(this.props.node)) {
			extendData.childrenExpanded = !extendData.childrenExpanded;
			if (!extendData.childrenExpanded) {
				collapseChildrenRecursively(this.props.node);
			} else if (ev.altKey) {
				expandChildrenRecursively(this.props.node);
			}
			this.refresh();
			return;
		}

		if (ev.shiftKey && lastClickedItem && (lastClickedItem.props.node.parent === this.props.node.parent)) {
			let p = this.props.node.parent;
			let i1 = p.getChildIndex(lastClickedItem.props.node);
			let i2 = p.getChildIndex(this.props.node);
			let from = Math.min(i1, i2);
			let to = Math.max(i1, i2);
			while (from <= to) {
				let n = p.getChildAt(from) as Container;
				if (n !== lastClickedItem.props.node) {
					game.editor.selection.select(n, true, undefined, true);
				}
				from++;
			}
		} else {
			game.editor.selection.select(this.props.node, (ev.ctrlKey || ev.metaKey), undefined, true);
		}

		if (extendData.isSelected) {
			lastClickedItem = this;
		}
		game.editor.blurPropsInputs();
	}

	static clearLastClicked() {
		lastClickedItem = null;
	}

	render() {
		let node = this.props.node;
		let extendData = node.__nodeExtendData;
		extendData.treeNodeView = this;
		let children;
		let caret;
		if (nodeHasExpandableChildren(node)) {
			if (extendData.childrenExpanded) {
				caret = caretOpened;
				children = R.div({ className: 'tree-children' },
					node.children.map(renderSceneNode as any)
				);
			} else {
				caret = caretClosed;
			}
		}
		let className = 'tree-item';

		if (extendData.isSelected) {
			if (!lastClickedItem) {
				lastClickedItem = this;
			}
			className += ' item-selected';
		}

		if (extendData.isPrefabReference) {
			className += (extendData.unknownPrefab ? ' item-prefab-reference-unknown' : ' item-prefab-reference');
		}

		let style;
		if (extendData.hidden || extendData.isolate) {
			style = { display: 'none' };
		}

		const treeInjection = node.__treeInjection ? node.__treeInjection() : undefined; /// 99999

		return R.fragment(R.div({
			onDblClick: (ev: PointerEvent) => {
				if (!isClickedAtRightEdge(ev) && !(ev.ctrlKey || ev.metaKey)) {
					game.editor.editClassSource(node);
				}
			},
			onContextMenu: (ev: PointerEvent) => {
				onContextMenu(node, ev);
			},
			className,
			style,
			onClick: this.onClick,
			onDragStart(ev: DragEvent) {
				selectIfNotSelected(node);
				ev.dataTransfer!.setData('text/drag-thing-editor-tree-selection', '');
			},
			draggable: node.parent !== game.stage
		}, R.sceneNode(node), caret), treeInjection, children);
	}
}


const selectIfNotSelected = (node: Container) => {
	if (game.editor.selection.indexOf(node) < 0) {
		game.editor.selection.select(node);
	}
};

const onContextMenu = (node: Container, ev: PointerEvent) => {

	selectIfNotSelected(node);

	sp(ev);
	showContextMenu(TREE_NODE_CONTEXT_MENU, ev);
};

const isNodeVisibleInTree = (node: Container) => {
	return !node.__nodeExtendData.hidden;
};

function nodeHasExpandableChildren(node: Container) {
	return node.children.some(isNodeVisibleInTree) && !node.__hideChildren;
}

function isClickedAtRightEdge(ev: PointerEvent) {
	let b = ((ev.currentTarget as HTMLElement).closest('.scene-tree-view') as HTMLElement).getBoundingClientRect();
	return (b.right - ev.clientX) < 40;
}

function collapseChildrenRecursively(node: Container) {
	node.__nodeExtendData.childrenExpanded = false;
	if (node.hasOwnProperty('children')) {
		node.children.some(collapseChildrenRecursively as any);
	}
}

function expandChildrenRecursively(node: Container) {
	node.__nodeExtendData.childrenExpanded = true;
	if (node.hasOwnProperty('children')) {
		node.children.some(expandChildrenRecursively as any);
	}
}

export default TreeNode;

const renderSceneNode = (node: Container) => {
	if (node.__nodeExtendData.hidden) {
		return;
	}
	assert(typeof node.___id === 'number', 'scene object without ___id detected.', 40902);
	return h(TreeNode, { node: node, key: node.___id });
};

export { renderSceneNode };
</file>

<file path="src/editor/ui/tree-view/tree-view.ts">
import type { Container } from 'pixi.js';
import type { ClassAttributes } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import Window from 'thing-editor/src/editor/ui/editor-window';
import { toggleIsolation } from 'thing-editor/src/editor/ui/isolation';
import StatusBar from 'thing-editor/src/editor/ui/status-bar';
import { renderSceneNode } from 'thing-editor/src/editor/ui/tree-view/tree-node';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import { getSerializedObjectClass } from 'thing-editor/src/editor/utils/generate-editor-typings';
import getParentWhichHideChildren from 'thing-editor/src/editor/utils/get-parent-with-hidden-children';
import loadSafeInstanceByClassName from 'thing-editor/src/editor/utils/load-safe-instance-by-class-name';
import { scrollInToView } from 'thing-editor/src/editor/utils/scroll-in-view';
import Selection from 'thing-editor/src/editor/utils/selection';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import { mouseHandlerGlobal } from 'thing-editor/src/engine/utils/game-interaction';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import shakeDomElement from '../../utils/shake-element';

function onEmptyClick() {
	game.editor.selection.clearSelection(true);
}

type SearchEntry = string[];
let searchEntries: Map<Container, SearchEntry> = new Map();
let currentSearchedField: string | undefined;
function addSearchEntry(o: Container, propertyName: string) {
	let a: SearchEntry;
	if (!searchEntries.has(o)) {
		a = [];
		searchEntries.set(o, a);
	} else {
		a = searchEntries.get(o) as SearchEntry;
	}
	a.push(propertyName);
}

const onContextMenu = (ev: PointerEvent) => {
	showContextMenu([
		{
			name: R.fragment(R.icon('paste'), 'Paste'),
			onClick: editorUtils.onPasteClick,
			disabled: () => !editorUtils.canPaste()
		}
	], ev);
};

let highlightedDragItem: HTMLDivElement | null = null;
let pointerToItemRelationY = 0;
let dragTargetNode: Container;
let dragTargetExpandTimeOut = 0;
let dragTargetExpandTimeOutTarget: null | Container = null;

function hideDragTarget() {
	if (highlightedDragItem) {
		highlightedDragItem.classList.remove('drag-target-top');
		highlightedDragItem.classList.remove('drag-target-bottom');
		highlightedDragItem.classList.remove('drag-target-mid');
		highlightedDragItem.classList.remove('drag-target-wrap');
		StatusBar.removeStatus('drag-tree-wrap');
		StatusBar.removeStatus('drag-alt');
		highlightedDragItem = null;
	}
}

function canBeDragAccepted(ev: DragEvent) {
	for (let i of ev.dataTransfer!.items) {
		if (i.type === 'text/drag-thing-editor-class-id' ||
			i.type === 'text/drag-thing-editor-prefab-name' ||
			i.type === 'text/drag-thing-editor-tree-selection') {
			return i.type;
		}
	}
}

function clearDragExpandTimeOut() {
	if (dragTargetExpandTimeOut) {
		clearTimeout(dragTargetExpandTimeOut);
		dragTargetExpandTimeOut = 0;
		dragTargetExpandTimeOutTarget = null;
	}
}

function addToParentSafe(ClassId: string, prefabName: string, parent: Container, isClone?: boolean, nodeAt?: Container, atShift?: number) {
	let Classes!: SourceMappedConstructor[];
	if (prefabName) {
		Classes = [getSerializedObjectClass(Lib.prefabs[prefabName])];
	} else if (ClassId) {
		Classes = [game.classes[ClassId]];
	} else {
		Classes = game.editor.selection.map(c => c.constructor as SourceMappedConstructor);
	}

	if (Classes.every(Class => game.editor.isCanBeAddedAsChild(Class, parent))) {
		let nodes!: Container[];
		if (ClassId) {
			nodes = [loadSafeInstanceByClassName(ClassId, false)];
		} else if (prefabName) {
			nodes = [Lib.__loadPrefabReference(prefabName)];
		} else {
			if (isClone) {
				editorUtils.clone();
			}
			nodes = game.editor.selection.slice();

		}
		game.editor.selection.clearSelection();

		if (nodeAt) {
			nodes.reverse();
		}

		let p = parent;
		while (p) {
			if (nodes.indexOf(p) >= 0) {
				game.editor.ui.modal.notify('can not drop inside it self.');
				return;
			}
			p = p.parent;
		}

		for (const node of nodes) {
			game.editor.addTo(parent, node);
			if (nodeAt) {
				parent.addChildAt(node, parent.children.indexOf(nodeAt) + (atShift || 0));
			}
		}
	} else {
		game.editor.ui.modal.notify('can not drop this object here.');
	}
}

interface TreeViewState {
	search: string;
}

export default class TreeView extends ComponentDebounced<ClassAttributes<TreeView>, TreeViewState> {

	treeViewProps: any;

	constructor() {
		super();
		this.onSearchKeyDown = this.onSearchKeyDown.bind(this);
		this.onSearchChange = this.onSearchChange.bind(this);

		this.state = { search: game.editor.settings.getItem('tree-view-search', '') };

		this.treeViewProps = {
			className: 'scene-tree-view window-scrollable-content',
			onClick: onEmptyClick,
			onContextMenu,
			onDragOver: this.onDragOver.bind(this),
			onDragLeave: this.onDragLeave.bind(this),
			onDrop: this.onDrop.bind(this)
		};
	}

	onDragOver(ev: DragEvent) {
		if (canBeDragAccepted(ev)) {
			const isWrap = (ev.ctrlKey || ev.metaKey); /// 99999
			let treeItem = this.getClosestTreeItem(ev);
			if (treeItem) {
				hideDragTarget();
				highlightedDragItem = treeItem;
				if (Math.abs(pointerToItemRelationY) < 4 || isWrap) {
					if (!dragTargetNode.__nodeExtendData.childrenExpanded && dragTargetNode.children.length && !(ev.ctrlKey || ev.metaKey)) { // can expand tree item
						if (dragTargetExpandTimeOutTarget !== dragTargetNode) {
							clearDragExpandTimeOut();
							dragTargetExpandTimeOutTarget = dragTargetNode;
							dragTargetExpandTimeOut = window.setTimeout(() => {
								dragTargetNode.__nodeExtendData.childrenExpanded = true;
								this.refresh();
								dragTargetExpandTimeOut = 0;
								dragTargetExpandTimeOutTarget = null;
							}, 400);
						}
					} else {
						clearDragExpandTimeOut();
					}
					if (isWrap) {
						treeItem.classList.add('drag-target-wrap');
					} else {
						treeItem.classList.add('drag-target-mid');
					}
				} else {
					clearDragExpandTimeOut();
				}

				if (pointerToItemRelationY < 0) {
					if (dragTargetNode.parent !== game.stage) {
						treeItem.classList.add('drag-target-top');
					}
				} else {
					treeItem.classList.add('drag-target-bottom');
				}
				StatusBar.addStatus(CTRL_READABLE + ' - to "wrap" mode', 'drag-tree-wrap');

			} else {
				hideDragTarget();
			}

			if (canBeDragAccepted(ev) === 'text/drag-thing-editor-tree-selection') {
				StatusBar.addStatus('Alt - to clone object', 'drag-alt');
				ev.dataTransfer!.effectAllowed = ev.altKey ? 'copy' : 'move';
				ev.dataTransfer!.dropEffect = ev.altKey ? 'copy' : 'move';
			} else {
				ev.dataTransfer!.effectAllowed = isWrap ? 'move' : 'copy';
				ev.dataTransfer!.dropEffect = isWrap ? 'move' : 'copy';
			}
			ev.preventDefault();
		}
	}

	onDragLeave() {
		clearDragExpandTimeOut();
		hideDragTarget();
	}

	onDrop(ev: DragEvent) {
		mouseHandlerGlobal(ev as any);
		if (highlightedDragItem) {
			const ClassId = ev.dataTransfer!.getData('text/drag-thing-editor-class-id');
			const prefabName = ev.dataTransfer!.getData('text/drag-thing-editor-prefab-name');

			if (highlightedDragItem!.classList.contains('drag-target-wrap')) {
				if (ClassId) {
					editorUtils.wrap([dragTargetNode], loadSafeInstanceByClassName(ClassId));
				} else if (prefabName) {
					editorUtils.wrap([dragTargetNode], Lib.__loadPrefabReference(prefabName));
				} else {
					let c = game.editor.selection[0];
					while (c) {
						if (c === dragTargetNode) {
							game.editor.ui.modal.notify('Can not drop inside it self');
							return;
						}
						c = c.parent;
					}
					editorUtils.wrap([dragTargetNode], game.editor.selection[0]);
				}
			} else if (highlightedDragItem!.classList.contains('drag-target-mid')) {
				addToParentSafe(ClassId, prefabName, dragTargetNode, ev.altKey); // drop as children
			} else if (highlightedDragItem!.classList.contains('drag-target-bottom')) {
				if ((dragTargetNode.__nodeExtendData.childrenExpanded && dragTargetNode.children.length) || (dragTargetNode.parent === game.stage)) {
					addToParentSafe(ClassId, prefabName, dragTargetNode, ev.altKey, dragTargetNode.children[0],); //drop to top of children list
				} else {
					addToParentSafe(ClassId, prefabName, dragTargetNode.parent, ev.altKey, dragTargetNode, 1); //drop after
				}
			} else {
				addToParentSafe(ClassId, prefabName, dragTargetNode.parent, ev.altKey, dragTargetNode); //drop before
			}

			clearDragExpandTimeOut();
			hideDragTarget();
		}
	}

	getClosestTreeItem(ev: DragEvent) {
		let treeItem = (ev.target as HTMLDivElement).closest('.scene-node-item') as HTMLDivElement;
		if (!treeItem) {
			const allItems = (this.base as HTMLDivElement).closest('.window-content')!.querySelectorAll('.scene-node-item') as any as HTMLDivElement[];
			let closestDist = Number.MAX_VALUE;
			for (let item of allItems) {
				const itemBox = item.getBoundingClientRect();
				const dist = Math.abs(ev.clientY - (itemBox.y + itemBox.height / 2));
				if (dist < closestDist) {
					closestDist = dist;
					treeItem = item;

				}
			}
		}
		if (treeItem) {
			const itemBox = treeItem.getBoundingClientRect();
			pointerToItemRelationY = ev.clientY - (itemBox.y + itemBox.height / 2);
			dragTargetNode = game.currentContainer;
			const overedId = parseInt(treeItem.innerText.split(/#|\n/)[1]);
			game.currentContainer.forAllChildren((c: Container) => {
				if (overedId === c.___id) {
					dragTargetNode = c;
				}
			});
		}
		return treeItem;
	}

	private selectingNode?: Container;

	selectInTree(node: Container, add = false, fieldName?: string, fieldArrayItemNumber = -1) {
		assert(node, 'Attempt to select in tree empty node');
		this.selectingNode = node;
		game.editor.selection.select(node, add, () => {
			if (this.selectingNode !== node) { //select and shake last node only
				return;
			}
			if (fieldName && !add) {
				game.editor.ui.propsEditor.selectField(fieldName, false, false, fieldArrayItemNumber);
			}

			let e = document.querySelector('.scene-tree-view .item-selected') as HTMLElement;
			if (e) {
				Window.bringWindowForward(e.closest('.window-body') as HTMLElement);
				scrollInToView(e);
				(e.closest('.scene-tree-view') as HTMLElement).scrollLeft = 0;
				if (!fieldName) {
					shakeDomElement(e);
				}
			}
		});
	}

	shouldComponentUpdate() {
		return false;
	}

	onSearchKeyDown(ev: KeyboardEvent) {
		if (this.state.search && (ev.code === 'Enter') && !ev.repeat) {
			this.fundNextBySearch();
		}
	}

	onSearchChange(ev: InputEvent) {
		const val = (ev.target as HTMLInputElement).value;
		const search = val;
		const needSearch = !this.state.search || (this.state.search.length < search.length);
		this.setState({ search }, () => {
			if (needSearch) {
				this.fundNextBySearch();
			}
		});
		game.editor.settings.setItem('tree-view-search', val);
	}

	fundNextBySearch() {

		this.findNext((o: Container) => {
			let ret;
			if (getParentWhichHideChildren(o)) {
				return;
			}

			const search = this.state.search.toLowerCase();

			if ((o.constructor as SourceMappedConstructor).__className.toLowerCase().includes(search)) return true;
			if (o.__nodeExtendData.unknownConstructor?.toLowerCase().includes(search)) return true;

			if (o.__nodeExtendData.isPrefabReference && o.__nodeExtendData.isPrefabReference.toLocaleLowerCase().includes(search)) return true;

			let props = (o.constructor as SourceMappedConstructor).__editableProps;
			for (let p of props) {
				if (p.renderer?.search) {
					let data = (o as KeyedObject)[p.name];
					if (data) {
						const r = (p.renderer?.search as PropertySearchHandler)(search, data, p, o, addSearchEntry);
						if (r) {
							ret = r;
						}
					}
				} else if (p.type !== 'splitter') {
					let val = '' + (o as KeyedObject)[p.name];
					if (val.toLowerCase().includes(search)) {
						addSearchEntry(o, p.name);
						ret = true;
					}
				}
			}
			return ret;
		}, 1);
	}

	findNext(condition: (o: Container) => boolean | undefined, direction: -1 | 1) {
		searchEntries.clear();

		let a = new Selection();

		const searchIn = (o: Container) => {
			if (!o.__nodeExtendData.isolate) {
				if (condition(o)) {
					a.push(o);
				}
				o.forAllChildren((o) => {
					if (!o.__nodeExtendData.isolate && condition(o)) {
						a.push(o);
					}
				});
			}
		};

		if (game.__EDITOR_mode) {
			searchIn(game.currentContainer);
		} else {
			game.stage.forAllChildren((o) => {
				if (!o.__nodeExtendData.isolate && condition(o)) {
					a.push(o);
				}
			});
		}

		if (a.length > 0) {

			a.sortSelectedNodes();

			let field: string | undefined;
			let i = a.indexOf(game.editor.selection[0]);
			if (i >= 0) {
				let o = game.editor.selection[0];
				if (searchEntries.has(o)) {
					let entries = searchEntries.get(o) as SearchEntry;
					let i = entries.findIndex(e => (e === currentSearchedField));
					if (i >= 0) {
						i++;
						field = entries[i];
					} else {
						field = entries[0];
					}
				}
				if (!field) {
					i += direction;
					if (i < 0) i = a.length - 1;
					if (i >= a.length) i = 0;
				}
			} else {
				i = 0;
			}
			if (!field) {
				let o = a[i];
				if (searchEntries.has(o)) {
					field = (searchEntries.get(o) as SearchEntry)[0];
				}
			}

			currentSearchedField = field;
			this.selectInTree(a[i], false, field);
		} else {
			game.editor.selection.clearSelection(true);
		}
	}

	render() {
		if (!game.stage) return R.span();
		return R.fragment(
			R.input({ onKeyDown: this.onSearchKeyDown, onInput: this.onSearchChange, className: 'tree-view-search', value: this.state.search, placeholder: 'Search' }),
			this.state.search ? R.btn('search', () => this.fundNextBySearch(), undefined, 'hidden', { key: 'F3' }) : undefined,
			EDITOR_FLAGS.isolationEnabled ? R.btn('exit isolation', toggleIsolation, undefined, 'clickable isolation-warning', { key: 'i', ctrlKey: true }) : undefined,
			R.div(this.treeViewProps,
				game._getScenesStack().map(renderSceneStackItem as any),
				game.stage.children.map(renderRoots as any)
			)
		);
	}
}

const renderRoots = (node: Container, i: number) => {
	if (node === game.currentContainer) {
		return renderSceneNode(node);
	} else if (!game.__EDITOR_mode) {
		let style;
		if (node.__nodeExtendData.hidden) {
			style = { display: 'none' };
		}
		return R.div({ className: 'inactive-scene-item', style, key: 'na-' + i, title: 'This scene node is blocked by modal object for now.' }, R.sceneNode(node));
	}
};

const renderSceneStackItem = (s: Scene, i: number, a: Scene[]) => {
	let body;
	if ((s === game.currentScene) && (i === (a.length - 1))) {
		return undefined;
	} else if (typeof s === 'string') {
		body = R.span(null, 'waiting for instancing: ' + s);
	} else {
		body = R.sceneNode(s);
	}


	return R.div({ className: 'stacked-scene-item', title: 'This scene currently in stack.', key: i },
		body
	);
};

export type PropertySearchHandler = (textToSearch:string, data:any, property:EditablePropertyDesc, o:Container, addSearchEntry: (o: Container, propertyName: string) => void) => boolean;
</file>

<file path="src/editor/ui/ui.ts">
import type { ComponentChild } from 'preact';
import { h, render } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import AssetsView from 'thing-editor/src/editor/ui/assets-view/assets-view';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import Window from 'thing-editor/src/editor/ui/editor-window';
import MainMenu from 'thing-editor/src/editor/ui/main-menu';
import Modal from 'thing-editor/src/editor/ui/modal';
import PropsEditor from 'thing-editor/src/editor/ui/props-editor/props-editor';
import Status from 'thing-editor/src/editor/ui/status';
import StatusBar from 'thing-editor/src/editor/ui/status-bar';
import { TREE_NODE_CONTEXT_ARRANGE_MENU, TREE_NODE_CONTEXT_MENU } from 'thing-editor/src/editor/ui/tree-view/tree-node-context-menu';
import TreeView from 'thing-editor/src/editor/ui/tree-view/tree-view';
import Viewport from 'thing-editor/src/editor/ui/viewport';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import game from 'thing-editor/src/engine/game';

interface UIProps {
	onUIMounted: (ui: UI) => void;
}

const workingAreaProps = {
	id: 'working-area'
};

export default class UI extends ComponentDebounced<UIProps> {

	modal!: Modal;
	viewport!: Viewport;
	sceneTree!: TreeView;
	propsEditor!: PropsEditor;
	status!: Status;

	constructor() {
		super();

		this.modalRef = this.modalRef.bind(this);
		this.viewportRef = this.viewportRef.bind(this);
		this.sceneTreeRef = this.sceneTreeRef.bind(this);
		this.propsEditorRef = this.propsEditorRef.bind(this);
		this.statusRef = this.statusRef.bind(this);
	}

	componentDidMount(): void {
		this.props.onUIMounted(this);
	}

	protected viewportRef(viewport: Viewport | null) {
		this.viewport = viewport as Viewport;
	}

	protected sceneTreeRef(sceneTree: TreeView | null) {
		this.sceneTree = sceneTree as TreeView;
	}

	protected modalRef(ref: Modal | null) {
		this.modal = ref as Modal;
	}

	protected propsEditorRef(ref: PropsEditor | null) {
		this.propsEditor = ref as PropsEditor;
	}

	protected statusRef(ref: Status | null) {
		this.status = ref as Status;
	}

	render(): ComponentChild {
		return R.fragment(
			R.btn('prevent page kill', (ev) => {
				ev.preventDefault();
			}, undefined, 'hidden', { key: 'w', ctrlKey: true }),
			h(MainMenu, null),
			R.div(workingAreaProps,
				h(Window, {
					id: 'sceneTree',
					helpId: 'SceneTree',
					title: 'Scene tree',
					content: h(TreeView, { ref: this.sceneTreeRef }),
					x: 0, y: 0, w: 17, h: 70, minW: 150, minH: 150,
					hotkeysHandlers: [TREE_NODE_CONTEXT_MENU, TREE_NODE_CONTEXT_ARRANGE_MENU]
				}),

				h(Window, {
					id: 'propsEditor',
					helpId: 'Properties',
					title: 'Properties',
					content: h(PropsEditor, {
						ref: this.propsEditorRef
					}),
					x: 17,
					y: 0,
					w: 34,
					h: 70,
					minW: 250,
					minH: 150
				}),

				h(Window, {
					id: 'viewport',
					helpId: 'Viewport',
					title: R.span(null, 'Viewport: ', game.editor.projectDesc ? R.b(null, PrefabEditor.currentPrefabName || game.editor.currentSceneName) : undefined, h(StatusBar, null)),
					content: h(Viewport, { ref: this.viewportRef }),
					x: 34,
					y: 0,
					w: 100,
					h: 70,
					minW: 64,
					minH: 460,
					onResize: () => {
						if (game.projectDesc) {
							game._onContainerResize();
						}
					}
				}),

				AssetsView.renderAssetsViews(),

				h(Status, { ref: this.statusRef }),
				h(Modal, { ref: this.modalRef })
			)
		);
	}

}

const additionalWindowsContainers: Map<string, HTMLDivElement> = new Map();


function showAdditionalWindow(id: string, helpId: string, title: ComponentChild, content: ComponentChild,
	x: number, y: number, w: number, _h: number, minW: number, minH: number, onResize?: () => void) {
	if (!additionalWindowsContainers.has(id)) {
		let c = window.document.createElement('div');
		c.classList.add('additional-window-layer');
		window.document.querySelector('#working-area')!.appendChild(c);
		additionalWindowsContainers.set(id, c);
	}

	render(h(Window, { id, helpId, title, content, x, y, w, h: _h, minW, minH, onResize }), additionalWindowsContainers.get(id) as HTMLDivElement);
}

function hideAdditionalWindow(id: string) {
	if (additionalWindowsContainers.has(id)) {
		render(R.fragment(), additionalWindowsContainers.get(id) as HTMLDivElement);
	}
}

export { hideAdditionalWindow, showAdditionalWindow };
</file>

<file path="src/editor/ui/viewport.ts">
import { type Container } from 'pixi.js';
import type { ClassAttributes, ComponentChild } from 'preact';
import { h } from 'preact';
import ClassesLoader from 'thing-editor/src/editor/classes-loader';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';
import showContextMenu from 'thing-editor/src/editor/ui/context-menu';
import 'thing-editor/src/editor/ui/editor-overlay';
import { exitIsolation } from 'thing-editor/src/editor/ui/isolation';

import SelectEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import copyTextByClick from 'thing-editor/src/editor/utils/copy-text-by-click';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import libInfo from 'thing-editor/src/editor/utils/lib-info';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import type { FixedViewportSize } from 'thing-editor/src/engine/game';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import MusicFragment from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music/music-fragment';
import Keys from 'thing-editor/src/engine/utils/keys';
import Pool from 'thing-editor/src/engine/utils/pool';
import Sound from 'thing-editor/src/engine/utils/sound';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import DataAccessDebugger from '../utils/data-access-debugger';
import { StatusClearingCondition } from './status-clearing-condition';

const PLAY_ICON = R.icon('play');
const STOP_ICON = R.icon('stop');
const PAUSE_ICON = R.icon('pause');

let playTogglingTime = false;

let prefabTitleProps = { className: 'prefabs-mode-title' };
let prefabLabelProps = {
	className: 'selectable-text',
	title: CTRL_READABLE + '+click to copy prefab`s name',
	onMouseDown: copyTextByClick
};

export const enum PREFAB_PIVOT {
	MIDDLE = 'middle',
	LEFT_TOP = 'left-top'
}

export const __SystemBackDropPivots = [
	{
		name: R.icon('pivot/middle') as any,
		value: PREFAB_PIVOT.MIDDLE
	},
	{
		name: R.icon('pivot/left-top') as any,
		value: PREFAB_PIVOT.LEFT_TOP
	}
];

const ORIENTATION_ICON = R.icon('orientation-toggle');

const SPEED_SELECT = [0.1, 0.25, 0.5, 1, 2, 4, 8, 16, 32].map((value) => {
	return { value, name: '×' + value };
});

const onBgColorChange = (ev: InputEvent) => {
	PrefabEditor.BGColor = parseInt((ev.target as HTMLInputElement).value.replace('#', ''), 16);
};

interface ViewportStats {
	prefabMode: string | null;
}

document.addEventListener('fullscreenchange', () => {
	game.onResize();
});

interface ViewportSizeItem {
	name: string;
	value: FixedViewportSize;
}

const resolutions: ViewportSizeItem[] = [
	{ name: 'Responsive', value: false },
	{ name: 'Fixed', value: true },
	{ name: 'Pixel 2 XL', value: { w: 823, h: 411 } },
	{ name: 'iPhone 8', value: { w: 667, h: 375 } },
	{ name: 'iPhone X', value: { w: 812, h: 375 } },
	{ name: 'iPad', value: { w: 1024, h: 768 } }
];

export default class Viewport extends ComponentDebounced<ClassAttributes<Viewport>, ViewportStats> {

	viewportScale = 1;

	constructor(props: ClassAttributes<Viewport>) {
		super(props);
		this.onTogglePlay = this.onTogglePlay.bind(this);
		this.onPauseResumeClick = this.onPauseResumeClick.bind(this);
		this.onDoubleClick = this.onDoubleClick.bind(this);
		this.stopExecution = this.stopExecution.bind(this);
		this.onOneStepClick = this.onOneStepClick.bind(this);
		this.showResolutionSelectMenu = this.showResolutionSelectMenu.bind(this);
		editorEvents.once('projectDidOpen', () => {
			this.setSpeed(game.editor.settings.getItem('speed', 1));
			this.restoreResolution();
		});
	}

	addResolution(resolution: typeof resolutions[0]) {
		if (!resolutions.some(r => r.name === resolution.name)) {
			resolutions.push(resolution);
		}
	}

	restoreResolution() {
		let currentResolutionSettings = JSON.stringify(game.editor.settings.getItem('viewportMode', null));
		let currentItem = resolutions.find((i) => {
			return currentResolutionSettings === JSON.stringify(i.value);
		});
		if (currentItem) {
			this.setCurrentResolution(currentItem);
		}
	}

	showResolutionSelectMenu(ev: PointerEvent) {
		showContextMenu(
			resolutions.map((resolutionItem) => {
				return {
					name: R.span({ className: (resolutionItem === this.currentResolution) ? 'current-menu-item' : undefined },
						resolutionItem.name, ((typeof resolutionItem.value === 'boolean') ? undefined : R.span({ className: 'resolution' }, ' (' + resolutionItem.value.w + ' х ' + resolutionItem.value.h + ')'))),
					onClick: () => {
						game.editor.settings.setItem('viewportMode', resolutionItem.value);
						this.setCurrentResolution(resolutionItem);
					}
				};
			}), ev);
	}

	onTogglePlay() {
		if (!playTogglingTime && !game.editor.__FatalError) {

			Keys.resetAll();

			playTogglingTime = true;

			this.resetZoom();
			game.__doOneStep = false;
			game.__paused = false;
			let play = game.__EDITOR_mode;
			game.__time = 0;
			PrefabEditor.acceptPrefabEdition();
			Sound.__resetSounds();
			Pool.__resetIdCounter();
			editorEvents.emit('playToggle');
			if (play) { // launch game
				DataAccessDebugger.initializeGameData();
				(game.data as SelectableProperty).___EDITOR_isGoodForChooser = true;
				(game.data as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

				exitIsolation();
				game.editor.ui.status.clearByCondition(StatusClearingCondition.LAUNCH_GAME);
				game.editor.saveBackup();
				game.editor.selection.saveCurrentSelection();
				game.__clearStage();

				game.__EDITOR_mode = false;
				game._setCurrentScene(null);
				const backupName = game.editor.currentSceneBackupName;

				game.showScene(Lib.hasScene(backupName) ? backupName : game.editor.currentSceneName);
				game.stage.interactiveChildren = true;
			} else { //stop game
				EDITOR_FLAGS.isStoppingTime = true;
				game.__EDITOR_mode = true;
				game.__clearStage();
				game.editor.restoreBackup();
				EDITOR_FLAGS.isStoppingTime = false;
				game.stage.interactiveChildren = false;
			}

			this.forceUpdate();

			playTogglingTime = false;
			game.onResize();
		}
	}

	onPauseResumeClick() {
		game.__paused = !game.__paused;
		this.forceUpdate();
		game.editor.refreshPropsEditor();
	}

	onOneStepClick() {
		game.__doOneStep = true;
		this.forceUpdate();
	}

	setPrefabMode(enabled: string | null = null) {
		this.setState({ prefabMode: enabled });
	}

	stopExecution() {
		PrefabEditor.acceptPrefabEdition();
		if (!game.__EDITOR_mode) {
			this.onTogglePlay();
		}
	}

	onDoubleClick(ev: PointerEvent) {
		if ((ev.ctrlKey || ev.metaKey)) {
			this.resetZoom();
		}
	}

	resetZoom() {
		game.stage.scale.x = 1;
		game.stage.scale.y = 1;
		if (PrefabEditor.currentPrefabName) {
			game.stage.x = game.W / 2;
			game.stage.y = game.H / 2;
		} else {
			game.stage.x = 0;
			game.stage.y = 0;
		}
	}

	currentResolution = resolutions[0];

	setCurrentResolution(resolution: ViewportSizeItem) {
		if (!game.projectDesc.dynamicStageSize) {
			return;
		}
		this.currentResolution = resolution;
		game.__setFixedViewport(resolution.value);
	}

	scrollInToScreen(node: Container) {
		let b = node.getGlobalPosition();

		if (b.x > game.W) {
			game.stage.x -= b.x - game.W / 2;
		} else if (b.x < 0) {
			game.stage.x += -b.x + game.W / 2;
		}

		if (b.y > game.H) {
			game.stage.y -= b.y - game.H / 2;
		} else if (b.y < 0) {
			game.stage.y += -b.y + game.H / 2;
		}
	}

	render(): ComponentChild {
		let className = 'editor-viewport-wrapper';

		let panel: ComponentChild;
		let statusHeader: ComponentChild;

		let resolutionSelect;
		if (game.editor.projectDesc) {
			resolutionSelect = game.projectDesc.dynamicStageSize ?
				R.fragment(
					R.div({
						className: 'resolution clickable',
						onMouseDown: this.showResolutionSelectMenu
					},
					R.div(null, this.currentResolution.name),
					R.div(null, game.W + '×' + game.H),
					),
					R.hr()
				) :
				R.fragment(
					R.div(null, game.W + '×' + game.H),
					R.hr()
				);
		}

		const reloadClassesBtn = R.btn(R.icon('recompile'), game.editor.reloadClasses, ClassesLoader.isClassesWaitsReloading ? 'Source code modified externally. Click to load changes.' : 'Reload classes', ClassesLoader.isClassesWaitsReloading ? 'big-btn red-frame' : 'big-btn');
		const orientationButton = (game.editor.projectDesc && game.editor.projectDesc.screenOrientation === 'auto') ? R.btn(ORIENTATION_ICON, game.editor.toggleScreenOrientation, 'Portrait/Landscape switch', undefined, { key: 'r', ctrlKey: true }) : undefined;
		let prefabFile = this.state.prefabMode && fs.getFileByAssetName(this.state.prefabMode, AssetType.PREFAB);
		if (!prefabFile && this.state.prefabMode) {
			PrefabEditor.exitPrefabEdit(true); // prefab removed
		}
		if (prefabFile) {
			className += ' editor-viewport-wrapper-prefab-mode';


			let fileLibraryName = prefabFile.lib;
			if (fileLibraryName) {
				className += ' editor-viewport-wrapper-prefab-mode-lib';
			}

			panel = R.span(panelWrapperProps,
				R.span(panelProps,
					reloadClassesBtn,
					R.hr(),
					R.div(prefabTitleProps, 'Prefab: ', R.br(), R.b(prefabLabelProps, this.state.prefabMode)),
					R.hr(),
					fileLibraryName ? libInfo(prefabFile) : undefined,
					R.btn(R.icon('accept'), (ev) => {
						if (ev instanceof KeyboardEvent) {
							if ((ev.target as HTMLInputElement)?.tagName === 'INPUT' || (ev.target as HTMLInputElement)?.tagName === 'TEXTAREA') {
								(ev.target as HTMLInputElement).blur();
								return;
							}
						}
						PrefabEditor.acceptPrefabEdition(true);
					}, 'Accept prefab changes', 'main-btn', { key: 'Enter' }),
					R.btn(R.icon('reject'), () => {
						if (game.editor.isCurrentContainerModified) {
							game.editor.ui.modal.showEditorQuestion(
								'Are you sure?',
								'Are you really wanted to discard all changes made in prefab?',
								() => { PrefabEditor.exitPrefabEdit(true); },
								'Discard changes.'
							);
						} else {
							PrefabEditor.exitPrefabEdit(true);
						}
					}, 'Reject prefab changes', undefined, { key: 'Escape' }),
					R.hr(),
					R.input({
						onInput: onBgColorChange,
						className: 'clickable',
						type: 'color',
						value: '#' + PrefabEditor.BGColor.toString(16).padStart(6, '0'),
						title: 'Background color'
					}),
					h(SelectEditor, {select: __SystemBackDropPivots,
						onChange: (value: PREFAB_PIVOT) => {
							PrefabEditor.pivot = value;
							this.refresh();
							game.editor.onObjectsPropertyChanged(game.currentContainer, '__prefabPivot', value);
						}, value: PrefabEditor.pivot || __SystemBackDropPivots[0].value
					})
				),
				R.span(panelBottomProps,
					orientationButton,
					R.hr(),
					resolutionSelect
				)
			);
		} else {
			let pauseResumeBtn, oneStepBtn;
			if (game && !game.__EDITOR_mode) {
				pauseResumeBtn = R.btn(game.__paused ? PLAY_ICON : PAUSE_ICON, this.onPauseResumeClick, 'Pause/Resume', 'big-btn', { key: 'p', ctrlKey: true });
				if (game.__paused) {
					statusHeader = R.div({ className: 'red-blink' }, 'paused');
					oneStepBtn = R.btn('One step', this.onOneStepClick, undefined, 'big-btn', { key: 'BracketLeft', ctrlKey: true });
				} else {
					statusHeader = R.div(null, 'running');
				}
			}

			panel = R.span(panelWrapperProps,
				R.span(panelProps,
					reloadClassesBtn,
					R.hr(),
					R.btn((!game || game.__EDITOR_mode) ? PLAY_ICON : STOP_ICON, this.onTogglePlay, 'Play/Stop', 'big-btn', { key: 'Space', ctrlKey: true }),
					R.br(),
					statusHeader,
					pauseResumeBtn,
					oneStepBtn,
					(statusHeader) && R.hr()

				),
				R.span(panelBottomProps,
					orientationButton,
					R.hr(),
					resolutionSelect,
					R.btn('⛶', () => {
						if (document.fullscreenElement) {
							document.exitFullscreen();
						} else {
							(document.querySelector('#viewport-root') as HTMLElement).requestFullscreen().then(() => {
								game.onResize();
							});
						}
					}, 'Go fullscreen', 'big-btn', { key: 'ENTER', altKey: true }),
					R.hr(),
					'Speed:',
					h(SelectEditor, {
						onChange: (val) => {
							this.setSpeed(val);
						},
						noCopyValue: true,
						value: game.editor.settings.getItem('speed', 1),
						select: SPEED_SELECT
					}),
					R.hr()
				)
			);
		}


		return R.div({ className },
			panel,
			R.div({
				id: 'viewport-root',
				className: 'editor-viewport',
				onDblClick: this.onDoubleClick
			})
		);
	}

	setSpeed(speed:number) {
		game.pixiApp.ticker.speed = speed;
		MusicFragment.__applyGameSpeed(speed);
		this.forceUpdate();
		game.editor.settings.setItem('speed', speed);
	}
}

const panelWrapperProps = {
	className: 'viewport-panel-wrapper'
};

const panelProps = {
	className: 'viewport-panel'
};

const panelBottomProps = {
	className: 'viewport-panel viewport-bottom-panel'
};
</file>

<file path="src/editor/ui/window-menu.ts">
import type { ComponentChild } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import ComponentDebounced from 'thing-editor/src/editor/ui/component-debounced';

const windowMenuBodyProps = { className: 'window-menu-body' };

interface WindowMenuProps {
	menu: ComponentChild;
}

interface WindowMenuState {
	toggled?: boolean;
}

export default class WindowMenu extends ComponentDebounced<WindowMenuProps, WindowMenuState> {

	constructor(props: WindowMenuProps) {
		super(props);
		this.onMouseLeave = this.onMouseLeave.bind(this);
	}
	onMouseLeave() {
		if (this.state.toggled) {
			this.setState({ toggled: false });
		}
	}

	render() {
		let body: ComponentChild;
		if (this.state.toggled) {
			body = R.div(windowMenuBodyProps, this.props.menu);
		}
		return R.div({
			className: 'window-menu',
			onMouseLeave: this.onMouseLeave
		}, R.btn('...', () => {
			this.setState({ toggled: !this.state.toggled });
		}, undefined, 'window-menu-btn'), body);
	}

}
</file>

<file path="src/editor/utils/build.ts">
import type { FileDesc, FileDescClass, FileDescImage, FileDescPrefab, FileDescScene, FileDescSound } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import enumAssetsPropsRecursive from 'thing-editor/src/editor/utils/enum-assets-recursive';
import getHashedAssetName from 'thing-editor/src/editor/utils/get-hashed-asset-name';
import game, { DEFAULT_FADER_NAME, PRELOADER_SCENE_NAME } from 'thing-editor/src/engine/game';
import Lib, { isAtlasAsset } from 'thing-editor/src/engine/lib';
import type { AssetsDescriptor, SoundAssetEntry } from '../editor-env';
import { StatusClearingCondition } from '../ui/status-clearing-condition';

const addedCallbacks: Set<string> = new Set();
const postBuildCallbacks: ((path: string) => void)[] = [];
const preBuildCallbacks: ((debug: boolean) => void)[] = [];

function addPostBuildScript(callback: (outPath: string) => void, id: string) {
	if (!addedCallbacks.has(id + '-post-build')) {
		addedCallbacks.add(id + '-post-build');
		postBuildCallbacks.push(callback);
	}
}

/** you can add generated properties to game.ProjectDesc by adding them to game.editor.forceProjectDescPropsInBuild */
function addPreBuildScript(callback: (debug: boolean) => void, id: string) {
	if (!addedCallbacks.has(id + '-pre-build')) {
		addedCallbacks.add(id + '-pre-build');
		preBuildCallbacks.push(callback);
	}
}

let prefixToCutOff: '___' | '__';

function isFileNameValidForBuild(name: string) {
	return !name.startsWith(prefixToCutOff) && (!name.includes('/' + prefixToCutOff));
}

function filterAssets(file: FileDesc) {
	return isFileNameValidForBuild(file.assetName);
}

const filterChildrenByName = (childData: SerializedObject) => {

	if (childData.p?.name &&
		childData.p.name.startsWith(prefixToCutOff)) {
		return false;
	}
	if (childData.r &&
		!isFileNameValidForBuild(childData.r)) {
		return false;
	}
	return true;
};

const fieldsFilter = (key: string, value: any) => {
	if (!key.startsWith(prefixToCutOff)) {
		if (key === ':' && Array.isArray(value)) { // cut off __ objects
			return value.filter(filterChildrenByName);
		}
		return value;
	}
	if (typeof value === 'object') { //its prefab or scene data
		if (isFileNameValidForBuild(key)) {
			return value;
		}
	}
};

function getAssetsForBuild(type: AssetType.FONT): FileDesc[];
function getAssetsForBuild(type: AssetType.CLASS): FileDescClass[];
function getAssetsForBuild(type: AssetType.SOUND): FileDescSound[];
function getAssetsForBuild(type: AssetType.IMAGE): FileDescImage[];
function getAssetsForBuild(type: AssetType.PREFAB): FileDescPrefab[];
function getAssetsForBuild(type: AssetType.SCENE): FileDescScene[];
function getAssetsForBuild(type: AssetType) {
	return fs.getAssetsList(type).filter(filterAssets);
}

let assetsToCopy: { from: string; to: string }[] = [];

export default class Build {
	static async build(debug: boolean) {

		game.editor.ui.status.clearByCondition(StatusClearingCondition.BUILD_PROJECT);

		fs.removeSubAsset('src/__beforeprojectopen', AssetType.CLASS);
		game.editor.ui.modal.showSpinner();
		fs.log(debug ? 'build debug' : 'build release');

		for (const f of preBuildCallbacks) {
			await f(debug);
		}

		let projectDesc = JSON.parse(JSON.stringify(game.projectDesc)) as ProjectDesc;
		Object.assign(projectDesc, game.editor.forceProjectDescPropsInBuild);

		game.editor.forceProjectDescPropsInBuild = {};

		game.editor.validateResources();

		assetsToCopy = [];

		if (game.editor.askSceneToSaveIfNeed() === false) {
			return;
		}

		prefixToCutOff = (debug ? '___' : '__');

		const preloaderAssets: Set<FileDesc> = new Set();
		preloaderAssets.add(fs.getFileByAssetName(PRELOADER_SCENE_NAME, AssetType.SCENE));
		preloaderAssets.add(fs.getFileByAssetName(DEFAULT_FADER_NAME, AssetType.PREFAB));
		const fonts = fs.getAssetsList(AssetType.FONT);
		for (const font of fonts) {
			preloaderAssets.add(font);
		}
		enumAssetsPropsRecursive(Lib.scenes[PRELOADER_SCENE_NAME], preloaderAssets);

		const text = projectDesc.embedLocales ?
			game.editor.LanguageView.__getTextAssets()
			:
			undefined;

		///////////////////////////////////////////////////////////
		/// assets-preloader.json ////////////////////////////////
		/////////////////////////////////////////////////////////
		saveAssetsDescriptor(preloaderAssets, 'assets-preloader.json', projectDesc, text);

		const mainAssets: Set<FileDesc> = new Set();
		const allAssets = fs.getAssetsList();
		for (let asset of allAssets) {
			if (!preloaderAssets.has(asset)) {
				mainAssets.add(asset);
			}
		}

		///////////////////////////////////////////////////////////
		/// assets-main.json /////////////////////////////////////
		/////////////////////////////////////////////////////////
		saveAssetsDescriptor(mainAssets, 'assets-main.json');

		let scenesFiles = getAssetsForBuild(AssetType.SCENE);
		let prefabsFiles = getAssetsForBuild(AssetType.PREFAB);
		let classesFiles = getAssetsForBuild(AssetType.CLASS) as FileDescClass[];

		classesFiles.sort((a, b) => {
			if (a.assetName > b.assetName) {
				return 1;
			} else if (a.assetName < b.assetName) {
				return -1;
			}
			return 0;
		});

		const classesNames:string[] = [];
		let src = [`/* this file is generated by thing-editor.
Please do not modify it. Any changes will be overridden anyway.*/

import Lib from 'thing-editor/src/engine/lib';`];

		const findRef = (class_: SourceMappedConstructor): boolean => {
			let name = class_.__className;
			if (findClassNameInAssetFiles(name, scenesFiles) || findClassNameInAssetFiles(name, prefabsFiles)) {
				return true;
			}
			return classesFiles.some((c: FileDescClass) => {
				return (c.asset.prototype instanceof class_) && findRef(c.asset.prototype.constructor as SourceMappedConstructor);
			});
		};

		classesFiles = classesFiles.filter(f => findRef(f.asset));

		for (const classFile of classesFiles) {
			if (classFile.asset.__requiredComponents) {
				for (const requiredClass of classFile.asset.__requiredComponents) {
					if (!requiredClass.__classAsset) {
						game.editor.ui.status.warn(classFile.asset.__className + '.__requiredComponents contains wrong component: ' + (requiredClass.name || requiredClass), 99999, undefined, undefined, undefined, undefined, StatusClearingCondition.BUILD_PROJECT);
					} else {
						if (classesFiles.indexOf(requiredClass.__classAsset) < 0) {
							classesFiles.push(requiredClass.__classAsset);
						}
					}
				}
			}
		}

		for (let classFile of classesFiles) {
			let name = classFile.asset.__className;
			classesNames.push(name);
			let path = classFile.fileName;

			if (path.startsWith('/')) {
				path = path.substr(1);
			}
			src.push('import ' + name + ' from \'' + path + '\';');
			src.push(name + '.__defaultValues = ' + JSON.stringify(classFile.asset.__defaultValues, fieldsFilter) + ';');
		}


		src.push('const classes:KeyedObject = {' + classesNames.join(',') + '};');
		src.push('Lib._setClasses(classes);');
		fs.writeFile('.tmp/classes.ts', src.join('\n'));

		const reversedDirsList = game.editor.assetsFoldersReversed;

		for (let dir of reversedDirsList) {
			const htmlName = dir + 'index.html';
			if (fs.exists(htmlName)) {
				fs.writeFile('.tmp/index.html', fs.readFile(htmlName).replace(/\%__project-assets-dir__\%\//gm, game.editor.currentProjectAssetsDir));
				break;
			}
		}

		await fs.build(game.editor.currentProjectDir, debug, assetsToCopy, projectDesc).then(async (result: any) => {


			if (result instanceof Error) {
				const a = result.message.split('\n');
				if (a.length > 1) {
					const b = (a[1] as string).split(':');
					const i = b.findIndex(t => t.indexOf('ERROR') >= 0);
					if (i > 3) {
						const lineNum = b[i - 2];
						const charNum = b[i - 1];
						b.length = i - 2;
						const fileName = b.join(':');

						game.editor.editSource(fileName, lineNum, charNum, true);
					}
				} else {
					const a = result.message.split(' in file ');
					if (a.length > 1) {
						const b = (a[1] as string).split(':');
						const lineNum = b[b.length - 1];
						const fileName = a[1];
						game.editor.editSource(fileName, lineNum, undefined, true);
					}
				}
				game.editor.ui.modal.showError(renderTextWithFilesLinks(result.message), 99999, 'Build error!');
			} else {
				const path = game.editor.currentProjectDir + (debug ? 'debug/' : 'release/');
				for (const f of postBuildCallbacks) {
					await f(path);
				}
				if (!game.editor.buildProjectAndExit) {
					game.editor.ui.modal.showEditorQuestion('Build', 'Builded successfully.', () => {
						game.editor.openUrl('http://localhost:5174/' + path);
					}, 'Open');
				}
			}
			game.editor.ui.modal.hideSpinner();
		});
	}
}

function findClassNameInAssetFiles(className: string, assets: FileDesc[]) {
	for (let prefab of assets) {
		if (findClassNameInPrefabData(className, prefab.asset as SerializedObject)) return true;
	}
}

function findClassNameInPrefabData(name: string, data: SerializedObject): boolean {
	if (!filterChildrenByName(data)) {
		return false;
	}
	if (data.c === name) {
		return true;
	}
	if (data.hasOwnProperty(':')) {
		return data[':']!.some((d) => {
			return findClassNameInPrefabData(name, d);
		});
	}
	return false;
}

function getAssetsToCopy(assets: Set<FileDesc>, originalFileNames = false) {
	assetsToCopy = [];
	enumAssetsToCopy(assets, originalFileNames);
	return assetsToCopy;
}

function enumAssetsToCopy(assets: Set<FileDesc>, originalFileNames = false) {
	let images: string[] = [];

	let sounds: SoundAssetEntry[] = [];

	const scenes: KeyedMap<SerializedObject> = {};
	const prefabs: KeyedMap<SerializedObject> = {};

	let resources: string[] | undefined;
	let xmls: string[] | undefined;
	let fonts: string[] | undefined;

	const hashed = (file:FileDesc) => {
		return originalFileNames ? '' : getHashedAssetName(file);
	};

	assets.forEach((file) => {
		if (isFileNameValidForBuild(file.assetName)) {
			if (file.assetType === AssetType.IMAGE) {
				if (!Lib.__isSystemTexture((file as FileDescImage).asset, file.assetName)) {
					if (!file.parentAsset) {
						assetsToCopy.push({
							from: file.fileName,
							to: hashed(file)
						});
						images.push(hashed(file));
					}
				}
			} else if (file.assetType === AssetType.SCENE) {
				scenes[file.assetName] = file.asset as SerializedObject;
			} else if (file.assetType === AssetType.PREFAB) {
				prefabs[file.assetName] = file.asset as SerializedObject;
			} else if (file.assetType === AssetType.SOUND) {
				for (let ext of (originalFileNames ? ['wav'] : game.projectDesc.soundFormats)) {
					if (!file.parentAsset) {
						assetsToCopy.push({
							from: file.fileName.replace(/\wav$/, ext),
							to: hashed(file) + '.' + ext
						});
					}
				}
				sounds.push([hashed(file), (file as FileDescSound).asset.preciseDuration]);
			} else if (file.assetType === AssetType.RESOURCE) {
				if (isAtlasAsset(file.asset) || file.includeToBuild) {
					if (!resources) {
						resources = [];
					}
					resources.push(hashed(file));
					assetsToCopy.push({
						from: file.fileName,
						to: hashed(file) + '.json'
					});
					if ((file.asset as any)?.skeleton) {
						assetsToCopy.push({
							from: file.fileName.replace(/\.json$/, '.atlas'),
							to: hashed(file) + '.atlas'
						});
						const allImages = fs.getAssetsList(AssetType.IMAGE);
						const fileRoot = file.fileName.substring(0, file.fileName.length - 5);
						for (const i of allImages) {
							if (i.fileName.startsWith(fileRoot)) {
								assetsToCopy.push({
									from: i.fileName,
									to: hashed(i) + i.fileName.split('.').pop()
								});
							}
						}
					}
				}
			} else if (file.assetType === AssetType.BITMAP_FONT) {
				if (!xmls) {
					xmls = [];
				}
				xmls.push(hashed(file));
				assetsToCopy.push({
					from: file.fileName,
					to: hashed(file) + '.xml'
				});
			} else if (file.assetType === AssetType.FONT) {
				if (!fonts) {
					fonts = [];
				}
				const hashedFontName = hashed(file);
				fonts.push(hashedFontName);
				assetsToCopy.push({
					from: file.fileName,
					to: hashedFontName
				});
			}
		}
	});
	return {
		scenes,
		prefabs,
		resources,
		xmls,
		fonts,
		images,
		sounds
	} as AssetsDescriptor;
}

function saveAssetsDescriptor(assets: Set<FileDesc>, fileName: string, projectDesc?: ProjectDesc, text?: KeyedObject) {
	const content = enumAssetsToCopy(assets);
	content.projectDesc = projectDesc;
	content.text = text;
	fs.writeFile(
		'.tmp/' + fileName,
		JSON.stringify(content, fieldsFilter)
	);
}

function renderTextWithFilesLinks(txt: string) {
	if (txt.indexOf(' in file ') > 0) {
		const a = txt.split(' in file ');
		return R.span(null, a[0], ' in file ', R.a({
			href: '#',
			onClick: () => {
				game.editor.editFile(a[1]);
			}
		}, a[1]));
	}
	return txt;
}

export { addPostBuildScript, addPreBuildScript, getAssetsToCopy };
</file>

<file path="src/editor/utils/button-only-selectable-property.ts">
import game from 'thing-editor/src/engine/game';

const ButtonOnlyPropertyDesc = {
	get: () => {
		return !game.editor.currentPathChoosingField || game.editor.currentPathChoosingField.name.toLocaleLowerCase().indexOf('click') < 0; // TODO check if button callback can choose it
	}
};
export { ButtonOnlyPropertyDesc };
</file>

<file path="src/editor/utils/copy-text-by-click.ts">
import sp from 'thing-editor/src/editor/utils/stop-propagation';
import game from 'thing-editor/src/engine/game';

let __textCopiedFrom: HTMLDivElement | undefined;

const copyTextByClick = (ev: PointerEvent) => {
	if (ev.ctrlKey || ev.metaKey) {
		const target = ((ev.target as HTMLDivElement).closest('.selectable-text') || ev.target) as HTMLDivElement;

		const copyValue = (target.attributes as any).ctrlClickCopyValue;
		game.editor.copyToClipboard(typeof copyValue !== 'undefined' ?
			copyValue.value : (target).innerText);
		sp(ev);
		__textCopiedFrom = target;
	}
};

export default copyTextByClick;

window.addEventListener('mouseup', () => {
	setTimeout(() => {
		__textCopiedFrom = undefined;
	}, 10);
});

const isEventBlockedByTextCopy = (ev:PointerEvent) => {
	return ev.target === __textCopiedFrom;
};
export { isEventBlockedByTextCopy };
</file>

<file path="src/editor/utils/data-access-debugger.ts">
import type { ComponentChild } from 'preact';
import { h, type ClassAttributes } from 'preact';
import game from 'thing-editor/src/engine/game';
import R from '../preact-fabrics';
import ComponentDebounced from '../ui/component-debounced';
import showContextMenu from '../ui/context-menu';
import Window from '../ui/editor-window';
import MainMenu from '../ui/main-menu';
import SelectEditor from '../ui/props-editor/props-editors/select-editor';
import { hideAdditionalWindow, showAdditionalWindow } from '../ui/ui';
import { editorEvents } from './editor-events';
import sp from './stop-propagation';

const enum DataAccessDebuggerMode {
	EQUAL = 'EQUAL',
	LESS = 'LESS',
	BIGGER = 'BIGGER',
	NOT_EQUAL = 'NOT_EQUAL',
	ANY = 'ANY',
}

const MODE_SELECT_LIST = [
	{ name: 'EQUAL', value: DataAccessDebuggerMode.EQUAL },
	{ name: 'LESS', value: DataAccessDebuggerMode.LESS },
	{ name: 'BIGGER', value: DataAccessDebuggerMode.BIGGER },
	{ name: 'NOT_EQUAL', value: DataAccessDebuggerMode.NOT_EQUAL },
	{ name: 'ANY', value: DataAccessDebuggerMode.ANY }
];

interface DataAccessDebugEntry {
	propertyName: string;
	mode: DataAccessDebuggerMode;
	rawValue: string;
	parsedValue: any;
	stringifiedValue: any;

	enabled: boolean;
}

interface DataAccessDebuggerState {
	debugEntries: DataAccessDebugEntry[];
}

let instance: DataAccessDebugger | null;

export default class DataAccessDebugger extends ComponentDebounced<ClassAttributes<DataAccessDebugger>, DataAccessDebuggerState> {

	static gameData: GameData;
	static gameDataProxy: GameData;

	static initializeGameData() {
		this.gameData = {} as any;
		this.gameDataProxy = new Proxy(this.gameData, DataAccessDebugger.handler) as any;
		this.applyDataToGame();
	}

	private static applyDataToGame() {
		if (instance && instance.state.debugEntries.some(e => e.enabled)) {
			game.data = DataAccessDebugger.gameDataProxy;
		} else {
			game.data = DataAccessDebugger.gameData;
		}
		if (instance) {
			game.editor.settings.setItem('debug-data-access', instance.state.debugEntries);
			instance.refresh();
		}
	}

	static refresh() {
		if (instance) {
			instance.refresh();
		}
	}

	static toggle() {
		game.editor.settings.setItem('data-access-debugger-shown', !instance);
		if (!instance) {
			showAdditionalWindow('data-access-debugger', 'data-access-debugger', 'game.data access debugger', h(DataAccessDebugger, null), 40, 70, 100, 100, 300, 100);
			Window.bringWindowForward('#data-access-debugger');
		} else {
			hideAdditionalWindow('data-access-debugger');
		}
	}

	static handler = {
		set: setData_thing_editor_debug_helper,
		deleteProperty: deleteProperty_thing_editor_debug_helper
	};

	constructor() {
		super();
		this.state = {debugEntries: game.editor.settings.getItem('debug-data-access', [])};
	}

	componentDidMount(): void {
		instance = this;
	}

	componentWillUnmount(): void {
		instance = null;
		DataAccessDebugger.applyDataToGame();
	}

	renderDebugEntry(item: DataAccessDebugEntry) {
		return R.div({
			className: item.enabled ? 'data-access-debugger-item' : 'data-access-debugger-item semi-transparent',
			onContextMenu: (ev: PointerEvent) => {
				sp(ev);
				showContextMenu([
					{
						name: 'Delete',
						onClick: () => {
							instance?.state.debugEntries.splice(instance?.state.debugEntries.indexOf(item), 1);
							DataAccessDebugger.applyDataToGame();
						}
					}
				], ev);
			},
		},
		R.input({
			placeholder: 'Property name',
			onInput: (ev: Event) => {
				item.propertyName = ((ev.target as any).value as string).trim();
				DataAccessDebugger.applyDataToGame();
			},
			value: item.propertyName
		}),
		h(SelectEditor, {
			value: item.mode,
			noCopyValue: true,
			onChange: (value : DataAccessDebuggerMode) => {
				item.mode = value;
				DataAccessDebugger.applyDataToGame();
			},
			select: MODE_SELECT_LIST }
		),
		R.input({
			placeholder: 'value',
			onInput: (ev: Event) => {
				let currentValue = (ev.target as any).value;
				try {
					item.parsedValue = JSON.parse(currentValue);
				} catch (_er) {
					item.parsedValue = currentValue;
				}
				item.stringifiedValue = JSON.stringify(item.parsedValue);
				item.rawValue = currentValue;

				DataAccessDebugger.applyDataToGame();
			},
			value: item.rawValue
		}),
		R.input({
			title: 'Enabled',
			onChange: (ev: InputEvent) => {
				item.enabled = (ev.target as HTMLInputElement).checked;
				DataAccessDebugger.applyDataToGame();
			},
			type: 'checkbox',
			checked: item.enabled
		})
		);
	}

	render(): ComponentChild {
		return R.div(
			{
				className: 'data-access-debugger window-scrollable-content'
			},
			R.btn('×', DataAccessDebugger.toggle, 'Hide data access debugger', 'close-window-btn', {key: 'Escape'}),
			this.state.debugEntries.map(this.renderDebugEntry),
			R.div(null, R.btn('+ Add debug entry', () => {
				instance!.state.debugEntries.push({
					enabled: true,
					propertyName: '',
					mode: DataAccessDebuggerMode.EQUAL,
					parsedValue: '',
					rawValue: '',
					stringifiedValue: '""'
				});
				DataAccessDebugger.applyDataToGame();
			}))
		);
	}
}

editorEvents.on('projectDidOpen', () => {
	if (game.editor.settings.getItem('data-access-debugger-shown')) {
		DataAccessDebugger.toggle();
	}
});

function deleteProperty_thing_editor_debug_helper(data:any, prop:any):any {
	for (const item of instance!.state.debugEntries) {
		if ((prop === item.propertyName) && ((item.mode === DataAccessDebuggerMode.ANY) || (typeof item.parsedValue === 'undefined'))) {
			debugger; // access to data detected
		}
	}

	delete data[prop];
	return true;
}

function setData_thing_editor_debug_helper(data:any, prop:any, val:any):any {
	let valueParsed = false;
	let valueToCompare;

	for (const item of instance!.state.debugEntries) {
		if (item.enabled && prop === item.propertyName) {
			if (!item.rawValue) {
				debugger; // access to data detected
			}

			if (!valueParsed) {
				valueToCompare = val;
				if (val && typeof val === 'object') {
					try {
						valueToCompare = JSON.stringify(JSON.parse(val));
					} catch (_er) {}
				}
				valueParsed = true;
			}

			switch (item.mode) {
			case DataAccessDebuggerMode.ANY:
				debugger; // access to data detected
				break;
			case DataAccessDebuggerMode.EQUAL:
				if (valueToCompare == item.parsedValue || valueToCompare == item.stringifiedValue) {
					debugger; // access to data detected
				}
				break;
			case DataAccessDebuggerMode.NOT_EQUAL:
				if (valueToCompare != item.parsedValue && valueToCompare != item.stringifiedValue) {
					debugger; // access to data detected
				}
				break;
			case DataAccessDebuggerMode.BIGGER:
				if (valueToCompare > item.parsedValue) {
					debugger; // access to data detected
				}
				break;
			case DataAccessDebuggerMode.LESS:
				if (valueToCompare < item.parsedValue) {
					debugger; // access to data detected
				}
				break;
			}
		}
	}

	data[prop] = val;
	return true;
}

MainMenu.injectMenu('project', [
	{
		name: 'Debug game.data access...',
		onClick: () => {
			DataAccessDebugger.toggle();
		}
	}
], 'debug-data-access', -1);
</file>

<file path="src/editor/utils/data-path-fixer.ts">
import { Container } from 'pixi.js';
import R from 'thing-editor/src/editor/preact-fabrics';
import makePathForKeyframeAutoSelect from 'thing-editor/src/editor/utils/movie-clip-keyframe-select-path';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import type { TimelineData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

import { getLatestSceneNodeBypath, getLatestSceneNodesByComplexPath } from 'thing-editor/src/engine/utils/get-value-by-path';

/** data about objects, all not empty data-path properties reference to */
let rememberedRefs: Map<Container, KeyedMap<ReferencesData>>;

export default class DataPathFixer {

	static rememberPathReferences() {
		if (beforeNameEditOldValues) {
			DataPathFixer.onNameBlur();
		}
		_validateRefEntryOldNames = undefined;
		_validateRefEntryNewName = undefined;
		if (game.currentScene) {
			game.currentScene._refreshAllObjectRefs();
		}
		rememberedRefs = new Map();
		_rememberPathReference(game.currentContainer);
		game.currentContainer.forAllChildren(_rememberPathReference);
	}

	static validatePathReferences(oldNames?: (string | null)[], newName?: string) {
		_validateRefEntryOldNames = oldNames;
		_validateRefEntryNewName = newName;
		if (game.currentScene) {
			game.currentScene._refreshAllObjectRefs();
		}
		rememberedRefs.forEach(validateRefEntry);
	}

	static beforeNameEdit(newName: string) {
		nameEditNewName = newName;
		if (!beforeNameEditOldValues) {
			DataPathFixer.rememberPathReferences();
			beforeNameEditOldValues = game.editor.selection.map(o => o.name);
		}
	}

	static onNameBlur() {
		if (beforeNameEditOldValues) {
			DataPathFixer.validatePathReferences(beforeNameEditOldValues, nameEditNewName);
			beforeNameEditOldValues = undefined;
		}
	}
}

const ARRAY_ITEM_SPLITTER = ':array-index:';

let nameEditNewName: string;
let beforeNameEditOldValues: (string | null)[] | undefined;

let _validateRefEntryOldNames: (string | null)[] | undefined;
let _validateRefEntryNewName: string | undefined;

const tryToFixDataPath = (node: Container, fieldName: string, path_: string, oldRefs: ReferencesOfDataPath, currentRefs: ReferencesOfDataPath) => {

	let pathes = path_.split(/[,|`]/);
	let atLeastOnePartFixed = false;

	assert(pathes.length === oldRefs.length, 'DataPathFixer refs count does not match.');

	let clones: Container[] = [];
	game.currentContainer.forAllChildren((o) => {
		if (o.__nodeExtendData.__isJustCloned) {
			if (o.name) {
				clones.push(o);
			}
			o.forAllChildren((c) => {
				if (c.name) {
					clones.push(c);
				}
			});
		}
	});

	for (let j = 0; j < oldRefs.length; j++) {

		let currentRef = currentRefs[j];
		let oldRef = oldRefs[j];
		if (currentRef === oldRef) {
			continue;
		}

		let path = pathes[j];

		if (!oldRef || !oldRef.parent) {
			return;
		}

		let repairNode;
		let newPath = path;


		if (clones.length) { //is was clone or paste. try to rename cloned nodes to fix ref
			for (let c of clones) {
				let tmpName = c.name;
				c.name += '-copy';
				game.currentScene._refreshAllObjectRefs();
				repairNode = getLatestSceneNodeBypath(newPath, node);
				if (repairNode === oldRef) {
					break;
				}
				c.name = tmpName;
			}
		}
		if (repairNode !== oldRef) {
			if (_validateRefEntryOldNames) { //it is was renaming. try to fix .#names
				for (let oldName of _validateRefEntryOldNames) {
					if (oldName) {
						oldName = oldName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
						let pathFixer = new RegExp('\\.#' + oldName + '(\\.|$)');
						let pathFixer2 = new RegExp('(\\.all\\.)' + oldName + '(\\.|$)');
						let pathFixer3 = new RegExp('^all\\.' + oldName + '(\\.|$)');
						newPath = newPath.replace(pathFixer, '.#' + _validateRefEntryNewName + '$1');
						newPath = newPath.replace(pathFixer2, '$1' + _validateRefEntryNewName + '$2');
						newPath = newPath.replace(pathFixer3, 'all.' + _validateRefEntryNewName + '$1');
					}
				}
				repairNode = getLatestSceneNodeBypath(newPath, node);
			} else { //node added or removed

				let pathParts = path.split('.');
				for (let i = 0; i < pathParts.length;) { //try to remove one of the part of chain
					i++;
					let a = pathParts.slice(0);
					a.splice(i, 1);
					newPath = a.join('.');
					repairNode = getLatestSceneNodeBypath(newPath, node, true);
					if (repairNode === oldRef) {
						break;
					}
				}

				if (repairNode !== oldRef) { //try to insert "parent" somwhere in chain
					for (let i = 0; i < pathParts.length;) {
						i++;
						let a = pathParts.slice(0);
						a.splice(i, 0, 'parent');
						newPath = a.join('.');
						repairNode = getLatestSceneNodeBypath(newPath, node, true);
						if (repairNode === oldRef) {
							break;
						}
					}
				}

				if (repairNode !== oldRef) { //try to insert new name somewhere in chain
					let changedNode = game.editor.selection[0];
					let changedName = changedNode.name;
					if (!changedName) {
						changedName = 'new' + changedNode.constructor.name;
						let i = 1;
						while (changedNode.parent.getChildByName(changedName + i)) {
							i++;
						}
						changedName += i;
						changedNode.name = changedName;
						Lib.__invalidateSerializationCache(changedNode);
					}
					changedName = '#' + changedName;
					for (let i = 0; i < pathParts.length;) {
						i++;
						let a = pathParts.slice(0);
						a.splice(i, 0, changedName);
						newPath = a.join('.');
						repairNode = getLatestSceneNodeBypath(newPath, node, true);
						if (repairNode === oldRef) {
							break;
						}
					}
				}
			}
		}
		if (repairNode === oldRef) {
			pathes[j] = newPath;
			atLeastOnePartFixed = true;
		} else {
			return;
		}
	}
	assert(atLeastOnePartFixed, 'Path fixing error.');

	//apply fixed path

	let finalPath = pathes.shift();
	if (pathes.length > 0) {
		finalPath += ',' + pathes.join(',');
	}

	let fn = fieldName.split(',');
	let keyframe;
	if (fn.length > 1) {
		//it is keyframe action
		const movieClip = node as MovieClip;
		for (let f of movieClip._timelineData.f) {
			if (f.n === fn[1]) {
				let targetTime = parseInt(fn[2]);
				for (let kf of f.t) {
					if (kf.t == targetTime) {
						keyframe = kf;
						break;
					}
				}
				break;
			}
		}
	}

	if (keyframe) {
		keyframe.a = finalPath;
	} else {
		if (fieldName.indexOf(ARRAY_ITEM_SPLITTER) > 0) {
			const a = fieldName.split(ARRAY_ITEM_SPLITTER); // EditablePropertyDescRaw.arrayProperty
			(node as KeyedObject)[a[0]][a[1]] = finalPath;
		} else {
			(node as KeyedObject)[fieldName] = finalPath;
		}
	}
	Lib.__invalidateSerializationCache(node);
	if ((node as KeyedObject).__invalidateSerializeCache) {
		(node as KeyedObject).__invalidateSerializeCache();
	}
	return true;

};

type ReferencesOfDataPath = (Container | null)[];

interface ReferencesData {
	targetNodes: ReferencesOfDataPath;
	path: string;
}
const rememberRef = (o: Container, path: string, name: string) => {
	if (path) {
		let targetNodes = getLatestSceneNodesByComplexPath(path, o);
		let objectsFieldsRefs = rememberedRefs.get(o);
		if (!objectsFieldsRefs) {
			objectsFieldsRefs = {};
			rememberedRefs.set(o, objectsFieldsRefs);
		}
		objectsFieldsRefs[name] = { targetNodes, path };
	}
};
function _rememberPathReference(o: Container) {
	let props = (o.constructor as SourceMappedConstructor).__editableProps;


	for (let p of props) {
		if (p.type === 'data-path' || p.type === 'callback') {
			if (p.arrayProperty) {
				let a = (o as KeyedObject)[p.name] as string[];
				if (!Array.isArray(a)) {
					a = [a];
				}
				a.forEach((path, i) => {
					rememberRef(o, path, p.name + ARRAY_ITEM_SPLITTER + i);
				});
			} else {
				rememberRef(o, (o as KeyedObject)[p.name], p.name);
			}
		} else if (p.type === 'timeline') {
			let timeline = (o as KeyedObject)[p.name] as TimelineData;
			if (timeline) {
				for (let field of timeline.f) {
					for (let k of field.t) {
						if (k.a) {
							rememberRef(o, k.a, makePathForKeyframeAutoSelect(p, field, k));
						}
					}
				}
			}
		}
	}
}

const validateRefEntry = (m: KeyedMap<ReferencesData>, o: Container) => {
	if (o.parent) {
		for (let fieldName in m) {

			let item = m[fieldName];
			let path = item.path;
			let oldRefs = item.targetNodes;
			let currentRefs = getLatestSceneNodesByComplexPath(path, o);

			for (let i = 0; i < oldRefs.length; i++) {
				if (oldRefs[i] !== currentRefs[i]) {
					if (!tryToFixDataPath(o, fieldName, path, oldRefs, currentRefs)) {

						let oldRef = oldRefs[i];
						let currentRef = currentRefs[i];

						let was;
						if (oldRef instanceof Container) {
							was = R.sceneNode(oldRef);
						} else {
							was = '' + oldRef;
						}
						let become;
						if (currentRef instanceof Container) {
							become = R.sceneNode(currentRef);
						} else {
							become = '' + currentRef;
						}

						let pathParts = path.split(/[,|`]/);
						let splitter = ',';

						let itemIndex = -1;
						if (fieldName.includes(ARRAY_ITEM_SPLITTER)) {
							const a = fieldName.split(ARRAY_ITEM_SPLITTER);
							fieldName = a[0];
							itemIndex = parseInt(a[1]);
						}

						game.editor.ui.status.warn(R.span(null, 'Path reference (', pathParts.map((pathPart: string, partNum: number) => {
							let ret = ((oldRefs[partNum] !== currentRefs[partNum]) ? R.b : R.span)({ key: partNum }, pathPart, partNum < (pathParts.length - 1) ? splitter : undefined);
							splitter = ',';
							return ret;
						}), ') is affected:', R.br(), ' Was: ', was, R.br(), ' Become: ', become), 32016, o, fieldName, false, itemIndex);
					}
				}
			}
		}
	}
};
</file>

<file path="src/editor/utils/debounced-call.ts">
let debounces: Map<() => void, number> = new Map();

const debouncedCall = (f: () => void, timeMs = 0) => {
	if (debounces.has(f)) {
		clearTimeout(debounces.get(f));
		debounces.delete(f);
	}
	debounces.set(f, window.setTimeout(() => {
		debounces.delete(f);
		f();
	}, timeMs));
};

export default debouncedCall;
</file>

<file path="src/editor/utils/editor-events.ts">
import { EventEmitter } from 'events';
import type { Container } from 'pixi.js';
import type TypedEventEmitter from 'typed-emitter';
import EDITOR_FLAGS from './flags';

type EditorEvents = {
	playToggle: () => void;
	projectDidOpen: () => void;
	beforePropertyChanged: (o: Container, fieldName: string, field: EditablePropertyDesc, val: any, isDelta?: boolean) => void;
	afterPropertyChanged: (o: Container, fieldName: string, field: EditablePropertyDesc, val: any, isDelta?: boolean) => void;
	willClassesReload: () => void;
	didClassesReloaded: () => void;
	gameWillBeInitialized: () => void;
	prefabUpdated: (prefabName:string) => void;
	sceneUpdate: (sceneName:string) => void;
	firstSceneWillOpen: () => void;
	assetsRefreshed: () => void;
	textureUpdated: (textureName: string) => void;
	soundPlay: (soundId: string, volume: number) => void;
};

const editorEvents = new EventEmitter() as TypedEventEmitter<EditorEvents>;
editorEvents.setMaxListeners(1000);
const originalOn = editorEvents.on.bind(editorEvents) as any;

(editorEvents as any).on = function proxiedOn(...args:any) {
	if (EDITOR_FLAGS.__classesReloadingTime) {
		(args[1] as any).__userHandler_iIUH213 = true;
	}
	originalOn(...args);
};
(editorEvents as any).__removeUserHandlers = function() {
	for (const key in (editorEvents as any)._events) {
		const a = (editorEvents as any)._events[key] as any;
		if (Array.isArray(a)) {
			for (let i = a.length - 1; i >= 0; i--) {
				const f = a[i];
				if (f.__userHandler_iIUH213) {
					editorEvents.off(key as any, f);
				}
			}
		}
	}
	//
}.bind(editorEvents);

export { editorEvents };
</file>

<file path="src/editor/utils/editor-utils.ts">
import { Container, MIPMAP_MODES, Point, Sprite, WRAP_MODES } from 'pixi.js';
import R, { renderClass } from 'thing-editor/src/editor/preact-fabrics';
import DataPathFixer from 'thing-editor/src/editor/utils/data-path-fixer';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import exportAsPng from 'thing-editor/src/editor/utils/export-as-png';
import getParentWhichHideChildren from 'thing-editor/src/editor/utils/get-parent-with-hidden-children';
import increaseNumberInName from 'thing-editor/src/editor/utils/increase-number-in-name';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib, { constructRecursive } from 'thing-editor/src/engine/lib';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';

import type { ComponentChild } from 'preact';
import type { FileDesc, FileDescClass } from 'thing-editor/src/editor/fs';
import { AssetType } from 'thing-editor/src/editor/fs';

import fs from 'thing-editor/src/editor/fs';
import { regeneratePrefabsTypings } from 'thing-editor/src/editor/utils/generate-editor-typings';
import loadSafeInstanceByClassName from 'thing-editor/src/editor/utils/load-safe-instance-by-class-name';
import L from 'thing-editor/src/engine/utils/l';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';
import type { ClipboardAsset, L10nEntryAsset } from '../editor-env';
import { getAssetsToCopy } from './build';
import copyTextByClick from './copy-text-by-click';
import enumAssetsPropsRecursive from './enum-assets-recursive';
import roundUpPoint from './round-up-point';

const prefabNameFilter = /[^a-zA-Z\-\/0-9_]/g;

const cachedImages = new Set();

const onPreviewButtonClick = (o: Container) => {
	if (o.__nodeExtendData.__isPreviewMode) {
		editorUtils.exitPreviewMode(o);
	} else {
		editorUtils.goToPreviewMode(o);
	}
	game.editor.refreshPropsEditor();
};

const classNamePropertyDescriptor = {
	get: () => {
		let o = game.editor.selection[0];
		return (o.__nodeExtendData.__isPreviewMode) ? 'danger-btn' : undefined;
	}
};

let labelTextProps = {
	className: 'selectable-text labels-log-label',
	title: CTRL_READABLE + '+click to copy key name',
	onMouseDown: copyTextByClick
};

export namespace editorUtils {

	export const findInvisibleParent = (o: Container): Container | undefined => {
		if (!o) {
			return o;
		}
		if (!o.visible || o.alpha < 0.01 || Math.abs(o.scale.x) < 0.001 || Math.abs(o.scale.y) < 0.001 || (game.__EDITOR_mode && o.__hideInEditor) || (o instanceof Sprite && o.image === 'EMPTY' && o === game.editor.selection[0])) {
			return o;
		}
		if (o.parent === game.stage) {
			return;
		}
		return findInvisibleParent(o.parent);
	};

	export const isInModal = (o: EventTarget | HTMLElement | null) => {
		if (o) {
			return (o as HTMLElement).closest('.modal-body');
		}
	};

	export const exitPreviewMode = (o: Container) => {
		if (!o.__nodeExtendData.__isPreviewMode) return;
		editorEvents.off('beforePropertyChanged', o.__exitPreviewMode!);
		o.__exitPreviewMode!();
		o.__nodeExtendData.__isPreviewMode = false;
	};

	export const goToPreviewMode = (o: Container) => {
		if (o.__nodeExtendData.__isPreviewMode) return;
		editorEvents.on('beforePropertyChanged', o.__exitPreviewMode!);
		o.__goToPreviewMode!();
		o.__nodeExtendData.__isPreviewMode = true;
	};

	export const canDelete = () => {
		return (game.editor.selection.length > 0) && (game.editor.selection.indexOf(game.currentContainer) < 0);
	};

	export const deleteSelected = () => {

		const editor = game.editor;

		if ((editor.selection.length > 0) && (editor.selection[0] !== game.currentContainer)) {

			DataPathFixer.rememberPathReferences();

			let p = editor.selection[0].parent;
			let i = p.getChildIndex(editor.selection[0]);

			while (editor.selection.length > 0) {
				let o = editor.selection[0];
				Lib.__invalidateSerializationCache(o.parent);
				o.remove();
			}

			let isAnotherNodeSelected = false;

			while (i < p.children.length) {
				let c = p.getChildAt(i++);
				if (!getParentWhichHideChildren(c, true)) {
					editor.ui.sceneTree.selectInTree(c);
					isAnotherNodeSelected = true;
					break;
				}
			}
			i--;
			if (!isAnotherNodeSelected) {
				while (i >= 0) {
					let c = p.getChildAt(i--);
					if (!getParentWhichHideChildren(c, true)) {
						editor.ui.sceneTree.selectInTree(c);
						isAnotherNodeSelected = true;
						break;
					}
				}
			}

			if (!isAnotherNodeSelected && (p !== game.stage)) {
				editor.ui.sceneTree.selectInTree(p);
			}

			DataPathFixer.validatePathReferences();

			editor.refreshTreeViewAndPropertyEditor();
			editor.sceneModified(true);
		}
	};

	export const centralizeObjectToContent = (o: Container) => {
		if (!o.children.length) {
			return;
		}
		let b = o.getBounds();
		let p;
		if (b.width > 0 || b.height > 0) {
			let b = o.getBounds();
			let midX = b.x + b.width / 2;
			let midY = b.y + b.height / 2;
			p = new Point(midX, midY);
			o.parent.toLocal(p, undefined, p);
		} else {
			let midX = 0;
			for (let c of o.children) {
				midX += c.x;
			}
			midX /= o.children.length;

			let midY = 0;
			for (let c of o.children) {
				midY += c.y;
			}
			midY /= o.children.length;
			p = new Point(midX, midY);
			o.parent.toLocal(p, o, p);
		}

		let pos = o.getGlobalPosition();
		let p2 = new Point();
		o.parent.toLocal(pos, undefined, p2);
		roundUpPoint(pos);

		game.editor.moveContainerWithoutChildren(o, Math.round(p.x - p2.x), Math.round(p.y - p2.y));
	};

	export const makePreviewModeButton = (title: string, helpUrl: string): EditablePropertyDescRaw => {
		let previewBtnProperty: EditablePropertyDescRaw = {
			type: 'btn',
			title,
			helpUrl,
			name: title,
			onClick: onPreviewButtonClick
		};
		Object.defineProperty(previewBtnProperty, 'className', classNamePropertyDescriptor);
		return previewBtnProperty;
	};


	export const clone = () => {
		if (game.editor.selection.some((o) => o.parent === game.stage)) {
			game.editor.ui.modal.showInfo('Can not clone root object', '', 30017);
			return;
		}

		DataPathFixer.rememberPathReferences();

		game.editor.disableFieldsCache = true;
		let allCloned: Container[] = [];

		game.editor.selection.some((o) => {
			let clone: Container = Lib._deserializeObject(Lib.__serializeObject(o));
			allCloned.push(clone);

			let cloneExData = clone.__nodeExtendData;
			let exData = o.__nodeExtendData;
			if (exData.hidePropsEditor) {
				cloneExData.hidePropsEditor = exData.hidePropsEditor;
			}
			if (exData.noSerialize) {
				cloneExData.noSerialize = exData.noSerialize;
			}
			cloneExData.__isJustCloned = true;

			clone.name = increaseNumberInName(clone.name);

			let i = o.parent.children.indexOf(o) + 1;
			while (o.parent.children[i] && ((allCloned.indexOf(o.parent.children[i]) >= 0) || o.parent.children[i].__nodeExtendData.isSelected)) {
				i++;
			}
			o.parent.addChildAt(clone, i);

			if (!game.__EDITOR_mode) {
				constructRecursive(clone);
			}
			Lib.__invalidateSerializationCache(clone);

		});

		game.editor.selection.clearSelection();
		for (let c of allCloned) {
			game.editor.selection.add(c);
		}

		game.editor.disableFieldsCache = false;

		DataPathFixer.validatePathReferences();
		for (let c of allCloned) {
			let cloneExData = c.__nodeExtendData;
			cloneExData.__isJustCloned = false;
		}
		game.editor.refreshTreeViewAndPropertyEditor();
		game.editor.sceneModified();
	};

	export const onDeleteClick = () => {

		if ((game.editor.selection.length > 0) && (game.editor.selection[0] !== game.currentContainer)) {

			DataPathFixer.rememberPathReferences();

			let p = game.editor.selection[0].parent;
			let i = p.getChildIndex(game.editor.selection[0]);

			while (game.editor.selection.length > 0) {
				let o = game.editor.selection[0];
				Lib.__invalidateSerializationCache(o.parent);
				o.remove();
			}

			let isNextChildSelected = false;

			while (i < p.children.length) {
				let c = p.getChildAt(i++);
				if (!getParentWhichHideChildren(c, true)) {
					game.editor.ui.sceneTree.selectInTree(c);
					isNextChildSelected = true;
					break;
				}
			}
			i--;
			if (!isNextChildSelected) {
				while (i >= 0) {
					let c = p.getChildAt(i--);
					if (!getParentWhichHideChildren(c, true)) {
						game.editor.ui.sceneTree.selectInTree(c);
						isNextChildSelected = true;
						break;
					}
				}
			}

			if (!isNextChildSelected && (p !== game.stage)) {
				game.editor.ui.sceneTree.selectInTree(p);
			}

			DataPathFixer.validatePathReferences();

			game.editor.refreshTreeViewAndPropertyEditor();
			game.editor.sceneModified(true);
		}
	};

	export const enterPrefabName = (defaultPrefabName: string, title: ComponentChild) => {
		return game.editor.ui.modal.showPrompt(title,
			defaultPrefabName,
			(val) => { // filter
				return val.replace(prefabNameFilter, '-');
			},
			(val) => { //accept
				if (Lib.prefabs.hasOwnProperty(val)) {
					return 'Prefab with such name already exists';
				}
				if (val.endsWith('/') || val.startsWith('/')) {
					return 'name can not begin or end with "/"';
				}
			}
		);
	};

	export const savePrefab = (container: Container | FileDescClass) => {

		const isContainer = container instanceof Container;

		if (container instanceof Scene) {
			game.editor.ui.modal.showInfo('You can not save Scene as prefab. Please select some object from scene first.', undefined, 32037);
		} else {

			game.editor.chooseAssetsFolder('Where to save prefab?').then((chosenFolder) => {

				if (!chosenFolder!) {
					return;
				}

				let defaultPrefabName = '';
				if (PrefabEditor.currentPrefabName) {
					let a = PrefabEditor.currentPrefabName.split('/');
					a.pop();
					defaultPrefabName = a.join('/');
					if (defaultPrefabName) {
						defaultPrefabName += '/';
					}
				}

				enterPrefabName(defaultPrefabName, R.span(null, 'Enter name for new prefab: ', isContainer ? R.sceneNode(container) : renderClass(container))).then((enteredName) => {
					if (enteredName) {
						const fin = (doNotOpenToEdit = false) => {
							if (isContainer) {
								Lib.__savePrefab(container, enteredName, chosenFolder);
							} else {
								const instance = loadSafeInstanceByClassName(container.asset.__className);
								Lib.__savePrefab(instance, enteredName, chosenFolder);
								Lib.destroyObjectAndChildren(instance);
							}
							regeneratePrefabsTypings();
							if (!doNotOpenToEdit) {
								PrefabEditor.editPrefab(enteredName);
							}
						};

						if (container !== game.currentContainer && isContainer) {
							game.editor.ui.modal.showEditorQuestion('Reference?', 'Turn selected in to prefab reference?', () => {
								fin(true);
								Lib.__preparePrefabReference(container, enteredName);
								Lib.__invalidateSerializationCache(container);
								game.editor.sceneModified(true);
							}, 'Convert to prefab reference', fin, 'Keep original', true);
						} else {
							fin();
						}
					}
				});
			});
		}
	};

	export const isCanBeUnwrapped = () => {
		if (game.editor.selection.length !== 1) {
			return;
		}
		let o = game.editor.selection[0];
		if ((o.parent === game.stage) && !game.__EDITOR_mode) {
			return;
		}
		if (o === game.currentContainer) {
			return !(o instanceof Scene) && (o.children.length === 1);
		}
		if (o.__nodeExtendData.isPrefabReference) {
			return false;
		}
		return o.children.length > 0;
	};

	export const onExportAsPngClick = async (o:Container) => {

		let blob = await exportAsPng(o, undefined, undefined, 1) as Blob;
		if (blob) {
			let a = document.createElement('a');
			document.body.append(a);
			a.download = (o.name || 'image') + '.png';
			a.href = URL.createObjectURL(blob);
			a.click();
			a.remove();
		} else {
			game.editor.ui.modal.showModal('Nothing visible selected to export.');
		}
	};

	export const onUnwrapClick = () => {
		if (isCanBeUnwrapped()) {

			DataPathFixer.rememberPathReferences();

			let o = game.editor.selection[0];
			let parent = o.parent;
			let i = parent.getChildIndex(o);

			let isPrefab = (o === game.currentContainer);

			game.editor.selection.clearSelection();

			if (isPrefab && o.children.length !== 1) {
				game.editor.ui.modal.showError('To unwrap prefab it is should have exactly one children.', 30005);
				return;
			}

			while (o.children.length > 0) {
				let c = o.getChildAt(o.children.length - 1);
				c.detachFromParent();

				Lib.__invalidateSerializationCache(c);
				parent.toLocal(c, o, c);
				roundUpPoint(c);

				if (isPrefab) {
					c.name = o.name;
					game.__setCurrentContainerContent(c);
				} else {
					parent.addChildAt(c, i);
				}

				c.rotation += o.rotation;
				game.editor.ui.sceneTree.selectInTree(c, true);
			}


			if (!isPrefab) {
				Lib.__invalidateSerializationCache(o.parent);
				o.remove();
			}

			DataPathFixer.validatePathReferences();
			game.editor.refreshTreeViewAndPropertyEditor();
			game.editor.sceneModified(true);
		}
	};

	export const onCopyClick = () => {

		if (game.editor.selection.length > 0) {
			const data = game.editor.selection.map(Lib.__serializeObject);
			let assets = new Set<FileDesc>();
			for (let o of data) {
				enumAssetsPropsRecursive(o, assets);
			}
			const assetsFileNames = new Set() as Set<string>;
			const files = new Map() as Map<FileDesc, string[]>;
			const assetsArray = Array.from(assets);
			assets.forEach(a =>{
				if (a.fileName) {
					assetsFileNames.add(a.fileName);
					files.set(a, [a.fileName]);
				}
			});


			getAssetsToCopy(assets, true).forEach((f) => {
				if (assetsFileNames.has(f.from)) {
					return; // file already in assets list
				}
				if (assetsArray.some((asset) => {
					if (asset.fileName.endsWith('.json')) {
						const assetRoot = asset.fileName.substring(0, asset.fileName.length - 5);
						if (f.from.startsWith(assetRoot)) {
							files.get(asset)!.push(f.from);
							return true;
						}
					}
				})) {
					return; // parent asset found
				}

				// cant find
				assert(false, 'cant find parent asset for file ' + f.from);
			});

			clipboard.data = {
				data,
				assets: Array.from(assets).map(
					a => {
						return {
							name: a.assetName,
							type: a.assetType,
							files: files.get(a),
							l10n: (a.assetType === AssetType.L10N_ENTRY) ? a.asset as L10nEntryAsset : undefined
						} as ClipboardAsset;
					}),
				project: game.editor.currentProjectDir
			};

			game.editor.refreshTreeViewAndPropertyEditor();
		}
	};

	export const wrap = (nodes: Container[], wrapper: Container) => {
		const o = nodes[0];
		let parent = o.parent;
		for (let c of nodes) {
			if (c.parent !== parent) {
				game.editor.ui.modal.showInfo('Selected object should have same parent to be wrapped.', 'Can not wrap', 30012);
				return;
			}
		}

		if (o instanceof Scene) {
			game.editor.ui.modal.showInfo('Scene can not be wrapped, you can change scene\'s type instead.', 'Can not wrap', 30013);
			return;
		}
		DataPathFixer.rememberPathReferences();
		let isPrefab = o === game.currentContainer;
		let prefabName = game.currentContainer.name;
		game.editor.selection.clearSelection();

		let indexToAdd = parent.getChildIndex(o);

		for (let c of nodes) {
			wrapper.addChild(c);
		}
		if (isPrefab) {
			wrapper.name = prefabName;
			o.name = null;
			let data = Lib.__serializeObject(wrapper);
			wrapper = Lib._deserializeObject(data);
			game.__setCurrentContainerContent(wrapper);
		} else {
			parent.addChildAt(wrapper, indexToAdd);
		}
		Lib.__invalidateSerializationCache(wrapper);

		game.editor.selection.clearSelection();
		game.editor.ui.sceneTree.selectInTree(wrapper);
		wrapper.__nodeExtendData.childrenExpanded = true;
		DataPathFixer.validatePathReferences();
		game.editor.sceneModified(true);
		Lib.__callInitIfGameRuns(wrapper);
	};

	export const wrapSelected = (Class?: SourceMappedConstructor, prefabName?: string) => {
		assert(game.__EDITOR_mode, 'Can not wrap in running mode.');

		if (game.editor.selection.length < 1) {
			assert(false, 'Nothing selected to be wrapped.');
		} else if ((!Class && !prefabName) && (!clipboard.data || clipboard.data.data.length !== 1)) {
			game.editor.ui.status.error('Exactly one container should be copied in to clipBoard to wrap selection with it.');
		} else {
			let a = game.editor.selection.slice(0);
			let w;
			if (Class) {
				w = loadSafeInstanceByClassName(Class.__className, true);
				wrap(a, w);
			} else {

				if (prefabName) {
					w = Lib.__loadPrefabReference(prefabName);
				} else {
					game.editor.disableFieldsCache = true;
					w = Lib._deserializeObject({ c: clipboard.data.data[0].c, p: clipboard.data.data[0].p });
					game.editor.disableFieldsCache = false;
				}
				wrap(a, w);
			}
		}
	};

	export const onCutClick = () => {
		onCopyClick();
		onDeleteClick();
	};

	export const onPasteWrapClick = () => {
		wrapSelected();
	};

	export const onPasteClick = async () => {
		if (canPaste()) {

			if ((await copyRelatedAssets()) === false) {
				// canceled
				return;
			}

			DataPathFixer.rememberPathReferences();

			game.editor.disableFieldsCache = true;
			let added: Container[] = [];

			let insertTo = game.editor.selection.slice();
			if (insertTo.length === 0) {
				insertTo.push(game.currentContainer);
			}
			game.editor.selection.clearSelection();
			for (let selected of insertTo) {
				clipboard.data.data.some((data) => {
					let o = Lib._deserializeObject(data);
					added.push(o);
					o.__nodeExtendData.__isJustCloned = true;
					game.editor.addTo(selected, o);
				});
			}
			DataPathFixer.validatePathReferences();

			while (added.length > 0) {
				let o = added.shift() as Container;
				o.__nodeExtendData.__isJustCloned = false;
			}
			game.editor.sceneModified(true);
			game.editor.disableFieldsCache = false;
			return added;
		}
	};

	export const canPaste = () => {
		return clipboard.data && clipboard.data.data.length > 0;
	};

	export const onBringUpClick = () => {
		let i = 0;
		while (onMoveUpClick(true) && i++ < 100000); //moves selected object up until its become top
		game.editor.sceneModified(true);
		game.editor.refreshTreeViewAndPropertyEditor();
	};

	export const onMoveUpClick = (doNotSaveHistoryState = false) => {
		let ret = false;

		game.editor.selection.some((o) => {
			if (o.parent !== game.stage) {
				let i = o.parent.getChildIndex(o);
				if (i > 0) {
					let upper = o.parent.getChildAt(i - 1);
					if (!upper.__nodeExtendData.isSelected) {
						o.parent.swapChildren(o, upper);
						Lib.__invalidateSerializationCache(o.parent);
						ret = true;
					}
				}
			}
		});
		if (doNotSaveHistoryState !== true) {
			game.editor.sceneModified(true);
			game.editor.refreshTreeViewAndPropertyEditor();
		}
		return ret;
	};

	export const preCacheImages = (preactContent?: any) => {
		if (preactContent && (preactContent as any).props) {
			if (preactContent.type === 'img') {
				if (!cachedImages.has(preactContent.props.src)) {
					cachedImages.add(preactContent.props.src);
					const img = new Image();
					img.src = preactContent.props.src;
					document.body.appendChild(img);
					img.style.display = 'none';
				}
			}
			if (preactContent.props.children) {
				preactContent.props.children.forEach(preCacheImages);
			}
		}
	};

	export const onMoveDownClick = (doNotSaveHistoryState = false) => {
		let ret = false;
		let a = game.editor.selection.slice(0);
		a.reverse();
		a.some((o) => {
			if (o.parent !== game.stage) {
				let i = o.parent.getChildIndex(o);
				if (i < (o.parent.children.length - 1)) {
					let lower = o.parent.getChildAt(i + 1);
					if (!lower.__nodeExtendData.isSelected) {
						o.parent.swapChildren(o, lower);
						Lib.__invalidateSerializationCache(o.parent);
						ret = true;
					}
				}
			}
		});
		if (doNotSaveHistoryState !== true) {
			game.editor.sceneModified(true);
			game.editor.refreshTreeViewAndPropertyEditor();
		}
		return ret;
	};
	export const onBringDownClick = () => {
		let i = 0;
		while (onMoveDownClick(true) && i++ < 100000); //move selected element down until its become bottom.
		game.editor.sceneModified(true);
		game.editor.refreshTreeViewAndPropertyEditor();
	};

	/// #if EDITOR
	export const __setTextureSettingsBits = (name: string, bits: number, mask = 0xffffffff) => {
		if (!name || name === 'EMPTY' || name === 'WHITE') {
			return;
		}
		let current = Lib._getTextureSettingsBits(name, 0xffffffff);
		let n = (current & (mask ^ 0xffffffff)) | bits;
		if (n !== current) {
			if (n === 0) {
				delete game.projectDesc.loadOnDemandTextures[name];
			} else {
				game.projectDesc.loadOnDemandTextures[name] = n;
			}
			game.editor.saveProjectDesc();

			const TEXTURE_BITS = 4 | 8 | 16;
			if (Lib.hasTexture(name) && ((current & TEXTURE_BITS) !== (n & TEXTURE_BITS))) {
				let baseTexture = Lib.getTexture(name).baseTexture;
				baseTexture.mipmap = (n & 4) ? MIPMAP_MODES.ON : MIPMAP_MODES.OFF;
				if (n & 16) {
					baseTexture.wrapMode = WRAP_MODES.MIRRORED_REPEAT;
				} else if (n & 8) {
					baseTexture.wrapMode = WRAP_MODES.REPEAT;
				} else {
					baseTexture.wrapMode = WRAP_MODES.CLAMP;
				}
				baseTexture.update();
				game.editor.ui.refresh();
			}
		}
	};
	/// #endif
}

interface ClipboardData {
	data: SerializedObject[];
	assets: ClipboardAsset[];
	project: string;
}

class clipboard {
	static set data(cd: ClipboardData) {
		game.editor.settings.setItem('__EDITOR-clipboard-data', cd);
		game.editor.settings.removeItem('__EDITOR-clipboard-data-timeline-name');
	}

	static get data(): ClipboardData {
		return game.editor.settings.getItem('__EDITOR-clipboard-data');
	}

}


const getL10nKey = (asset: L10nEntryAsset) => {
	let originalKey = asset[0];
	let foreignProjectPrefix = asset[2];
	return foreignProjectPrefix ? originalKey.replace(foreignProjectPrefix, game.projectDesc.__localesNewKeysPrefix || '') : originalKey;
};

const replaceTranslationsRecursive = (o:SerializedObject, oldKey:string, newKey:string):boolean|undefined => {
	let ret;
	if (o.c) {
		const constr = game.classes[o.c];
		if (constr) {
			let props = constr.__editableProps;
			for (let field of props) {
				if (field.type === 'l10n') {
					let key = o.p[field.name];
					if (key === oldKey) {
						o.p[field.name] = newKey;
						ret = true;
					}
				}
			}
		}
	}
	if (o[':']) {
		for (let c of o[':']) {
			ret = replaceTranslationsRecursive(c, oldKey, newKey) || ret;
		}
	}
	return ret;
};


const copyRelatedAssets = async () => {

	const replaces = {} as KeyedMap<string>;
	if (clipboard.data.project !== game.editor.currentProjectDir) {
		let assets = clipboard.data.assets.filter((asset) => {
			if (asset.type === AssetType.L10N_ENTRY) {
				return !L.has(getL10nKey(asset.l10n!));
			}
			return !fs.getFileByAssetName(asset.name, asset.type);
		});

		const fileExist = new Set() as Set<string>;
		assets.forEach((asset) => {
			asset.files?.forEach(fileName => {
				if (fs.exists(fileName)) {
					fileExist.add(fileName);
				}
			});
		});

		if (assets.length > 0) {
			const selectedAssets = await (await import('../ui/filter-list')).showListFilter(
				'Related assets will be copied to the project:',
				assets.map((asset) => {
					if (asset.type === AssetType.L10N_ENTRY) {
						let l18n = getL10nKey(asset.l10n!);
						const texts = asset.l10n![1];
						return {
							name: R.div({title: 'Localized text entry'}, R.span(labelTextProps, l18n), ': ', R.b(null, Object.values(texts)[0])),
							pureName: l18n,
							value: asset
						};
					}
					const deleted = asset.files.every(f => !fileExist.has(f));
					return {
						disabled: deleted,
						unselected: deleted,
						name: R.span({className: 'asset-files-names'}, asset.files.map((fileName) => {
							return R.div(fileExist.has(fileName) ? null : {className: 'danger', title: 'deleted file'}, fileName);
						})),
					 	pureName: asset.files[0],
					  	value: asset };
				})
			);

			const LanguageView = (await import('../ui/language-view')).default;

			if (!selectedAssets) {
				return false;
			}

			selectedAssets.forEach((i) => {
				const asset: ClipboardAsset = i.value;
				if (asset.type === AssetType.L10N_ENTRY) {
					const originalKey = asset.l10n![0];
					const texts = asset.l10n![1];
					const projectKey = getL10nKey(asset.l10n!);
					for (const langId in texts) {
						LanguageView.addTranslationToProject(projectKey, texts[langId], langId);
					}

					if (originalKey !== projectKey) {
						for (let o of clipboard.data.data) {
							replaceTranslationsRecursive(o, originalKey, projectKey);
							replaces[originalKey] = projectKey;
						}
					}

				} else {
					for (const fileName of asset.files) {
						fs.copyFile(fileName, game.editor.currentProjectAssetsDirRooted + fileName.split('/assets/').pop());
					}
				}
			});

			fs.refreshAssetsList();
			game.editor.ui.refresh();

			for (let asset of clipboard.data.assets) {
				if (asset.type === AssetType.PREFAB) {
					let prefabName = asset.name;
					for (let oldKey in replaces) {
						let newKey = replaces[oldKey];
						let prefabData = Lib.prefabs[prefabName];
						if (replaceTranslationsRecursive(prefabData, oldKey, newKey)) {
							Lib.__savePrefabData(prefabData, prefabName);
						}
					}
				}
			}
		}
	}
};
</file>

<file path="src/editor/utils/enum-assets-recursive.ts">
import type { FileDesc } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import L from 'thing-editor/src/engine/utils/l';
import type { L10nEntryAsset } from '../editor-env';

const addImageToAssetsList = (imageName: string, ret: Set<FileDesc>) => {
	if (imageName) {
		const file = fs.getFileByAssetName(imageName, AssetType.IMAGE);
		assert(file, 'Wrong image name.');
		if (!Lib.__isSystemTexture(file.asset, file.assetName)) {
			ret.add(file);
		}
	}
};

const addResourceToAssetsList = (resourceName: string, ret: Set<FileDesc>) => {
	if (resourceName) {
		const file = fs.getFileByAssetName(resourceName, AssetType.RESOURCE);
		assert(file, 'Wrong resource name.');
		ret.add(file);
	}
};

const addSoundToAssetsList = (soundName: string, ret: Set<FileDesc>) => {
	if (soundName) {
		const file = fs.getFileByAssetName(soundName, AssetType.SOUND);
		assert(file, 'Wrong sound name.');
		ret.add(file);
	}
};

const addPrefabToAssetsList = (prefabName: string, ret: Set<FileDesc>) => {
	if (prefabName) {
		const file = fs.getFileByAssetName(prefabName, AssetType.PREFAB);
		assert(file, 'Wrong prefab name.');
		if (!ret.has(file)) {
			ret.add(file);

			enumAssetsPropsRecursive(Lib.prefabs[prefabName], ret);
		}
	}
};

const enumAssetsPropsRecursive = (o: SerializedObject, ret: Set<FileDesc>) => {
	if (o.c) {
		const constr = game.classes[o.c];

		let props = constr.__editableProps;
		let imageFields: KeyedMap<true> = {};
		for (let field of props) {
			if (field.type === 'image') {
				imageFields[field.name] = true;
				addImageToAssetsList(o.p[field.name], ret);
			} else if (field.type === 'resource') {
				addResourceToAssetsList(o.p[field.name], ret);
			} else if (field.type === 'prefab') {
				let prefabName = o.p[field.name];
				if (Lib.hasPrefab(prefabName)) {
					addPrefabToAssetsList(prefabName, ret);
				}
			} else if (field.type === 'sound') {
				let soundName = o.p[field.name];
				if (Lib.hasSound(soundName)) {
					addSoundToAssetsList(soundName, ret);
				}
			} else if (field.type === 'callback') {
				let action = o.p[field.name];
				if (action && action.indexOf(',') > 0) {

					let params = action.split(',');
					params.shift();
					for (let p of params) {
						if (p.endsWith('.png') || p.endsWith('.jpg')) {
							addImageToAssetsList(p, ret);
						}
					}
				}
			} else if (field.type === 'l10n') {
				let key = o.p[field.name];
				if (key && L.has(key)) {
					const entryTexts = {} as KeyedMap<string>;
					const lData = L.getData();
					for (const langId in lData) {
						entryTexts[langId] = lData[langId][key];
					}
					let array = [key, entryTexts] as L10nEntryAsset;
					let prefix = game.projectDesc.__localesNewKeysPrefix;
					if (prefix && key.startsWith(prefix)) {
						array.push(prefix);
					}

					ret.add({assetType: AssetType.L10N_ENTRY, asset: array, assetName: key, fileName: '', mTime: 0, lib: null});
				}
			}
		}
		if (((constr as any === game.classes.MovieClip) || (constr.prototype instanceof game.classes.MovieClip)) && o.p.timeline) {
			for (let f of o.p.timeline.f) {
				for (let keyframe of f.t) {
					if (imageFields[f.n]) {
						addImageToAssetsList(keyframe.v, ret);
					}
					let a = keyframe.a;
					if (a && (a.indexOf('Sound.play`') >= 0 || a.indexOf('Sound.playPitched`') >= 0)) {
						let sndName = a.split(',')[1];
						if (Lib.hasSound(sndName)) {
							addSoundToAssetsList(sndName, ret);
						}
					}
				}
			}
		}
	} else {
		addPrefabToAssetsList(o.r!, ret);
	}
	if (o[':']) {
		for (let c of o[':']) {
			enumAssetsPropsRecursive(c, ret);
		}
	}
};

export default enumAssetsPropsRecursive;
</file>

<file path="src/editor/utils/export-as-png.ts">
import type { Container, Rectangle } from 'pixi.js';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

/** exports DisplayObject as canvas, and destroys object if it has no parent */

export default async function exportAsPng(object: Container, width = 0, height = 0, cropAlphaThreshold = 1, bounds?: Rectangle, returnAsCanvas = false, destroySource = false):Promise<Blob | HTMLCanvasElement | undefined> {

	if (object.width > 0 && object.height > 0) {
		let tmpVisible = object.visible;
		object.visible = true;

		let objectsParent = object.parent;

		let oldIndex = 0;
		oldIndex = objectsParent ? objectsParent.children.indexOf(object) : 0;
		let f = object.filters;
		let c = Lib._loadClassInstanceById('Container');
		let c2 = Lib._loadClassInstanceById('Container');
		c.addChild(object);
		c2.addChild(c);

		object.filters = [];
		game.editor.ui.modal.showSpinner();

		let b = c.getLocalBounds();

		let canvas;
		let cropTop = 0;
		let cropBottom = 0;
		let cropLeft = 0;
		let cropRight = 0;

		if (cropAlphaThreshold >= 0) {
			canvas = game.pixiApp.renderer.plugins.extract.canvas(c);
			let ctx = canvas.getContext('2d', {
				alpha: true
			});
			let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;


			while (cropTop < canvas.height) {
				let isEmptyLine = true;
				let y = cropTop * canvas.width * 4 + 3;
				for (let x = 0; x < canvas.width; x++) {
					if (imageData[x * 4 + y] >= cropAlphaThreshold) {
						isEmptyLine = false;
						break;
					}
				}
				if (!isEmptyLine) {
					break;
				}
				cropTop++;
			}

			while (cropBottom < canvas.height) {
				let isEmptyLine = true;
				let y = (canvas.height - 1 - cropBottom) * canvas.width * 4 + 3;
				for (let x = 0; x < canvas.width; x++) {
					if (imageData[x * 4 + y] >= cropAlphaThreshold) {
						isEmptyLine = false;
						break;
					}
				}
				if (!isEmptyLine) {
					break;
				}
				cropBottom++;
			}

			while (cropLeft < canvas.width) {
				let isEmptyLine = true;
				let x = cropLeft * 4 + 3;
				for (let y = 0; y < canvas.height; y++) {
					if (imageData[x + y * canvas.width * 4] >= cropAlphaThreshold) {
						isEmptyLine = false;
						break;
					}
				}
				if (!isEmptyLine) {
					break;
				}
				cropLeft++;
			}

			while (cropRight < canvas.width) {
				let isEmptyLine = true;
				let x = (canvas.width - 1 - cropRight) * 4 + 3;
				for (let y = 0; y < canvas.height; y++) {
					if (imageData[x + y * canvas.width * 4] >= cropAlphaThreshold) {
						isEmptyLine = false;
						break;
					}
				}
				if (!isEmptyLine) {
					break;
				}
				cropRight++;
			}

			b.y += cropTop;
			b.height -= cropTop + cropBottom;
			b.x += cropLeft;
			b.width -= cropLeft + cropRight;
		}

		let b2 = c2.getLocalBounds();
		c2.getLocalBounds = () => {
			return bounds || b2;
		};

		if (width > 0 && height > 0) {

			b2.x = 0;
			b2.y = 0;
			b2.width = width;
			b2.height = height;

			let scale = Math.min(width / b.width, height / b.height);
			b.y *= scale;
			b.x *= scale;
			b.width *= scale;
			b.height *= scale;

			c.scale.x = c.scale.y = scale;
			c.x = -b.x + (width - b.width) / 2;
			c.y = -b.y + (height - b.height) / 2;
		} else {
			b2.y += cropTop;
			b2.height -= cropTop + cropBottom;
			b2.x += cropLeft;
			b2.width -= cropLeft + cropRight;
			if (b2.x < 0) {
				b2.x = Math.floor(b2.x);
			} else {
				b2.x = Math.ceil(b2.x);
			}
			if (b2.y < 0) {
				b2.y = Math.floor(b2.y);
			} else {
				b2.y = Math.ceil(b2.y);
			}
		}

		b2.width = Math.ceil(b2.width);
		b2.height = Math.ceil(b2.height);

		if (b2.width & 1) {
			b2.width++;
		}
		if (b2.height & 1) {
			b2.height++;
		}

		canvas = game.pixiApp.renderer.plugins.extract.canvas(c2) as HTMLCanvasElement;

		if (destroySource) {
			Lib.destroyObjectAndChildren(object);
		} else {
			object.visible = tmpVisible;
			object.filters = f;
			if (objectsParent) {
				objectsParent.addChildAt(object, oldIndex);
			} else {
				object.detachFromParent();
			}
		}
		Lib.destroyObjectAndChildren(c2);

		let ret = returnAsCanvas ? canvas : await new Promise((resolve) => {
			canvas.toBlob(resolve, 'image/png');
		});
		delete (c2 as any).getLocalBounds;

		game.editor.ui.modal.hideSpinner();

		return ret as Blob | HTMLCanvasElement;
	}
}
</file>

<file path="src/editor/utils/find-file-in-assets.ts">
import game from 'thing-editor/src/engine/game';
import fs from '../fs';

const findFileInAssets = (fileName:string) => {
	for (const assetsFolder of game.editor.assetsFoldersReversed) {
		const fullPath = assetsFolder + fileName;
		if (fs.exists(fullPath)) {
			return fullPath;
		}
	}
};

export default findFileInAssets;
</file>

<file path="src/editor/utils/flags.ts">
import type { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';
import type { FSCallback } from '../editor-env';

const EDITOR_BACKUP_PREFIX = '___editor_backup_';

let cachedErrorsChecked = false;

class EDITOR_FLAGS {
	/* super.init() call validation flag*/
	static _root_initCalled: Set<Container> = new Set();
	/* super.onRemove() call validation flag*/
	static _root_onRemovedCalled: Set<Container> = new Set();

	static __classesReloadingTime = false;

	static blockSelectByStageClick = 0;

	static updateInProgress = false;

	static isolationEnabled = false;

	static isTryTime = 0;

	static __touchTime = 0;

	static isStoppingTime = false;

	static pathValidationCurrentThis: any = null;

	static rememberTryTime() {
		if (!cachedErrorsChecked) {
			detectCachedErrorsStopping();
			cachedErrorsChecked = true;
		}
		EDITOR_FLAGS.isTryTime++;
	}

	static checkTryTime() {
		EDITOR_FLAGS.isTryTime--;
		assert(EDITOR_FLAGS.isTryTime >= 0, 'checkTryTime() without rememberTryTime() detected.');
	}
}

type Electron_ThingEditorServer = { // exposed from electron
	fs: (command: string, filename?: string | string[] | number, content?: string | boolean | ArrayBuffer, ...args: any[]) => FSCallback;
	fsAsync: (command: string, filename?: string | string[], content?: string | boolean, ...args: any[]) => Promise<any>;
	versions: KeyedObject;
	onServerMessage: (_onServerMessage: (event: string, ...args: any[]) => void) => void;
	argv: string[];
};

export const electron_ThingEditorServer: Electron_ThingEditorServer = (window as any).electron_ThingEditorServer;


export default EDITOR_FLAGS;

export { EDITOR_BACKUP_PREFIX };

const detectCachedErrorsStopping = () => {
	let tryTime = Date.now();
	try {
		throw new Error('Test error.');
	} catch (_er) {
	}
	if (((Date.now() - tryTime) > 1000)) {
		alert('Looks like you stopped on caught exception, probably you need to disable \'stop on caught exception\' option in your debugger.');
	}
};
</file>

<file path="src/editor/utils/generate-editor-typings.ts">
import fs from 'thing-editor/src/editor/fs';
import { getAllObjectRefsCount } from 'thing-editor/src/editor/utils/scene-all-validator';
import { __UnknownClass } from 'thing-editor/src/editor/utils/unknown-class';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

let __currentAllMap: string;
let __currentClassesMap: string;

const getImportSrcForClass = (className: string) => {
	const path = game.classes[className].__sourceFileName!;
	return 'import type ' + className + ' from \'' + path.substring(1, path?.length - 3) + '\';';
};

const regenerateCurrentSceneMapTypings = () => {
	if (game.editor.editorArguments['no-vscode-integration']) {
		return;
	}
	if (!game.currentScene || !game.__EDITOR_mode) {
		return;
	}

	const sceneClass = (game.currentScene.constructor as SourceMappedConstructor);

	const json: KeyedMap<string> = {};
	const classes: Set<string> = new Set();

	classes.add(sceneClass.__className);

	game.currentScene._refreshAllObjectRefs();
	for (let n of Object.keys(game.currentScene.all)) {
		if (!n.startsWith('___')) {
			try {
				let className = (game.all[n].constructor as SourceMappedConstructor).__className;
				classes.add(className);
				json[n] = className;
			} catch (_er) { }
		}
	}
	let jsonString = JSON.stringify(json);
	if (__currentAllMap !== jsonString) {
		__currentAllMap = jsonString;

		let imports = [];
		let declarations = [];

		for (let className of classes.values()) {
			if (className !== 'Container') {
				imports.push(getImportSrcForClass(className));
			}
		}

		const keys = Object.keys(json);
		for (let name of keys) {
			let className = json[name];
			if (className !== 'Container') {
				const isRefused = getAllObjectRefsCount(name);
				if (isRefused) {
					declarations.push(`/** @deprecated ${isRefused} */`);
				}
				declarations.push('\'' + name + '\': ' + className + ';');
			}
		}

		let mapJS = `// thing-editor auto generated file.

import type { Container } from 'pixi.js';
`
			+ imports.join('\n') +
`

declare global {
type CurrentSceneType = ` + sceneClass.__className + `;

interface ThingSceneAllMap {
	[key: string]: Container;
`
			+ declarations.join('\n') + `
}
}
`;
		fs.writeFile('/thing-editor/src/editor/current-scene-typings.ts', mapJS);
	}
};


const regenerateClassesTypings = () => {
	if (game.editor.editorArguments['no-vscode-integration']) {
		return;
	}

	const classesNames: string[] = Object.keys(game.classes).filter(n => !n.startsWith('___'));

	let jsonString = classesNames.join(',');
	if (__currentClassesMap !== jsonString) {
		__currentClassesMap = jsonString;

		let imports = [];
		let declarations = [];

		for (let className of classesNames) {
			imports.push(getImportSrcForClass(className));
		}

		for (let className of classesNames) {
			declarations.push('\'' + className + '\': typeof ' + className + ';');
		}

		let mapJS = `// thing-editor auto generated file.
`
			+ imports.join('\n') +
`

declare global {

export interface GameClasses {
[key: string]: SourceMappedConstructor;
`
			+ declarations.join('\n') + `
}
}
`;
		fs.writeFile('/thing-editor/src/editor/current-classes-typings.ts', mapJS);
	}
};

let __currentPrefabsMap: string;

const regeneratePrefabsTypings = () => {

	if (game.editor.editorArguments['no-vscode-integration']) {
		return;
	}
	if (!game.currentScene || !game.__EDITOR_mode) {
		return;
	}
	let json: KeyedObject = {};
	let classes: Set<string> = new Set();

	for (let prefabName in Lib.prefabs) {
		if (!prefabName.startsWith('___')) {
			let className = getSerializedObjectClass(Lib.prefabs[prefabName]).__className;
			json[prefabName] = className;
			classes.add(className);
		}
	}

	let jsonString = JSON.stringify(json);
	if (__currentPrefabsMap !== jsonString) {
		__currentPrefabsMap = jsonString;

		let imports = [];
		let declarations = [];

		for (let prefabName in json) {
			declarations.push('	static loadPrefab(prefabName: \'' + prefabName + '\'):' + json[prefabName] + ';');
		}

		for (let className of classes.values()) {
			imports.push(getImportSrcForClass(className));
		}

		let mapJS = `// thing-editor auto generated file.
`
			+ imports.join('\n') +
			`
export default class TLib {
`
			+ declarations.join('\n') + `
	static loadPrefab(prefabName: string): Container;
	static loadPrefab(prefabName: string): Container {
		return prefabName as any;
	}
}
`;

		fs.writeFile('/thing-editor/src/editor/prefabs-typing.ts', mapJS);
	}
};

const getSerializedObjectClass = (data: SerializedObject): SourceMappedConstructor => {
	if (!data) {
		return __UnknownClass as SourceMappedConstructor;
	}
	if (data.r) {
		return getSerializedObjectClass(Lib.prefabs[data.r]);
	}
	return game.classes[data.c!] || __UnknownClass;
};

export default regenerateCurrentSceneMapTypings;

export { getSerializedObjectClass, regenerateClassesTypings, regeneratePrefabsTypings };
</file>

<file path="src/editor/utils/get-hashed-asset-name.ts">
import type { FileDesc } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';

const getHashedAssetName = (file: FileDesc) => {
	if (!file._hashedAssetName) {
		const hash = fs.getFileHash(file.fileName);
		if (file.assetType === AssetType.IMAGE || file.assetType === AssetType.FONT) {
			const n = file.assetName.lastIndexOf('.');
			file._hashedAssetName = file.assetName.substring(0, n) + '_' + hash + file.assetName.substring(n);
		} else {
			file._hashedAssetName = file.assetName + '_' + hash;
		}
	}
	return file._hashedAssetName;
};

export default getHashedAssetName;
</file>

<file path="src/editor/utils/get-parent-with-hidden-children.ts">
import type { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';

export default function getParentWhichHideChildren(child: Container, closest = false): Container | undefined {
	let parents = [];
	let o = child;
	while (o) {
		parents.unshift(o);
		o = o.parent;
	}

	if (closest) {
		parents.reverse();
	}

	for (let i = 0; i < parents.length; i++) {
		o = parents[i];

		let extendData = o.__nodeExtendData;

		if (extendData.hidden) {
			if (!closest) {
				assert(i > 0, 'Cannot get parent hides children.');
				o = parents[i - 1];
				if (o !== child) {
					return o;
				}
			} else {
				assert(i < (parents.length - 1), 'Cannot get parent hides children.');
				o = parents[i + 1];
				if (o !== child) {
					return o;
				}
			}
		}
		if (o.__hideChildren) {
			if (o !== child) {
				return o;
			}
		}
	}
}
</file>

<file path="src/editor/utils/get-prefab-defaults.ts">
import type { Container } from 'pixi.js';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

const __prefabsDefaults: Map<string, KeyedObject> = new Map();

const getPrefabDefaults = (o: Container): KeyedObject => {
	if (o.__nodeExtendData.isPrefabReference) {
		const prefabName = o.__nodeExtendData.isPrefabReference;
		if (!__prefabsDefaults.has(prefabName)) {
			const ret: KeyedObject = {};
			if (Lib.hasPrefab(prefabName)) {
				const dataChain: SerializedObjectProps[] = [];
				let prefabData = Lib.prefabs[prefabName] || ret;
				while (true) { // eslint-disable-line no-constant-condition
					dataChain.unshift(prefabData.p);
					if (prefabData.r) {
						prefabData = Lib.prefabs[prefabData.r];
					} else {
						break;
					}
				}
				if (game.classes[prefabData.c!]) {
					dataChain.unshift(game.classes[prefabData.c!].__defaultValues);
				}
				dataChain.unshift(ret);
				Object.assign.apply(ret, dataChain as any);
			}
			__prefabsDefaults.set(prefabName, ret);

		}
		return __prefabsDefaults.get(prefabName)!;
	} else {
		return (o.constructor as SourceMappedConstructor).__defaultValues;
	}
};

const invalidatePrefabDefaults = () => {
	__prefabsDefaults.clear();
};

export default getPrefabDefaults;

export { invalidatePrefabDefaults };
</file>

<file path="src/editor/utils/goto-label-consumer.ts">
import type { Container } from 'pixi.js';
import game from 'thing-editor/src/engine/game';
import type { IGoToLabelConsumer } from '../editor-env';

const gotoLabelHelper = (context: IGoToLabelConsumer):Promise<(string|undefined)[]> => {

	return new Promise((resolve) => {

		let addedLabels: Set<string> = new Set();

		let labels = [];

		const l = context.__getLabels();

		if (l) {
			for (let name of l) {
				if (!addedLabels.has(name)) {
					labels.push(name);
					addedLabels.add(name);
				}
			}
		}

		return game.editor.ui.modal.showPrompt('Choose label to go', '', undefined, undefined, false, false, labels).then((enteredLabelName) => {
			if (enteredLabelName) {
				resolve([enteredLabelName]);
			}
			return null;
		});
	});
};

const gotoLabelRecursiveHelper = (context: Container) => {
	return new Promise((resolve) => {
		let labels = [] as string[];
		let addedLabels: Set<string> = new Set();
		const getLabels = (o:any) => {
			if (o.__getLabels) {
				const _labels = o.__getLabels();
				if (_labels) {
					for (const label of _labels) {
						if (!addedLabels.has(label)) {
							addedLabels.add(label);
							labels.push(label);
						}
					}
				}
			}
		};
		getLabels(context);
		context.forAllChildren(getLabels);

		return game.editor.ui.modal.showPrompt('Choose label to go recursive for event ' + (game.editor.currentPathChoosingField?.name || ' of keyframe.'), '', undefined, undefined, false, false, labels).then((enteredLabelName) => {
			if (enteredLabelName) {
				resolve([enteredLabelName]);
			}
			return null;
		});
	});
};

export function decorateGotoLabelMethods(constrictor: new() => IGoToLabelConsumer) {
	(constrictor.prototype.gotoLabelRecursive as SelectableProperty).___EDITOR_callbackParameterChooserFunction = gotoLabelRecursiveHelper;
	(constrictor.prototype.gotoLabelRecursive as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
	(constrictor.prototype.gotoLabelRecursive as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
	if (constrictor.prototype.gotoLabel) {
		(constrictor.prototype.gotoLabel as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
		(constrictor.prototype.gotoLabel as SelectableProperty).___EDITOR_callbackParameterChooserFunction = gotoLabelHelper;
	}
}

export { gotoLabelHelper };
</file>

<file path="src/editor/utils/highlight-object.ts">
import { OutlineFilter } from '@pixi/filter-outline';
import type { Container } from 'pixi.js';

const highlightFilter = new OutlineFilter(3, 0xff0000);

const highlightObject = (o: Container) => {
	if (!o.filters || o.filters.indexOf(highlightFilter) < 0) {
		o.addFilter(highlightFilter);
		window.setTimeout(() => {
			o.removeFilter(highlightFilter);
		}, 100);
		window.setTimeout(() => {
			o.addFilter(highlightFilter);
		}, 200);
		window.setTimeout(() => {
			o.removeFilter(highlightFilter);
		}, 300);
	}
};

export default highlightObject;
</file>

<file path="src/editor/utils/history.ts">
import { EventEmitter } from 'events';
import type { Container } from 'pixi.js';
import MainMenu from 'thing-editor/src/editor/ui/main-menu';
import regenerateCurrentSceneMapTypings from 'thing-editor/src/editor/utils/generate-editor-typings';
import type { SelectionData } from 'thing-editor/src/editor/utils/selection';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';

import Pool from 'thing-editor/src/engine/utils/pool';
import type TypedEmitter from 'typed-emitter';

const HISTORY_LEN = 100;
const STRICT_HISTORY_LEN = 20;

let undoStack: KeyedMap<HistoryRecord[]> = {}; //separated undo/redo array for scene and each modal objects
let redosStack: KeyedMap<HistoryRecord[]> = {};

let instance: History;


let lastAppliedTreeData: HistorySerializedData;

let currentSelectionNavigation = 0;

let STATE_APPLY_TIME = false;

function applyState(state: HistoryRecord) {
	STATE_APPLY_TIME = true;
	assert(state, 'Empty history record.');
	assert(game.__EDITOR_mode, 'Attempt to save undo history in runtime mode.');
	currentSelectionNavigation = 0;
	let stateChanged = state.treeData !== lastAppliedTreeData;
	if (stateChanged) {
		instance.events.emit('beforeHistoryJump');
		Pool.__resetIdCounter();
		let node = Lib._deserializeObject(state.treeData);
		game.__setCurrentContainerContent(node);
	}
	game.editor.selection.loadSelection(state.selectionData);
	const stage = game.stage as Container;
	stage.x = state.selectionData._stageX as number;
	stage.y = state.selectionData._stageY as number;
	stage.scale.x = stage.scale.y = state.selectionData._stageS as number;
	lastAppliedTreeData = state.treeData;

	if (stateChanged) {
		instance.events.emit('afterHistoryJump');
	}
	STATE_APPLY_TIME = false;
}

function getHistoryName() {
	if ((typeof game === 'undefined') || !game.currentContainer) {
		return;
	}
	let n = game.currentContainer.name;
	assert(n, 'currentContainer name is empty.');
	if (game.currentContainer instanceof Scene) {
		n = 's/' + n;
	} else {
		n = 'p/' + n;
	}
	return n;
}

type HistoryEvents = {
	beforeHistoryJump: () => void;
	afterHistoryJump: () => void;
}

interface HistorySerializedData extends SerializedObject {
	_isModified?: boolean;
}

interface HistoryRecord {

	treeData: HistorySerializedData;
	/** field was edited to undo record created */
	fieldName: string | null;

	selectionData: SelectionData;

}

class History {

	events = new EventEmitter() as TypedEmitter<HistoryEvents>;

	constructor() {
		this.undo = this.undo.bind(this);
		this.redo = this.redo.bind(this);
		this.isRedoAvailable = this.isRedoAvailable.bind(this);
		this.isUndoAvailable = this.isUndoAvailable.bind(this);
		instance = this;

		window.addEventListener('mouseup', this.scheduleHistorySave);
		window.addEventListener('keyup', this.scheduleHistorySave);
		window.addEventListener('drop', this.scheduleHistorySave);
	}

	_sceneModifiedInner(saveImmediately = false) {
		clearSelectionSaveTimeout();
		if (game.__EDITOR_mode) {
			needHistorySave = true;
			if (saveImmediately) {
				instance.scheduleHistorySave();
			}
		}
	}

	scheduleHistorySave() {
		if (!historySaveScheduled) {
			historySaveScheduled = window.setTimeout(() => {
				historySaveScheduled = 0;
				instance.saveHistoryNow();
			}, 1);
		}
	}

	scheduleSelectionSave() {
		if (!STATE_APPLY_TIME) {
			clearSelectionSaveTimeout();
			if (game.__EDITOR_mode) {
				needSaveSelectionInToHistory = window.setTimeout(saveSelectionState, 50);
			}
		}
	}

	saveHistoryNow() {
		if (needHistorySave) {
			clearSelectionSaveTimeout();
			needHistorySave = false;
			instance.addHistoryState();
			if (historySaveScheduled) {
				clearInterval(historySaveScheduled);
				historySaveScheduled = 0;
			}
			regenerateCurrentSceneMapTypings();
		}
	}

	isRedoAvailable() {
		let r = this._redoList;
		return r && r.length > 0;
	}

	isUndoAvailable() {
		let u = this._undoList;
		return u && u.length > 1;
	}

	get _undoList(): HistoryRecord[] {
		let n = getHistoryName();
		if (!n) {
			return [];
		}
		if (!undoStack.hasOwnProperty(n)) {
			undoStack[n] = [];
		}
		return undoStack[n];
	}

	get _redoList(): HistoryRecord[] {
		let n = getHistoryName();
		if (!n) {
			return [];
		}
		if (!redosStack.hasOwnProperty(n)) {
			redosStack[n] = [];
		}
		return redosStack[n];
	}

	_pushCurrentStateToUndoHistory(selectionData: SelectionData, selectionOnly = false) {
		assert(game.__EDITOR_mode, 'Attempt to use history in running time.');

		let treeData: HistorySerializedData;

		if (selectionOnly) {
			if (!this.currentState || arraysEqual(selectionData, this.currentState.selectionData)) {
				return;
			}
			treeData = this.currentState.treeData;
		} else {
			Lib.__invalidateSerializationCache(game.currentContainer);
			treeData = Lib.__serializeObject(game.currentContainer);
			treeData._isModified = true;
		}

		let historyRecord: HistoryRecord = { treeData, selectionData, fieldName: game.editor._lastChangedFiledName };
		game.editor._lastChangedFiledName = null;

		lastAppliedTreeData = historyRecord.treeData;

		this._undoList.push(historyRecord);

		//reduce and limit history
		if (this._undoList.length > HISTORY_LEN) {
			let i = HISTORY_LEN - 1;
			while (i > STRICT_HISTORY_LEN) {
				i -= 2;
				this._undoList.splice(i, 1);
			}
		}
	}

	addSelectionHistoryState() {
		this.addHistoryState(true);
	}

	addHistoryState(selectionOnly = false) {
		let selectionData = game.editor.selection.saveSelection();

		const stage = game.stage as Container;
		selectionData._stageX = stage.x;
		selectionData._stageY = stage.y;
		selectionData._stageS = stage.scale.x;
		if (!selectionOnly) {
			this._redoList.length = 0;
		}
		this._pushCurrentStateToUndoHistory(selectionData, selectionOnly);
	}

	undo() {
		if (this.isUndoAvailable()) {
			if (this.currentState.fieldName) {
				game.editor.ui.propsEditor.selectField(this.currentState.fieldName);
			}
			this._redoList.push(this._undoList.pop() as HistoryRecord);
			applyState(this.currentState);
		}
	}

	redo() {
		if (this.isRedoAvailable()) {
			this._undoList.push(this._redoList.pop() as HistoryRecord);
			applyState(this.currentState);
			if (this.currentState.fieldName) {
				game.editor.ui.propsEditor.selectField(this.currentState.fieldName);
			}
		}
	}

	get currentState(): HistoryRecord {
		let undo = this._undoList;
		if (undo) {
			return undo[undo.length - 1];
		}

		return null!;
	}


	setCurrentStateModified() {
		this.currentState.treeData._isModified = true;
	}

	setCurrentStateUnmodified() {
		if (this._undoList.length === 0 && this._redoList.length === 0) {
			this.addHistoryState();
		}
		this._undoList.some((s) => {
			s.treeData._isModified = true;
		});
		delete (this.currentState as HistoryRecord).treeData._isModified;
	}

	get isStateModified() {
		return this.currentState && this.currentState.treeData._isModified;
	}

	navigateSelection(direction = -1) {
		while (true) { // eslint-disable-line no-constant-condition
			currentSelectionNavigation += direction;

			let targetHistoryState;
			if (currentSelectionNavigation <= 0) {
				targetHistoryState = this._undoList[this._undoList.length - 1 + currentSelectionNavigation];
				currentSelectionNavigation = Math.max(-(this._undoList.length - 1), currentSelectionNavigation);
			} else {
				targetHistoryState = this._redoList[currentSelectionNavigation - 1];
				currentSelectionNavigation = Math.min(this._redoList.length, currentSelectionNavigation);
			}
			if (targetHistoryState) {
				if (JSON.stringify(targetHistoryState.selectionData.slice()) !== JSON.stringify(game.editor.selection.saveSelection())) {
					game.editor.selection.loadSelection(targetHistoryState.selectionData);
					break;
				}
			} else {
				break;
			}
		}
	}
}


let historySaveScheduled = 0;
let needHistorySave = false;

let needSaveSelectionInToHistory = 0;

function clearSelectionSaveTimeout() {
	if (needSaveSelectionInToHistory) {
		clearInterval(needSaveSelectionInToHistory);
		needSaveSelectionInToHistory = 0;
	}
}

function saveSelectionState() {
	if (game.__EDITOR_mode) {
		game.editor.history.addSelectionHistoryState();
	}
	needSaveSelectionInToHistory = 0;
}

function arraysEqual(a: any[], b: any[]) {
	if (a === b) return true;
	if (a == null || b == null) return false;
	if (a.length !== b.length) return false;

	for (let i = 0; i < a.length; ++i) {
		if (Array.isArray(a[i])) {
			if (!arraysEqual(a[i], b[i])) return false;
		} else {
			if (a[i] !== b[i]) return false;
		}
	}
	return true;
}


let historyInstance = new History();

export default historyInstance;

MainMenu.injectMenu('edit', [

	null,
	{
		name: 'Undo',
		onClick: () => game.editor.history.undo(),
		hotkey: { key: 'z', ctrlKey: true },
		disabled: () => !instance.isUndoAvailable() || !game.__EDITOR_mode
	},
	{
		name: 'Redo',
		onClick: () => game.editor.history.redo(),
		hotkey: { key: 'y', ctrlKey: true },
		disabled: () => !instance.isRedoAvailable() || !game.__EDITOR_mode
	},
	{
		name: 'Selection history back',
		onClick: () => game.editor.history.navigateSelection(-1),
		hotkey: { key: 'ArrowLeft', ctrlKey: true, altKey: true },
		disabled: () => !game.__EDITOR_mode
	},
	{
		name: 'Selection history forward',
		onClick: () => game.editor.history.navigateSelection(1),
		hotkey: { key: 'ArrowRight', ctrlKey: true, altKey: true },
		disabled: () => !game.__EDITOR_mode
	}
], 'history-navigation-built-in');
</file>

<file path="src/editor/utils/hotkey.ts">
import game from 'thing-editor/src/engine/game';
import { CTRL_READABLE } from 'thing-editor/src/engine/utils/utils';


interface Hotkey {
	key: string;
	ctrlKey?: true;
	altKey?: true;
	shiftKey?: true;
}

const isHotkeyHit = (ev: KeyboardEvent, element: HTMLElement, hotkey?: Hotkey) => {
	if (!hotkey) {
		return;
	}

	if ((((ev.ctrlKey || ev.metaKey) && (hotkey.key === 'c' || hotkey.key === 'v')) && (window.getSelection() || '').toString()) ||
		((hotkey.key !== 'F1' && hotkey.key !== 'F12') && game.editor.ui.modal.isUIBlockedByModal(element)) // F1, F12 - hotkey works always
	) {
		return;
	}

	const evCode = (ev.code === 'Backspace') ? 'Delete' : ev.code;

	if ((evCode.replace(/^Key/, '').toLocaleLowerCase() === hotkey.key.toLocaleLowerCase()) &&
		(((ev.ctrlKey || ev.metaKey) || false) === (hotkey.ctrlKey === true)) &&
		((ev.altKey || false) === (hotkey.altKey === true)) &&
		((ev.shiftKey || false) === (hotkey.shiftKey === true))
	) {
		return true;
	}
};


const hotkeyToString = (hotkey:Hotkey) :string => {
	let help = [];
	if (hotkey.ctrlKey) {
		help.push(CTRL_READABLE);
	}
	if (hotkey.altKey) {
		help.push('Alt');
	}
	if (hotkey.shiftKey) {
		help.push('Shift');
	}
	help.push('"' + ((hotkey.key.length > 1) ? hotkey.key : hotkey.key.toUpperCase()) + '"');
	return ' (' + help.join(' + ') + ')';
};


export default isHotkeyHit;
export { hotkeyToString };
export type { Hotkey };
</file>

<file path="src/editor/utils/increase-number-in-name.ts">
const regex = /(\d+)(?!.*\d)/;

export default function increaseNumberInName(name: string | null, step = 1) {
	if (name) {
		let a = regex.exec(name);
		if (a) {
			let oldNum = a.pop()!;
			let newNum = (parseInt(oldNum) + step).toString();
			while (newNum.length < oldNum.length) {
				newNum = '0' + newNum;
			}
			a.shift();
			let n = name.lastIndexOf(oldNum);
			return name.substr(0, n) + newNum + name.substr(n + oldNum.length);
		}
	}
	return name;
}
</file>

<file path="src/editor/utils/is-event-focus-on-input-element.ts">
const isEventFocusOnInputElement = (ev: KeyboardEvent): boolean => {

	let tag = (document.activeElement || (ev.target as HTMLInputElement)).tagName;

	if (((tag === 'INPUT') && ((ev.target as HTMLInputElement).type !== 'checkbox')) ||
			tag === 'TEXTAREA') {

		if (ev.ctrlKey || ev.metaKey) {
			if (ev.key === 'z' || ev.key === 'v' || ev.key === 'y' || ev.key === 'a') {
				return true;
			}
			if (ev.key === 'x' || ev.key === 'c') {
				return !!document.getSelection();
			}
		} else if (ev.key !== 'Escape') {
			return true;
		}
	}
	return false;
};

export default isEventFocusOnInputElement;
</file>

<file path="src/editor/utils/lib-info.ts">
import type { ComponentChild, ComponentChildren } from 'preact';
import type { FileDesc, LibInfo } from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';

const libIconCache: Map<LibInfo, ComponentChild> = new Map();

const LIB_HOLDER = R.span({ className: 'empty-lib-holder' });

const libIcon = (libInfo: LibInfo): ComponentChildren => {
	if (!libIconCache.has(libInfo)) {
		libIconCache.set(libInfo, R.icon('lib' + (libInfo.libNum % 7)));
	}
	return libIconCache.get(libInfo);
};

const libInfo = (file: FileDesc): ComponentChildren => {
	if (file.lib) {
		if (!file.libInfoCache) {
			const libInfo = file.lib;
			const icon = libIcon(libInfo);
			file.libInfoCache = R.span({
				className: 'lib-info',
				title: libInfo.name
			},
			icon
			);
		}
		return file.libInfoCache;
	} else {
		return LIB_HOLDER;
	}
};

export default libInfo;
export { libIcon };
</file>

<file path="src/editor/utils/load-safe-instance-by-class-name.ts">
import type { Container } from 'pixi.js';
import Lib from 'thing-editor/src/engine/lib';

const loadSafeInstanceByClassName = (className: string, isForWrapping = false): Container => {

	let ret: Container;

	const PREFAB_NAME = '___default_content/' + className.toLocaleLowerCase();

	if (Lib.hasPrefab(PREFAB_NAME)) {
		ret = Lib.loadPrefab(PREFAB_NAME);
		ret.name = '';
		return ret;
	} else {
		ret = Lib._loadClassInstanceById(className);
	}

	if (ret.__EDITOR_onCreate) {
		ret.__EDITOR_onCreate(isForWrapping);
	}

	return ret;
};

export default loadSafeInstanceByClassName;
</file>

<file path="src/editor/utils/merge-project-desc.ts">
import assert from 'thing-editor/src/engine/debug/assert';

const isProjectDescValueKeyedMap = (key: string) => {
	return key === 'loadOnDemandTextures' || key === 'loadOnDemandSounds' ||
		key === 'soundBitRates';
};

const mergeProjectDesc = (target: ProjectDesc, src: ProjectDesc) => {
	for (const key in src) {
		const targetVal = (target as KeyedObject)[key];
		const srcVal = (src as KeyedObject)[key];
		if (isProjectDescValueKeyedMap(key)) {
			(target as KeyedObject)[key] = Object.assign({}, srcVal, targetVal);
		} else if (key === 'webfontloader') {
			let newVal;
			if (targetVal && typeof targetVal !== 'object') {
				assert(false, 'invalid "webfontloader" property: ' + JSON.stringify(targetVal));
			}
			if (srcVal && typeof srcVal !== 'object') {
				assert(false, 'invalid "webfontloader" property: ' + JSON.stringify(srcVal));
			}

			if (!srcVal) {
				newVal = targetVal;
			} else if (!targetVal) {
				newVal = srcVal;
			} else {
				newVal = Object.assign({}, targetVal);
				for (let provider in srcVal) {
					if (srcVal[provider] && srcVal[provider].families) {
						let families = srcVal[provider].families;
						if (targetVal[provider] && targetVal[provider].families) {
							families = targetVal[provider].families.concat(families);
						}
						newVal[provider] = { families };
					} else {
						newVal[provider] = srcVal[provider];
					}
				}
			}
			(target as KeyedObject)[key] = newVal;
		} else if (Array.isArray(targetVal)) {
			if (srcVal) {
				const newVal = targetVal.slice();
				for (const s of srcVal) {
					if (newVal.indexOf(s) < 0) {
						newVal.push(s);
					}
				}
				(target as KeyedObject)[key] = newVal;
			}
		} else {
			(target as KeyedObject)[key] = srcVal;
		}
	}
};


export default mergeProjectDesc;

export { isProjectDescValueKeyedMap };
</file>

<file path="src/editor/utils/movie-clip-keyframe-select-path.ts">
import type { TimelineFieldData, TimelineKeyFrame } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';

const makePathForKeyframeAutoSelect = (property: string | EditablePropertyDesc, field: TimelineFieldData, keyframe: TimelineKeyFrame) => {
	return ((property as EditablePropertyDesc).name || property) + ',' + field.n + ',' + keyframe.t;
};

export default makePathForKeyframeAutoSelect;
</file>

<file path="src/editor/utils/new-component-wizard.ts">
import fs from 'thing-editor/src/editor/fs';
import R from 'thing-editor/src/editor/preact-fabrics';
import type { ChooseListItem } from 'thing-editor/src/editor/ui/choose-list';
import game from 'thing-editor/src/engine/game';

interface ChooseTemplateItem extends ChooseListItem {
	title: string;
	desc: string;
	path: string;
	isScene: boolean;
}

const newComponentWizard = async () => {

	let chosenFolder: string | undefined = await game.editor.chooseAssetsFolder('Where to create component?');

	if (!chosenFolder) {
		return;
	}

	let selectedTemplate = await game.editor.ui.modal.showListChoose('Choose template for new Custom Component', ([
		{
			title: 'Basic Game Object',
			desc: 'Creates simple game object. Then you can program this object\'s logic with javascript. This type of object will contain only basic methods of game object \'init\', \'update\', \'onRemove\', but you can add any method you want manually.',
			path: 'basic-game-object.tst',
			isScene: false
		},
		{
			title: 'Basic Scene',
			desc: 'Creates new type of scenes. Then you can create new scenes with this type.',
			path: 'basic-scene.tst',
			isScene: true
		},
		{
			title: 'Full Game Object',
			desc: 'Contains all the methods of game object. Include \'game methods\', and \'editor mode methods\'.',
			path: 'full-game-object.tst',
			isScene: false
		},
		{
			title: 'Full Scene',
			desc: 'Contains all the methods of game scene. Include \'game methods\', and \'editor mode methods\'.',
			path: 'full-scene.tst',
			isScene: true
		}
	] as ChooseTemplateItem[]).map((tmp) => {
		tmp.pureName = tmp.title;
		tmp.name = R.div({ className: 'project-item-select' },
			R.div(null, tmp.title),
			R.div({ className: 'template-desc' }, tmp.desc)
		);
		return tmp;
	}), false, true);


	if (!selectedTemplate) {
		return;
	}

	let enteredClassName = await game.editor.ui.modal.showPrompt('Enter Component Name',
		selectedTemplate.isScene ? 'custom/MyNewScene' : 'custom/MyNewComponent',
		(val) => { //filter
			return val.replace(/[^a-zA-Z0-9\/]/gm, '_');
		},
		(val) => { //accept
			if (game.classes[val]) {
				return 'Component with name \'' + val + '\' already exists';
			}
		}
	);

	if (!enteredClassName) {
		return;
	}

	let selectedBaseClassName = await game.editor.chooseClass(selectedTemplate.isScene, '_baseClass', 'Choose base Component');

	if (!selectedBaseClassName) {
		return;
	}

	const selectedBaseClass = game.classes[selectedBaseClassName];
	let enteredClassNameParts = enteredClassName.split('/').filter((i: string) => i);
	enteredClassName = enteredClassNameParts.pop()!;
	if (!enteredClassName) {
		game.editor.ui.modal.showError('Wrong component name provided.', 30001);
		return;
	}
	if (enteredClassName.match('/^[\d_]/m')) {
		game.editor.ui.modal.showError('Class name can not start with digit or "_".', 30002);
		return;
	}
	enteredClassName = enteredClassName.substr(0, 1).toUpperCase() + enteredClassName.substr(1);

	let classFoldername = enteredClassNameParts.join('/');
	if (classFoldername) {
		classFoldername += '/';
	}
	let templateSrc = fs.readFile('thing-editor/src/editor/templates/' + selectedTemplate.path);

	//add or remove super method call if its exists
	let baseClassInstance = new (selectedBaseClass as any)();
	const regex = /(\/\/)(super\.)([a-zA-Z_]+)(\(\);)/gm;
	templateSrc = templateSrc.replace(regex, (_substr, _m1, m2, m3, m4) => {
		let isSuperClassHasThisMethod = (baseClassInstance as KeyedObject)[m3];
		if (isSuperClassHasThisMethod) {
			return m2 + m3 + m4;
		} else {
			return '';
		}
	});

	let baseClassPath = selectedBaseClass.__sourceFileName!.replace(/^\//, '').replace(/\.ts$/, '');

	templateSrc = templateSrc.replace(/CURRENT_PROJECT_DIR/gm, '/games/' + (game.editor.currentProjectDir.replace(/\/$/, '')));
	templateSrc = templateSrc.replace(/NEW_CLASS_NAME/gm, enteredClassName);
	templateSrc = templateSrc.replace(/BASE_CLASS_NAME/gm, selectedBaseClass.__className);
	templateSrc = templateSrc.replace(/BASE_CLASS_PATH/gm, baseClassPath);
	let createdCount = game.editor.settings.getItem('created-components', 0);
	createdCount++;
	game.editor.settings.setItem('created-components', createdCount);

	if (createdCount > 3) {
		templateSrc = templateSrc.replace(/\t*((\/\*(.|\n)+\*\/)|(\/\/.+))\n\t*/gm, '');
	}

	let fileName = enteredClassName.replace(/[A-Z]/gm, (substr: string, offset: number) => {
		return ((offset === 0 || enteredClassName[offset - 1] === '_') ? '' : '-') + substr.toLowerCase();
	});
	fileName = chosenFolder + 'src/' + classFoldername + fileName + '.c.ts';
	fs.writeFile(fileName, templateSrc);
	fs.refreshAssetsList();
	game.editor.reloadClasses().then(() => {
		game.editor.editClassSource(game.classes[enteredClassName]);
	});
};

export default newComponentWizard;
</file>

<file path="src/editor/utils/number-checker.ts">
import { ObservablePoint } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';

let _definedProps = new WeakMap();
let _valStore = new WeakMap();

let _getValStore = (o: KeyedObject) => {
	if (!_valStore.has(o)) {
		_valStore.set(o, {});
	}
	return _valStore.get(o);
};


export default function wrapPropertyWithNumberChecker(constructor: SourceMappedConstructor, propertyName: string) {

	if (!_definedProps.has(constructor)) {
		_definedProps.set(constructor, {});
	}
	let o = _definedProps.get(constructor);
	if (o.hasOwnProperty(propertyName)) return; //wrapped already
	o[propertyName] = true;

	let originalSetter: ((val: any) => void) | undefined;

	let newSetter = function wrapPropertyWithNumberCheckerSetter(this: KeyedObject, val: any) {
		const isNumberValid = typeof val === 'number' && !isNaN(val);
		if (!isNumberValid) {
			console.error('invalid value for "' + propertyName + '". Valid number value expected. ' + val + ' received. ' + (this.___info || ''));
			debugger;
			val = 0;
		}
		(originalSetter as any).call(this, val);
	};

	let d;

	let prot = constructor.prototype;
	while (prot) {
		d = Object.getOwnPropertyDescriptor(prot, propertyName);
		if (d) {
			//console.log("Property " + propertyName + " wrapped.")
			originalSetter = d.set;

			if ((originalSetter as any).name === 'wrapPropertyWithNumberCheckerSetter') {
				return;
			}
			d.set = newSetter;
			break;
		}
		prot = Object.getPrototypeOf(prot);
	}

	if (!d) {
		//console.log("Own property " + propertyName + " wrapped.")
		let privValue = '__wrapper_store_' + propertyName;

		originalSetter = function (this: KeyedObject, val: any) {
			_getValStore(this)[privValue] = val;
		};
		d = {
			set: newSetter, get: function () {
				return _getValStore(this)[privValue];
			}
		};
	}

	try {
		Object.defineProperty(constructor.prototype, propertyName, d);
	} catch (_er) {
		assert(false, 'Can not add NaN checking for property \'' + propertyName + '\'. Please make this property configurable or add noNullCheck flag in it`s descriptor.', 40903);
	}
}

wrapPropertyWithNumberChecker(ObservablePoint as any, 'x');
wrapPropertyWithNumberChecker(ObservablePoint as any, 'y');
</file>

<file path="src/editor/utils/old-references-detect.ts">
import { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';

import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

const objectsReferences: Map<KeyedObject, Map<string, any>> = new Map;

function markOldReferences(o: KeyedObject) {
	const refsMap = new Map();
	objectsReferences.set(o, refsMap);
	for (let f of Object.getOwnPropertyNames(o)) {
		if (((o as KeyedObject)[f] instanceof Container)) {
			if (f !== 'tempDisplayObjectParent') {
				o[f] = accessDetectionProxy(o.constructor as SourceMappedConstructor, f);
				refsMap.set(f, o[f]);
			}
		}
	}
}

function checkForOldReferences(o: KeyedObject) {
	if (objectsReferences.has(o) && !Lib.__outdatedReferencesDetectionDisabled) {
		const refsMap = objectsReferences.get(o)!;
		const keys = refsMap.keys();
		for (let f of keys) {
			if (o[f] === refsMap.get(f)) {
				let c = o.constructor as SourceMappedConstructor;
				game.editor.ui.status.error(c.name + ' did not clean reference to display object in property "' + f + '". Please null this field in onRemove method, or add "@editable({type: "ref"})" decorator for this field (click to copy fix-js and open class source code.).', 10048, () => {
					game.editor.copyToClipboard('@editable({type: "ref"})');
					game.editor.editClassSource(c);
				});
			}
		}
	}
}

function accessToOldReferenceDetector(obj: OutdatedProxy, prop: any): any {
	if (!Lib.__outdatedReferencesDetectionDisabled) {
		game.editor.editClassSource(obj.class_);
		assert(prop === 'thisIsOutdatedReference', 'Access to outdated reference "' + obj.fieldName + '" in class "' + obj.class_.__className + '" detected. Please clear reference in onRemove method.', 10041);
	}
}

interface OutdatedProxy {
	thisIsOutdatedReference: 'thisIsOutdatedReference';
	class_: SourceMappedConstructor;
	fieldName: string;
}

const accessDetectionProxiesCache = new Map();
const accessDetectionProxy = (class_: SourceMappedConstructor, fieldName: string) => {
	let key = class_.__className + ':' + fieldName;
	if (!accessDetectionProxiesCache.has(key)) {
		let procObject: OutdatedProxy = {
			thisIsOutdatedReference: 'thisIsOutdatedReference',
			class_,
			fieldName
		};

		let p = new Proxy(procObject, {
			get: accessToOldReferenceDetector,
			set: accessToOldReferenceDetector,
			has: accessToOldReferenceDetector,
			deleteProperty: accessToOldReferenceDetector,

			ownKeys: (accessToOldReferenceDetector as any),
			apply: accessToOldReferenceDetector
		});
		accessDetectionProxiesCache.set(key, p);
		return p;
	}
	return accessDetectionProxiesCache.get(key);
};

export { checkForOldReferences, markOldReferences };
</file>

<file path="src/editor/utils/prefab-editor.ts">
import type { Container } from 'pixi.js';
import { exitIsolation } from 'thing-editor/src/editor/ui/isolation';
import { regeneratePrefabsTypings } from 'thing-editor/src/editor/utils/generate-editor-typings';

import __refreshPrefabRefs, { __refreshPrefabRefsPrepare } from 'thing-editor/src/editor/utils/refresh-prefabs';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type __SystemBackDrop from 'thing-editor/src/engine/lib/assets/src/___system/backdrop.c';
import type Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';
import loadDynamicTextures from 'thing-editor/src/engine/utils/load-dynamic-textures';
import type { PREFAB_PIVOT } from '../ui/viewport';

let prefabsStack: string[] = [];
let backDrop: Container;
let backDropBG: Shape;

function applyGridPos() {
	if (backDrop) {
		switch (PrefabEditor.pivot) {
		case 'left-top':
			backDrop.x = game.W / 2;
			backDrop.y = game.H / 2;
			break;
		default:
			backDrop.x = 0;
			backDrop.y = 0;

		}
	}
}

export default class PrefabEditor {

	static editPrefab(name: string, isItStepInToStack = false) {
		if (game.__EDITOR_mode) {
			if (!Lib.hasPrefab(name)) {
				game.editor.ui.modal.showError('No prefab with name ' + name + ' exists.');
				return;
			}
			while (game.editor.ui.modal.state.modals.length) {
				game.editor.ui.modal.hideModal();
			}

			let a = prefabsStack.slice();
			PrefabEditor.acceptPrefabEdition();
			if (isItStepInToStack) {
				prefabsStack = a;
			}
			let preview = Lib.__loadPrefabNoInit(name);
			PrefabEditor.showPreview(preview);
			game.editor.ui.sceneTree.selectInTree(preview);
			game.editor.ui.viewport.setPrefabMode(name);
			game.editor.history.setCurrentStateUnmodified();
			prefabsStack.push(name);
			game.editor.ui.refresh();
		}
	}

	private static __pivot?: PREFAB_PIVOT;
	static set pivot(v: PREFAB_PIVOT | undefined) {
		PrefabEditor.__pivot = v;
		applyGridPos();
	}

	static get pivot() {
		return PrefabEditor.__pivot;
	}

	static get BGColor() {
		return backDropBG.shapeFillColor;
	}

	static set BGColor(val: number) {
		backDropBG.shapeFillColor = val;
	}

	private static savePrefabSettings() {
		if (this.currentPrefabName) {
			game.editor.settings.setItem('prefab-settings' + this.currentPrefabName, {
				bg: backDropBG.shapeFillColor,
				x: game.stage.x,
				y: game.stage.y,
				s: game.stage.scale.x
			});
		}
	}

	private static showPreview(object: Container) {
		if (!backDrop) {
			backDrop = Lib.__loadPrefabNoInit('___system/backdrop') as __SystemBackDrop;
			backDrop.name = null; // prevent get by name error;
			backDrop.__nodeExtendData.hidden = true;
			backDropBG = backDrop.findChildByName('backdrop') as Shape;
			applyGridPos();
		}
		exitIsolation();
		PrefabEditor.hidePreview();
		const prefabSettings = game.editor.settings.getItem('prefab-settings' + object.name, { bg: 0 });
		PrefabEditor.pivot = object.__prefabPivot;
		PrefabEditor.BGColor = prefabSettings.bg;
		game.stage.scale.x = game.stage.scale.y = prefabSettings.s || 1;
		game.stage.x = prefabSettings.x || (-object.x + game.W / 2);
		game.stage.y = prefabSettings.y || (-object.y + game.H / 2);

		game.stage.addChild(backDrop);
		game.showModal(object, undefined, true);
		this.currentPrefabName = object.name;
		object.__nodeExtendData.childrenExpanded = true;
		window.setTimeout(() => {
			let selectionData = game.editor.settingsLocal.getItem('__prefab-selection' + game.currentContainer.name);
			if (selectionData) {
				game.editor.selection.loadSelection(selectionData);
			}
			game.onResize();
		}, 1);
		loadDynamicTextures();
	}

	static currentPrefabName: string | null;

	static hidePreview() {
		exitIsolation();
		game.editor.ui.viewport.resetZoom();
		backDrop.detachFromParent();
		if (this.currentPrefabName) {
			let selectionData = game.editor.selection.saveSelection();
			game.editor.settingsLocal.setItem('__prefab-selection' + game.currentContainer.name, selectionData);
			assert(game.currentContainer.name === this.currentPrefabName, 'Wrong edition prefab name');
			game.hideModal();
			this.currentPrefabName = null;
			game.editor.ui.refresh();
			loadDynamicTextures();
			game.editor.selection.loadSelection(game.editor.history.currentState.selectionData);
		}
	}

	static getCurrentPrefabName() {
		return prefabsStack[prefabsStack.length - 1];
	}

	static acceptPrefabEdition(oneStepOnly = false) {
		exitIsolation();
		this.savePrefabSettings();
		game.editor.blurPropsInputs();
		game.editor.history.saveHistoryNow();
		let name = this.getCurrentPrefabName();
		let isChanged = prefabsStack.length && game.editor.isCurrentContainerModified;
		if (isChanged) {
			__refreshPrefabRefsPrepare();
			if (prefabsStack.length) {
				if (PrefabEditor.checkPrefabReferenceForLoops(game.currentContainer, name)) {
					return false;
				}
				game.editor.history.setCurrentStateUnmodified();
				game.editor._callInPortraitMode(() => {
					Lib.__savePrefab(game.currentContainer, name);
				});
				game.editor.validateResources();
			}
		}

		PrefabEditor.exitPrefabEdit(oneStepOnly);
		if (isChanged) {
			__refreshPrefabRefs();
			regeneratePrefabsTypings();
		}
	}

	static checkPrefabReferenceForLoops(o: Container, prefabName: string): boolean {
		let ret = false;
		o.forAllChildren((o) => {
			if (o.__nodeExtendData.isPrefabReference) {
				if (checkPrefabDataForLoop(Lib.prefabs[o.__nodeExtendData.isPrefabReference], prefabName)) {
					game.editor.ui.status.error('Could not save prefab changes. Loop in prefab references detected', 99999, o);
					game.editor.selection.select(o);
					ret = true;
				}
			}
		});
		return ret;
	}

	static exitPrefabEdit(oneStepOnly = false) {
		exitIsolation();
		if (prefabsStack.length) {

			game.editor.ui.viewport.setPrefabMode();
			PrefabEditor.hidePreview();
			if (oneStepOnly) {
				prefabsStack.pop();
				if (prefabsStack.length > 0) {
					PrefabEditor.editPrefab(prefabsStack.pop() as string, true);
				}
			} else {
				prefabsStack.length = 0;
			}
			game.editor.ui.refresh();
		}
	}
}

function checkPrefabDataForLoop(data: SerializedObject, loopName: string): boolean {
	if (!data) {
		return false;
	}
	if (data.r === loopName) {
		return true;
	}
	if (data[':']) {
		return Object.values(data[':']).some((d) => {
			return checkPrefabDataForLoop(d, loopName);
		});
	}
	return false;
}
</file>

<file path="src/editor/utils/prefab-selector.ts">
import type { SelectEditorItem } from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import Lib from 'thing-editor/src/engine/lib';

export default function makePrefabSelector(startsWith?: string, canBeEmpty = true, filter?: ((item: SelectEditorItem) => boolean)) {
	let ret = () => {
		let prefabsList: SelectEditorItem[] = [];
		if (canBeEmpty) {
			prefabsList.push({ name: ' ', value: null });
		}
		let a = Lib.prefabs;
		for (let name in a) {
			if (!startsWith || name.startsWith(startsWith)) {
				prefabsList.push({ name, value: name });
			}
		}
		if (filter) {
			prefabsList = prefabsList.filter(filter);
		}
		return prefabsList;
	};

	return ret;
}
</file>

<file path="src/editor/utils/protect-access-to-node.ts">
import type { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';

const protectAccessToSceneNode = (o: Container, debugName: string) => {
	o.name = debugName;
	o.__nodeExtendData = {};
	o.remove = () => {
		assert(false, 'Attempt to remove system node' + debugName, 10002);
	};
	o.destroy = () => {
		assert(false, 'Attempt to destroy system node ' + debugName, 10003);
	};
	o.detachFromParent = () => {
		assert(false, 'Attempt to detachFromParent system node ' + debugName, 10004);
	};
	(o as SelectableProperty).___EDITOR_isHiddenForChooser = true;
};

export default protectAccessToSceneNode;
</file>

<file path="src/editor/utils/refresh-prefabs.ts">
import type { SelectionData } from 'thing-editor/src/editor/utils/selection';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';

let selectionData: SelectionData | undefined;
let newSceneData: SerializedObject | undefined;

const __refreshPrefabRefsPrepare = () => {
	if (game.__EDITOR_mode) {
		selectionData = game.editor.selection.saveSelection();
		newSceneData = Lib.__serializeObject(game.currentScene);
	}
};

const __refreshPrefabRefs = () => {
	if (game.__EDITOR_mode) {
		game.showScene(Lib._deserializeObject(newSceneData!, true) as Scene);
		game.editor.selection.loadSelection(selectionData!);
		newSceneData = undefined;
		selectionData = undefined;
	}
};

export default __refreshPrefabRefs;

export { __refreshPrefabRefsPrepare };
</file>

<file path="src/editor/utils/round-up-point.ts">
const roundUpPoint = (p:{x: number; y: number}) =>{
	p.x = roundUpNumber(p.x);
	p.y = roundUpNumber(p.y);
	return p;
};

const roundUpNumber = (n:number) =>{
	if (Math.abs(n - Math.round(n)) < 0.00000001) {
		return Math.round(n);
	}
	return n;
};

export { roundUpNumber };
export default roundUpPoint;
</file>

<file path="src/editor/utils/scene-all-validator.ts">
import type { Container } from 'pixi.js';
import { DisplayObject } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';

const ACCESS_ASSERTING_Func = () => {
	assert(false, 'Scene`s "all" object vas not initialized yet. You can not use "all" before call super.init().', 10017);
};
const ACCESS__ALL_ASSERTING_PROXY = new Proxy({}, {
	get: ACCESS_ASSERTING_Func,
	set: ACCESS_ASSERTING_Func as any
});


const reasonsCache: Map<number, string> = new Map();

const getRefuseReason = (count: number): string => {
	if (!reasonsCache.has(count)) {
		reasonsCache.set(count, 'Refused because ' + count + ' objects with that name present on the scene.');
	}
	return reasonsCache.get(count)!;
};


let validatorCounter = 0;
let refsCounter: KeyedMap<number> = {};

function addAllRefsValidator(scene: Scene) {
	refsCounter = {};

	let deletionValidator = validatorCounter++;

	scene.all = new Proxy(scene.all, {
		get: (all: KeyedObject, containerName: string) => {
			if (containerName === '___EDITOR_isGoodForChooser') {
				return true;
			} else if (containerName === '___EDITOR_ChooserOrder') {
				return 100000;
			}
			let ret = (all)[containerName];
			if (!game.__EDITOR_mode && containerName !== 'hasOwnProperty') {
				let refsWithThanNameCount = refsCounter[containerName];
				assert(ret, 'Attempt to access to scene object \'all.' + containerName + '\'. Reference is empty: ' + ret, 10018);
				assert((ret instanceof DisplayObject) && (!refsWithThanNameCount || refsWithThanNameCount === 1), 'Attempt to access to object \'all.' + containerName + '\'. But ' + refsWithThanNameCount + ' object with that name present on scene ' + scene.name + '(' + scene.constructor.name + ').', 10019);
				assert(ret.__nodeExtendData.__allRefsDeletionValidator === deletionValidator, 'Attempt to access to scene object \'all.' + containerName + '\'. Reference to object is presents, but this object was removed from scene already. Use \'all\' path only for objects which never deleted from scene.', 10020);
			}
			return ret;
		},
		set: (all: KeyedObject, containerName: string, val: Container) => {
			val.__nodeExtendData.__allRefsDeletionValidator = deletionValidator;
			let count = refsCounter[containerName] || 0;
			if (!count) {
				all[containerName] = val;
			}
			count++;
			refsCounter[containerName] = count;
			return true;
		}
	}) as ThingSceneAllMap;
}

const getAllObjectRefsCount = (name: string): string | undefined => {
	let count = refsCounter[name];
	if (count > 1) {
		return getRefuseReason(count);
	}
};


export { ACCESS__ALL_ASSERTING_PROXY, addAllRefsValidator, getAllObjectRefsCount };
</file>

<file path="src/editor/utils/scene-utils.ts">
import loadSafeInstanceByClassName from 'thing-editor/src/editor/utils/load-safe-instance-by-class-name';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';

function onNewSceneClick() {
	game.editor.askSceneToSaveIfNeed();

	askNewSceneName('New scene name').then((enteredName) => {
		if (enteredName) {
			game.editor.chooseClass(true, '_newScene', 'Select type for new scene:').then((selectedClass) => {
				if (selectedClass) {
					const scene = loadSafeInstanceByClassName(selectedClass);
					Lib.__saveScene(scene as Scene, enteredName);
					Lib.destroyObjectAndChildren(scene);
					game.editor.openScene(enteredName);
				}
			});
		}
	});
}

const sceneNameFilter = /[^a-z\-\/0-9]/g;

function askNewSceneName(title: string, defaultSceneName = '') {
	return game.editor.ui.modal.showPrompt(title,
		defaultSceneName,
		(val) => { // filter
			return val.toLowerCase().replace(sceneNameFilter, '');
		},
		(val) => { //accept
			if (Lib.scenes.hasOwnProperty(val)) {
				return 'Scene with such name already exists';
			}
			if (val.endsWith('/') || val.startsWith('/')) {
				return 'name can not begin or end with "/"';
			}
		}
	);
}

function onSaveAsSceneClick() {
	let defaultSceneNameParts = game.editor.currentSceneName.split('/');
	defaultSceneNameParts.pop();
	let defaultSceneName = defaultSceneNameParts.join('/');
	if (defaultSceneName) {
		defaultSceneName += '/';
	}
	askNewSceneName('Save scene as', defaultSceneName).then((enteredName) => {
		if (enteredName) {
			game.editor.saveCurrentScene(enteredName);
			game.editor.ui.forceUpdate();
		}
	});
}

export { onNewSceneClick, onSaveAsSceneClick };
</file>

<file path="src/editor/utils/scroll-in-view.ts">
import shakeDomElement from 'thing-editor/src/editor/utils/shake-element';

const scrollInToViewAndShake = (element: HTMLElement) => {
	let p = element;
	while (p) {
		if (p.classList.contains('props-group-body') && p.classList.contains('hidden')) {
			p.classList.remove('hidden');
		}
		p = p.parentElement as HTMLElement;
	}
	scrollInToView(element);
	shakeDomElement(element);
};

const scrollInToView = (element: HTMLElement) => {
	(element as any).scrollIntoViewIfNeeded({ block: 'center', inline: 'center' });
	document.scrollingElement!.scrollTop = 0;
	document.scrollingElement!.scrollLeft = 0;
	document.body.scrollTop = 0;
	document.body.scrollLeft = 0;
};

export default scrollInToViewAndShake;

export { scrollInToView };
</file>

<file path="src/editor/utils/search-by-regexp-or-text.ts">
let lastSearchQuery: string;
let lastSearchRegExp: RegExp;

function searchByRegexpOrText(source: string, query: string) {
	if (!query) return true;
	try {
		let regExp;
		if (lastSearchQuery === query) {
			regExp = lastSearchRegExp;
		} else {
			regExp = new RegExp(query, 'i');
			lastSearchQuery = query;
			lastSearchRegExp = regExp;
		}
		if (source.search(regExp) >= 0) {
			return true;
		}
	} catch (_er) {}
	return source.toLowerCase().indexOf(query.toLowerCase()) >= 0;
}

export { searchByRegexpOrText };
</file>

<file path="src/editor/utils/selection.ts">
import assert from 'thing-editor/src/engine/debug/assert';

import { OutlineFilter } from '@pixi/filter-outline';

import type { Container } from 'pixi.js';
import TreeNode from 'thing-editor/src/editor/ui/tree-view/tree-node';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import getParentWhichHideChildren from 'thing-editor/src/editor/utils/get-parent-with-hidden-children';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import game from 'thing-editor/src/engine/game';
import LabelsLogger from '../ui/labels-logger';

const selectionFilter = new OutlineFilter(3, 0xffff00);
selectionFilter.padding = 3;
let filterPhase = false;

window.setInterval(() => {
	if (filterPhase || !game.editor.isGizmoVisible) {
		if (selectionFilter.alpha > 0) {
			selectionFilter.alpha -= 0.02;
			if (selectionFilter.alpha < 0.5) {
				filterPhase = false;
			}
		}
	} else {
		selectionFilter.alpha += 0.02;
		if (selectionFilter.alpha > 0.7) {
			filterPhase = true;
		}
	}

	selectionFilter.thickness = 3 * game.editor.ui.viewport.viewportScale;

}, 30);

interface SelectionPathEntry {
	n: string | null;
	i: number;
}
type SelectionPath = SelectionPathEntry[];

type SelectionDataBase = SelectionPath[];

interface SelectionData extends SelectionDataBase {
	_stageX?: number;
	_stageY?: number;
	_stageS?: number;
}

let IS_SELECTION_LOADING_TIME = false;

export default class Selection extends Array<Container> {

	constructor() {
		super();
		this._refreshOutlinesInner = this._refreshOutlinesInner.bind(this);
	}

	select(object: Container, add?: boolean, onTreeViewUpdated?:() => void, scrollInView = false) {
		if (!add) {
			if (this.length === 1 && this[0] === object) {
				onTreeViewUpdated && onTreeViewUpdated();
				return;
			}
			this.clearSelection();
		}
		if (object.__nodeExtendData.isSelected) {
			this.remove(object);
		} else {
			this.add(object, scrollInView);
		}
		filterPhase = false;
		this.sortSelectedNodes();
		game.editor.refreshTreeViewAndPropertyEditor(onTreeViewUpdated);
	}

	sortSelectedNodes() {
		recalculateNodesDeepness();
		this.sort(sortByDeepness);
	}

	add(o: Container, scrollInView = false) {
		let nodePath = getPathOfNode(o);
		let hidingParent = getParentWhichHideChildren(o, true);
		if (hidingParent && (hidingParent !== o)) {
			let popupShown = false;
			if (hidingParent.__nodeExtendData.isPrefabReference) {
				let parentPath = getPathOfNode(hidingParent);
				nodePath.length -= parentPath.length;

				let prefabName = hidingParent.__nodeExtendData.isPrefabReference;

				if (prefabName) {
					popupShown = true;
					PrefabEditor.editPrefab(prefabName, true);
					game.editor.selection.loadSelection([nodePath]);
				}
			}
			if (!popupShown) {
				game.editor.ui.modal.notify('Can not select object, because it is hidden by parent ' + (hidingParent.constructor as SourceMappedConstructor).__className + '; ' + o.___info, 'selection');
			}
			return;
		}

		assert(!o.__nodeExtendData.isSelected, 'Node is selected already.');
		assert(this.indexOf(o) < 0, 'Node is registered in selected list already.');
		o.__nodeExtendData.isSelected = true;
		let p = o.parent;
		while (p && p !== game.stage) {
			let data = p.__nodeExtendData;
			if (!data.hidden) {
				data.childrenExpanded = true;
			}
			p = p.parent;
		}

		this.push(o);
		o.__onSelect();
		if (scrollInView) {
			game.editor.ui.viewport.scrollInToScreen(o);
		}
		if (!IS_SELECTION_LOADING_TIME) {
			game.editor.history.scheduleSelectionSave();
		}
		LabelsLogger.refresh();
		this._refreshOutlines();
	}

	private outlineTimeout = 0;

	private _refreshOutlines() {
		if (!this.outlineTimeout) {
			this.outlineTimeout = window.setTimeout(this._refreshOutlinesInner, 1);
		}
	}

	private _refreshOutlinesInner() {
		this.outlineTimeout = 0;
		forAllSelected:
		for (const o of this) {
			let p = o.parent;
			while (p) {
				if (p.__nodeExtendData.isSelected) {
					o.removeFilter(selectionFilter);
					continue forAllSelected;
				}
				p = p.parent;
			}
			if (!o.filters?.includes(selectionFilter)) {
				o.addFilter(selectionFilter);
			}
		}
	}

	remove(o: Container) {
		game.editor.blurPropsInputs();
		assert(o.__nodeExtendData.isSelected, 'Node is not selected.');
		let i = this.indexOf(o);
		assert(i >= 0, 'Node is not registered in selected list.');
		o.__nodeExtendData.isSelected = false;
		o.removeFilter(selectionFilter);
		this.splice(i, 1);
		editorUtils.exitPreviewMode(o);
		if (!IS_SELECTION_LOADING_TIME) {
			game.editor.history.scheduleSelectionSave();
		}
		if (o.__onUnselect) {
			o.__onUnselect();
		}
		LabelsLogger.refresh();
		this._refreshOutlines();
	}

	saveSelection(): SelectionData {
		return this.map(getPathOfNode);
	}

	loadSelection(data: SelectionData) {
		IS_SELECTION_LOADING_TIME = true;
		if (!data || data.length === 0) {
			game.editor.selection.clearSelection();
		} else {
			this.clearSelection();
			data.some(selectNodeByPath);
		}
		TreeNode.clearLastClicked();
		game.editor.refreshTreeViewAndPropertyEditor();
		IS_SELECTION_LOADING_TIME = false;
	}

	clearSelection(refreshUI = false) {
		while (this.length > 0) {
			this.remove(this[this.length - 1]);
		}
		TreeNode.clearLastClicked();
		if (refreshUI) {
			game.editor.refreshTreeViewAndPropertyEditor();
		}
	}

	saveCurrentSelection() {
		game.editor.settingsLocal.setItem('__EDITOR_scene_selection' + game.editor.currentSceneName, game.editor.selection.saveSelection());
	}

	loadCurrentSelection() {
		this.loadSelection(game.editor.settingsLocal.getItem('__EDITOR_scene_selection' + game.editor.currentSceneName));
	}
}

let getPathOfNode = (node: Container): SelectionPath => {
	let ret: SelectionPath = [];
	while (node !== game.stage) {
		const a = node.parent.children.filter((c) => { return c.name === node.name; });
		ret.push({ n: node.name, i: a.indexOf(node) });
		node = node.parent;
	}
	return ret;
};

const selectNodeByPath = (path: SelectionPath) => {
	let ret = game.stage as Container;
	for (let i = path.length - 1; i >= 0 && ret; i--) {
		let p = path[i];
		const a = ret.children.filter((c) => { return c.name === p.n; });
		if (p.i < a.length) {
			ret = a[p.i] as Container;
		} else {
			return;
		}
	}

	if (ret && ret !== game.stage) {
		game.editor.selection.add(ret);
	}
};

export type { SelectionData };


//-------- sorting selection --------------------------------
let curDeepness = 0;

let recalculateNodesDeepness = () => {
	curDeepness = 0;
	recalculateNodesDeepnessRecursive(game.stage);
};

let recalculateNodesDeepnessRecursive = (n: Container) => {
	n.__nodeExtendData.deepness = curDeepness++;
	if (n.hasOwnProperty('children')) {
		n.children.some(recalculateNodesDeepnessRecursive as ((c: any, i: any, a: any) => void));
	}
};

let sortByDeepness = (a: Container, b: Container): number => {
	return (a.__nodeExtendData.deepness as number) - (b.__nodeExtendData.deepness as number);
};
</file>

<file path="src/editor/utils/shake-element.ts">
const shakeDomElement = (e?: HTMLElement | null) => {
	if (e) {
		e.classList.remove('shake');
		e.offsetWidth;
		e.classList.add('shake');
		window.setTimeout(() => {
			e.classList.remove('shake');
		}, 600);
	}
};

export default shakeDomElement;
</file>

<file path="src/editor/utils/stack-utils.ts">
import type { ComponentChild } from 'preact';
import R from 'thing-editor/src/editor/preact-fabrics';
import game from 'thing-editor/src/engine/game';

interface DebugStack {
	title: ComponentChild;
	stack: string;

}

interface StackItem {
	functionName: string;
	path: string;
}

const getCurrentStack = (title: string): DebugStack => {
	let stack = (new Error(title)).stack as string;

	stack = stack.replace('Error: ', '');
	stack = stack.split('http://localhost:5173').join('');
	const a = stack.split('\n');
	a.splice(1, 1);
	stack = a.join('\n');

	return {
		title,
		stack
	};
};

const showStack = (stack: DebugStack, header?: ComponentChild) => {
	let a = stack.stack.split('\n');
	a.shift();
	a.shift();

	const items: StackItem[] = a.map((s) => {
		let functionName;
		if (s.indexOf(' (') > 0) {
			functionName = s.split(' (');
			s = functionName[1].split(')').shift()!;
			functionName = functionName[0];
		} else {
			functionName = '';
		}

		if (s.indexOf('?') > 0) {
			let pathParts = s.split('?');
			let a = pathParts[1].split(':');
			s = pathParts[0] + ':' + a[1];
		}
		return { functionName, path: s };
	});
	game.editor.ui.modal.showModal(R.div(null, header, R.b(null, stack.title), ' was invoked at:', items.map((i, key) => {
		return R.div({
			key, className: 'list-item stack-item', onMouseDown: async () => {
				if (i.path) {
					game.editor.editSource(i.path.startsWith('/') ? i.path : '/' + i.path);
				}
			}
		}, R.b(null, i.functionName), ' (', i.path, ')');
	})));
};


export { getCurrentStack, showStack };
export type { DebugStack };
</file>

<file path="src/editor/utils/stop-propagation.ts">
const sp = (ev: Event) => {
	ev.stopPropagation();
	ev.preventDefault();
};

export default sp;
</file>

<file path="src/editor/utils/unknown-class.ts">
import { Container } from 'pixi.js';

class __UnknownClass extends Container {
	static __defaultValues = {};
}


__UnknownClass.__EDITOR_icon = 'tree/unknown-class';
export { __UnknownClass };
</file>

<file path="src/editor/utils/validate-serialized-data.ts">
import type { Container } from 'pixi.js';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import L from 'thing-editor/src/engine/utils/l';

function validateObjectDataRecursive(objectData: SerializedObject, rootName: string) {
	if (objectData.c) {
		let objectsConstructor = game.classes[objectData.c];
		if (!objectsConstructor) {
			validationError('Unknown component ' + objectData.c + ' detected.', rootName, (o: Container) => {
				return o.__nodeExtendData.unknownConstructor === objectData.c;
			}, undefined, 99999);
		} else {
			if (objectsConstructor.__validateObjectData) {
				let result = objectsConstructor.__validateObjectData(objectData.p);
				if (result) {
					validationError(result.message, rootName, result.findObjectCallback, result.fieldName, result.errorCode, objectsConstructor);
				}

			} for (const field of objectsConstructor.__editableProps) {
				if (field.type === 'image') {
					if (objectData.p.hasOwnProperty(field.name)) {
						const imageName = objectData.p[field.name];
						if (!fs.getFileByAssetName(imageName, AssetType.IMAGE)) {
							validationError('Invalid image \'' + imageName + '\'', rootName, (o: Container) => {
								return (o as KeyedObject)[field.name] === imageName;
							}, field.name, 99999, objectsConstructor);
						}
					}
				} else if (field.type === 'sound') {
					if (objectData.p.hasOwnProperty(field.name)) {
						const soundName = objectData.p[field.name];
						if (!fs.getFileByAssetName(soundName, AssetType.SOUND)) {
							validationError('Invalid sound \'' + soundName + '\'', rootName, (o: Container) => {
								return (o as KeyedObject)[field.name] === soundName;
							}, field.name, 99999, objectsConstructor);
						}
					}
				} else if (field.type === 'l10n') {
					if (objectData.p.hasOwnProperty(field.name)) {
						const localizationKey = objectData.p[field.name];
						if (!L.has(localizationKey)) {
							validationError('Invalid localization key \'' + localizationKey + '\'', rootName, (o: Container) => {
								return (o as KeyedObject)[field.name] === localizationKey;
							}, field.name, 99999, objectsConstructor);
						}
					}
				} else if (field.type === 'prefab') {
					if (objectData.p.hasOwnProperty(field.name)) {
						const prefabName = objectData.p[field.name];
						if (!fs.getFileByAssetName(prefabName, AssetType.PREFAB)) {
							validationError('Invalid prefab \'' + prefabName + '\'', rootName, (o: Container) => {
								return (o as KeyedObject)[field.name] === prefabName;
							}, field.name, 99999, objectsConstructor);
						}
					}
				}
			}
		}
	}
	if (objectData.hasOwnProperty(':')) {
		for (let child of objectData[':']!) {
			validateObjectDataRecursive(child, rootName);
		}
	}
}

function validationError(message: string, rootName: string, findObjectCallback: (o: Container) => boolean | undefined, fieldName?: string, errorCode = 99999, constructor?: SourceMappedConstructor) {
	const selectObject = (o: Container) => {
		game.editor.selection.select(o);
		if (fieldName) {
			game.editor.ui.propsEditor.selectField(fieldName);
		}
	};

	const findObject = () => {
		window.setTimeout(() => {
			if ((!constructor || (game.currentContainer instanceof constructor)) && findObjectCallback(game.currentContainer)) {
				selectObject(game.currentContainer);
			}
			game.currentContainer.forAllChildren((o) => {
				if ((!constructor || (o instanceof constructor)) && findObjectCallback(o)) {
					selectObject(o);
				}
			});
		}, 10);
	};

	game.editor.ui.status.error(message, errorCode, () => {
		if (Lib.prefabs[rootName]) {
			PrefabEditor.editPrefab(rootName);
			findObject();
		} else {
			game.editor.openScene(rootName);
			findObject();
		}
	});
}


export default validateObjectDataRecursive;
</file>

<file path="src/editor/warnings-filter.ts">
let filterAll = false;

const filterWarnings = (args: string[]) => {
	if (filterAll) {
		return true;
	}
	filterAll = args.some((a) => { return (typeof a === 'string') && a.includes('PixiJS Deprecation'); });
	return filterAll;
};

const originalGroupEnd = console.groupEnd;
console.groupEnd = () => {
	filterAll = false;
	originalGroupEnd.apply(console);

};

const originalWarn = console.warn;
console.warn = (...args: string[]) => {
	if (!filterWarnings(args)) {
		originalWarn.apply(console, args);
	}
};
const originalGroupCollapsed = console.groupCollapsed;
console.groupCollapsed = (...args: string[]) => {
	if (!filterWarnings(args)) {
		originalGroupCollapsed.apply(console, args);
	}
};
</file>

<file path="src/engine/basic-preact-fabrics.ts">
import { Fragment, h, type ComponentChildren } from 'preact';
import type { ComponentProps } from '../editor/preact-fabrics';

class R {
	static div: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static form: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static span: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static p: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static img: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static button: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static label: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static b: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static a: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static br: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static hr: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static svg: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static td: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static tr: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static th: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static tbody: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static thead: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static table: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static polyline: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static textarea: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static iframe: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h2: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h3: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h4: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static h5: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static script: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static meta: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static space: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;
	static smallSpace: (props?: ComponentProps | null, ...children: ComponentChildren[]) => preact.Component;

	static fragment(...children: ComponentChildren[]) {
		return h(Fragment, null, ...children);
	}
}

for (let factoryType of ['div', 'form', 'span', 'p', 'img', 'button', 'label',
	'b', 'a', 'br', 'hr', 'svg', 'td', 'tr', 'th', 'tbody', 'thead', 'table', 'polyline',
	'textarea', 'iframe', 'h2', 'h3', 'h4', 'h5', 'script', 'meta', 'space', 'smallSpace']) {

	(R as KeyedObject)[factoryType] = (...theArgs: any[]) => {
		return h(factoryType, ...theArgs as [any]);
	};
}


export default R;
</file>

<file path="src/engine/debug/assert.ts">
function assert(condition: any, message: string, errorCode = 99999): void {
	if (!condition) {
		message = message + '; errorCode: ' + errorCode;
		console.error(message);
		throw new Error(message);
	}
}

export default assert;
</file>

<file path="src/engine/game.ts">
import * as PIXI from 'pixi.js';
(window as any).PIXI = {};
Object.assign((window as any).PIXI, PIXI);

import type { IApplicationOptions } from 'pixi.js';
import { Application, BaseTexture, Container, GC_MODES, MIPMAP_MODES, Point, Texture, TextureGCSystem, utils } from 'pixi.js';
import type { __EditorType } from 'thing-editor/src/editor/editor';
import Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';

import assert from 'thing-editor/src/engine/debug/assert';
import Lib from 'thing-editor/src/engine/lib';

import { ButtonOnlyPropertyDesc } from 'thing-editor/src/editor/utils/button-only-selectable-property';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import SceneLinkedPromise from 'thing-editor/src/engine/lib/assets/___system/scene-linked-promise.c';
import FullScreen from 'thing-editor/src/engine/utils/full-screen';
import initGameInteraction, { addOnClickOnce } from 'thing-editor/src/engine/utils/game-interaction';
import { setValueByPath } from 'thing-editor/src/engine/utils/get-value-by-path';
import Keys from 'thing-editor/src/engine/utils/keys';
import type L from 'thing-editor/src/engine/utils/l';
import loadDynamicTextures from 'thing-editor/src/engine/utils/load-dynamic-textures';
import Settings from 'thing-editor/src/engine/utils/settings';
import Sound from 'thing-editor/src/engine/utils/sound';
import sureQuestionInit from 'thing-editor/src/engine/utils/sure-question';

import fs, { AssetType } from 'thing-editor/src/editor/fs';
import type { AssetsDescriptor } from '../editor/editor-env';
import type { ProjectOrientation } from '../editor/project-desc';
import type Button from './lib/assets/src/basic/button.c';
import ERROR_HTML from './utils/html-error.html?raw';

/// #if EDITOR
/*
/// #endif
	import preloaderAssets from '.tmp/assets-preloader' assert { type: 'json' };
//*/

let app: Application;
let stage: Container;
let modals: Container[] = [];
let hidingModals: Container[] = [];
let currentHidingFaderInUpdate: Container | null;

let scenesStack: (Scene | string)[] = [];
let hideTheseModalsUnderFader: Container[];
let currentFader: Container | undefined;
let hidingFaders: Container[] = [];

let _rendererWidth = 0;
let _rendererHeight = 0;
let scale = 1;

/// #if DEBUG
let lastFPSTime = 0;
type FixedViewportSize = { w: number; h: number } | boolean;

const loadingsInProgressOwners: Set<any> = new Set();

const FILTERED_PROPS = new Set([
	'globalEventDispatcher',
	'onGameReload',
	'loadingsInProgress',
	'loadingsFinished',
	'addAssets',
	'isAllButtonsDisabled'
]);
/// #endif

let contextLoseTime = 0;

const DEFAULT_FADER_NAME = 'fader/default';
const PRELOADER_SCENE_NAME = 'preloader';
const FRAME_PERIOD_LIMIT = 4.0;
const FRAME_PERIOD = 1.0;
let frameCounterTime = 0;

interface Mouse {
	/** click on game canvas */
	gameClick: boolean;
	/** 1 - left button, 2 - right button, 0 - no button pressed*/
	click: number;
	x: number;
	y: number;
}

const processOnResize = (o: Container) => {
	if (o._onRenderResize) {
		o._onRenderResize();
	}
};

export interface ThingGameEvents {
	'assets-will-add': [data: AssetsDescriptor];
	'button-click': [button: Button, source?:string];
	'stage-will-resize': [];
	'preloader-scene-will-start': [];
	'global-update': [];
	'modal-shown': [];
	'update': [];
	'updated': [];
	/// #if EDITOR
	'__sound-overridden': [soundId:string];
	/// #endif
}

declare global {
	interface GameData {

	}
}

class Game extends utils.EventEmitter<ThingGameEvents> {

	/** dynamically override spine library loading path */
	SPINE_SRC_PATH =
	/// #if EDITOR
	'/node_modules/pixi-spine/dist/pixi-spine.js';
	/*
	/// #endif
	'https://cdn.jsdelivr.net/npm/pixi-spine@4.0.4/dist/pixi-spine.js';
	//*/
	W = 0;
	H = 0;

	/** use in your game as storage for any variables accessible in data-path selectors */
	data: GameData = {} as any;

	Sound = Sound;

	_loadingErrorIsDisplayed = false;

	projectDesc!: ProjectDesc;
	all!: ThingSceneAllMap;

	classes!: GameClasses;
	pixiApp!: Application;
	stage!: Container;

	settings!: Settings;

	fullscreen = FullScreen;

	/** browser tab visibility */
	isVisible = true;
	isFocused = false;

	isMobile = utils.isMobile;
	isPortrait = false;
	isLandscapeMobile = false;
	_isCanvasRotated = false;

	_isWaitingToHideFader = false;

	mouse: Mouse = new Point() as any as Mouse;

	frameSeed = 0; // 99999

	/// #if EDITOR
	__mouse_EDITOR: Mouse = new Point() as any as Mouse;
	__mouse_uncropped: Mouse = new Point() as any as Mouse;
	/// #endif

	/** true if after current 'update' will be 'render'. */
	isUpdateBeforeRender = false;

	onGameReload?: () => void;

	private loadingsInProgress = 0;
	private loadingsFinished = 0;
	loadingProgress = 0;

	/// #if EDITOR
	editor!: __EditorType;
	__EDITOR_mode = false;
	/// #endif

	keys = Keys;

	L!: typeof L;


	/** cordova build only */
	exitApp: (() => void) | undefined;

	/// #if EDITOR
	__time = 0;
	get time() {
		return this.__time;
	}
	/*
	/// #endif
	time = 0;
	//*/

	setValueByPath = setValueByPath;

	constructor() {
		super();
		stage = new Container();
		stage.name = 'stage';
		this.stage = stage;
		stage.__nodeExtendData = {};
	}

	init(element?: HTMLElement, gameId?: string, pixiOptions?: Partial<IApplicationOptions>) {
		/// #if EDITOR
		/*
		/// #endif
		game.addAssets(preloaderAssets);
		//*/

		window.dispatchEvent(new CustomEvent('game-will-init'));

		Lib.addTexture('EMPTY', Texture.EMPTY);
		Lib.addTexture('WHITE', Texture.WHITE);

		this.pixiApp = app = new Application(pixiOptions);

		(element || document.body).appendChild(app.view as HTMLCanvasElement);

		this.onResize = this.onResize.bind(this);
		/// #if EDITOR
		(this.onResize as SelectableProperty).___EDITOR_isHiddenForChooser = true;
		/// #endif

		this.settings = new Settings(gameId || this.projectDesc.id);

		/// #if EDITOR
		if (game.projectDesc.screenOrientation === 'auto') {
			this.___enforcedOrientation = game.editor.settingsLocal.getItem('__EDITOR_is-portrait-orientation') ? 'portrait' : undefined;
		}
		/// #endif

		initGameInteraction();

		/// #if EDITOR
		/*
		/// #endif
		loadFonts();
		//*/

		app.stage.addChild(stage);

		/// #if EDITOR
		window.addEventListener('resize', this._onContainerResize.bind(this));
		/*
		/// #endif
		import('.tmp/classes').then(() => {
			game._startGame();
		}).catch(() => {
			game.showLoadingError('classes.js');
		});
		//*/
	}

	_setClasses(_classes: GameClasses) {
		if (!this.classes) {
			this._updateGlobal = this._updateGlobal.bind(this);
			app.ticker.add(this._updateGlobal);
			/// #if EDITOR
			setInterval(() => {
				if (game.pixiApp.ticker.lastTime < (performance.now() - 100)) {
					(game.pixiApp.ticker as any)._tick();
				}
			}, 100);

			/// #endif
			Sound.init();
		}
		this.classes = _classes;
	}

	_startGame() {
		/// #if EDITOR
		assert(false, '_startGame should not be called in editor.');
		/// #endif

		assert(this.classes, 'game.classes is not initialized. Has Vite duped index.js?');

		// workaround for issue: https://jira.bgaming.com/browse/BGG-6807, see for more details: https://github.com/pixijs/pixijs/issues/8315
		(Texture.WHITE.baseTexture.resource.source as any).getContext('2d').fillRect(0, 0, 1, 1);

		this.pixiApp.view.addEventListener!('wheel', (ev) => ev.preventDefault());
		window.addEventListener('resize', this._onContainerResize.bind(this));
		this.onResize();
		this.emit('preloader-scene-will-start');
		this.showScene(PRELOADER_SCENE_NAME);
	}

	_onContainerResize() {
		for (let i of [1, 20, 40, 80, 200, 500, 1000, 1500, 2000, 3000]) {
			window.setTimeout(this.onResize, i);
		}
	}

	get isAllButtonsDisabled() {
		return !!currentFader;
	}

	/// #if EDITOR
	get __enforcedOrientation() {
		return this.___enforcedOrientation;
	}

	set __enforcedOrientation(v) {

		assert(!v || v === 'landscape' || v === 'portrait', 'Wrong value for game.__enforcedOrientation. "landscape" or "portrait" expected');
		this.___enforcedOrientation = v;
		game.editor.settingsLocal.setItem('__EDITOR_is-portrait-orientation', v === 'portrait');

		if (v === 'portrait') {
			if (!game.isMobile.any) {
				game.isMobile.any = true;
				game.editor._processIsMobileHandlers();
			}
		} else {
			const isMobileRestore = game.editor.settings.getItem('isMobile.any', game.isMobile.any);
			if (game.isMobile.any != isMobileRestore) {
				game.isMobile.any = isMobileRestore;
				game.editor._processIsMobileHandlers();
			}
		}

		this.onResize();
	}
	/// #endif

	addAssets(data: AssetsDescriptor) {
		/// #if EDITOR
		assert(false, 'game.addAssets method for runtime only, but called in editor.');
		/// #endif
		if (data.projectDesc) {
			game.applyProjectDesc(data.projectDesc);
		}
		game.emit('assets-will-add', data); // 99999
		Lib.addAssets(data);
	}

	applyProjectDesc(projectDescriptor: ProjectDesc) {

		assert(!this.projectDesc, 'game.projectDesc already defined');

		/// #if DEBUG
		let so = projectDescriptor.screenOrientation;
		assert(so === 'auto' || so === 'landscape' || so === 'portrait', 'Wrong value for "screenOrientation". "auto", "landscape" or "portrait" expected', 30010);
		/// #endif

		BaseTexture.defaultOptions.mipmap = projectDescriptor.mipmap
			? MIPMAP_MODES.ON
			: MIPMAP_MODES.OFF;

		TextureGCSystem.defaultMode = GC_MODES.MANUAL;

		this.projectDesc = projectDescriptor;
		/// #if EDITOR
		/*
		/// #endif
		if(game.projectDesc.defaultFont) {
			document.body.style.fontFamily = game.projectDesc.defaultFont;
		}
		//*/
	}

	onResize() {
		if (!this.pixiApp) {
			return;
		}
		let w, h;
		if (this.pixiApp.view.parentNode === document.body) {
			w = window.innerWidth;
			h = window.innerHeight;
		} else {
			w = (this.pixiApp.view.parentNode as HTMLDivElement).clientWidth;
			h = (this.pixiApp.view.parentNode as HTMLDivElement).clientHeight;
		}

		const bodyW = w;
		const bodyH = h;

		//let debugInfo = 'w: ' + w + '; h: ' + h;

		let dynamicStageSize = game.projectDesc.dynamicStageSize;

		let orientation;
		/// #if EDITOR

		if (this.__fixedViewport) {
			if (this.__fixedViewport === true) {
				let size = this.editor._getProjectViewportSize(false);
				w = size.w;
				h = size.h;
			} else {
				if (game.isPortrait) {
					w = this.__fixedViewport.h;
					h = this.__fixedViewport.w;
				} else {
					w = this.__fixedViewport.w;
					h = this.__fixedViewport.h;
				}
			}
		}

		if (this.__enforcedW) {
			w = this.__enforcedW;
		}
		if (this.__enforcedH) {
			h = this.__enforcedH;
		}


		if ((this.projectDesc.screenOrientation === 'auto')) {
			orientation = this.__enforcedOrientation;
		} else {
			/// #endif
			orientation = this.projectDesc.screenOrientation;
			/// #if EDITOR
		}

		if (dynamicStageSize) {
			if (orientation === 'portrait') {
				if (w > h * 0.9) {
					w = Math.round(h * 0.9);
				}
			} else {
				if (h > w * 0.9) {
					h = Math.round(w * 0.9);
				}
			}
		}
		/// #endif

		if (orientation === 'auto') {
			orientation = ((w < h) && game.isMobile.any) ? 'portrait' : 'landscape';
		}

		let rotateCanvas = false;

		switch (orientation) {
		case 'portrait':
			rotateCanvas = w > h;
			game.isPortrait = true;
			break;
		default: //landscape
			rotateCanvas = h > w;
			game.isPortrait = false;
			break;
		}

		this.isLandscapeMobile = !this.isPortrait && this.isMobile.any;

		if (!this.isMobile.any // eslint-disable-line no-constant-condition
			/// #if EDITOR
			|| true
			/// #endif
		) { //rotate canvas for fixed orientation projects on mobile only
			rotateCanvas = false;
		}

		if (game.isPortrait) {
			/** game screen current width */
			this.W = this.projectDesc.portraitWidth;
			/** game screen current height */
			this.H = this.projectDesc.portraitHeight;
		} else {
			this.W = this.projectDesc.width;
			this.H = this.projectDesc.height;
		}


		if (!dynamicStageSize) {
			if (game.projectDesc.preventUpscale // eslint-disable-line no-constant-condition
				/// #if EDITOR
				|| true
				/// #endif
			) {
				if (rotateCanvas) {
					w = Math.min(this.H, w);
					h = Math.min(this.W, h);
				} else {
					w = Math.min(this.W, w);
					h = Math.min(this.H, h);
				}
			}
		}

		let S;
		if (rotateCanvas) {
			S = Math.min(h / this.W, w / this.H);
		} else {
			S = Math.min(w / this.W, h / this.H);
		}

		if (dynamicStageSize) {
			if (game.projectDesc.preventUpscale) {
				if (S < 1) {
					w = w / S;
					h = h / S;
				}
				S = 1;
			} else {
				w = w / S;
				h = h / S;
			}
		}

		let s = 1;
		if (this.isMobile.any // eslint-disable-line no-constant-condition
			/// #if EDITOR
			&& false
			/// #endif
		) {
			if (game.projectDesc.renderResolutionMobile) {
				s = game.projectDesc.renderResolutionMobile;
			}
		} else {
			if (game.projectDesc.renderResolution) {
				s = game.projectDesc.renderResolution;
			}
		}
		s = Math.max(window.devicePixelRatio || 1, s);
		S *= s;
		S = Math.min(3, S);
		/// #if EDITOR
		if (!document.fullscreenElement) {
			S = 1;
		}
		if (this.editor.buildProjectAndExit) {
			S = 1 / 16;
		}
		/// #endif

		if (this.pixiApp && this.pixiApp.renderer) {
			let gl = (this.pixiApp.renderer as any).gl as WebGL2RenderingContext;
			let maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
			if (maxTextureSize < 3000) {
				S = Math.min(1, S);
			}

			if (w * S > maxTextureSize) {
				S = maxTextureSize / w;
			}
			if (h * S > maxTextureSize) {
				S = maxTextureSize / h;
			}
		}

		if (dynamicStageSize) {
			if (rotateCanvas) {
				this.H = w;
				this.W = h;
			} else {
				this.W = w;
				this.H = h;
			}
		}

		let rendererWidth, rendererHeight;
		if (rotateCanvas) {
			rendererWidth = this.H;
			rendererHeight = this.W;
		} else {
			rendererWidth = this.W;
			rendererHeight = this.H;
		}

		this.W = Math.round(this.W);
		this.H = Math.round(this.H);

		if (this.W & 1) { //make even game logical size only. Keep canvas fit to client
			this.W++;
		}
		if (this.H & 1) {
			this.H++;
		}

		rendererWidth = Math.floor(rendererWidth += 0.0001);
		rendererHeight = Math.floor(rendererHeight += 0.0001);

		let needResizeRenderer = (_rendererWidth !== rendererWidth) || (_rendererHeight !== rendererHeight) || (scale !== S);

		//PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

		_rendererWidth = rendererWidth;
		_rendererHeight = rendererHeight;
		scale = S;


		let stage = game.stage;

		game._isCanvasRotated = rotateCanvas;

		if (rotateCanvas) {
			stage.rotation = Math.PI / 2.0;
			stage.x = this.H;
		} else {
			stage.rotation = 0;
			/// #if EDITOR
			/*
			/// #endif
			stage.x = 0;
			//*/
		}

		if (needResizeRenderer) {

			/// #if EDITOR
			if (!this.__enforcedW) {
				/// #endif
				let renderer = game.pixiApp.renderer;

				renderer.resolution = scale;
				renderer.resize(_rendererWidth, _rendererHeight); //prevent canvas size decreasing by pixel because of Math.ceil
				/// #if EDITOR
			}
			/// #endif
			this.emit('stage-will-resize');
			this.forAllChildrenEverywhere(processOnResize);
			/// #if EDITOR
			if (!this.__enforcedW) {
				this.editor.onEditorRenderResize();
			}
			/// #endif
		}

		const isWide = (bodyW / _rendererWidth) >= (bodyH / _rendererHeight);
		const c = this.pixiApp.view as HTMLCanvasElement;
		const w2 = isWide ? Math.round(bodyH * _rendererWidth / _rendererHeight) : bodyW;
		const h2 = isWide ? bodyH : Math.round(bodyW * _rendererHeight / _rendererWidth);
		c.style.width = w2 + 'px';
		c.style.height = h2 + 'px';
		/// #if EDITOR
		/*
		/// #endif
		c.style.left = Math.round((bodyW - w2) / 2) + 'px';
		c.style.top = Math.round((bodyH - h2) / 2) + 'px';
		//*/

		assert(_rendererWidth, 'Render\'s size was not calculated correctly.');
		assert(_rendererHeight, 'Render\'s size was not calculated correctly.');

		/// #if EDITOR
		game.editor.ui.viewport.viewportScale = game.pixiApp.view.width / (game.pixiApp.view as HTMLCanvasElement).clientWidth;
		/// #endif
	}

	/// #if EDITOR
	___enforcedOrientation: ProjectOrientation | undefined;

	__enforcedW: number | undefined;
	__enforcedH: number | undefined;

	__fixedViewport?: FixedViewportSize;
	__setFixedViewport(fixedViewport: FixedViewportSize) {
		this.__fixedViewport = fixedViewport;
		this.onResize();
	}
	/// #endif

	forAllChildrenEverywhere(callback: (o: Container) => void) {
		if (game.stage && game.stage.forAllChildren) {
			game.stage.forAllChildren(callback);
		}
		game.forAllChildrenEverywhereBack(callback);
	}

	forAllChildrenEverywhereBack(callback: (o: Container) => void) {
		for (let s of scenesStack) {
			if (typeof s !== 'string') {
				callback(s);
				if (!s.parent) {
					callback(s);
					s.forAllChildren(callback);
				}
			}
		}

		const staticScenes = Lib._getStaticScenes();
		for (let n in staticScenes) {
			let s = staticScenes[n];
			if (!s.parent) {
				callback(s);
				s.forAllChildren(callback);
			}
		}
	}

	get currentContainer(): Container {
		if (modals.length > 0) {
			return modals[modals.length - 1]; //top modal is active
		}
		return this.currentScene; //current scene is active if no modals on screen
	}

	/// #if EDITOR
	get currentScene() {
		return __currentSceneValue as CurrentSceneType | Scene;
	}
	/*
	/// #endif
	currentScene!:Scene;
	//*/

	_updateGlobal(dt: number) {
		/// #if DEBUG
		this._FPS++;
		let now = Date.now();
		if ((now - lastFPSTime) >= 1000) {
			this.FPS = this._FPS;
			this._FPS = 0;
			lastFPSTime = now;
		}
		/// #endif

		/// #if EDITOR
		EDITOR_FLAGS.__touchTime = (game.pixiApp.renderer as any).textureGC.count as number;
		EDITOR_FLAGS.updateInProgress = true;
		/// #endif

		if ((!this.__paused || this.__doOneStep)
			/// #if EDITOR
			&& !this.__EDITOR_mode
			/// #endif
		) {

			this.emit('global-update');//99999

			dt = Math.min(dt, FRAME_PERIOD_LIMIT);
			/// #if EDITOR
			dt = Math.min(dt, 1);
			/// #endif

			frameCounterTime += dt;
			frameCounterTime = Math.min(frameCounterTime, FRAME_PERIOD * game.projectDesc.framesSkipLimit);
			while (frameCounterTime > FRAME_PERIOD) {

				/// #if DEBUG
				frameCounterTime -= FRAME_PERIOD / game.pixiApp.ticker.speed;
				/*
				/// #endif
				frameCounterTime -= FRAME_PERIOD;
				//*/

				game.isUpdateBeforeRender = !(frameCounterTime > FRAME_PERIOD);
				this._updateFrame();

				if (this.__doOneStep) {
					/// #if EDITOR
					this.editor.refreshTreeViewAndPropertyEditor();
					/// #endif
					this.__doOneStep = false;
					frameCounterTime = 0;
					break;
				}
			}
		}

		if (this.currentScene) {
			app.renderer.background.backgroundColor.setValue(this.currentScene.backgroundColor);

			this.currentScene.interactiveChildren = ((modals.length === 0) && !currentFader);
			let i = modals.length - 1;
			let isCurrent = !currentFader;
			while (i >= 0) {
				modals[i].interactiveChildren = isCurrent;
				isCurrent = false;
				i--;
			}
		}

		/// #if EDITOR
		EDITOR_FLAGS.updateInProgress = false;
		/// #endif

	}

	_updateFrame() {
		if (game._loadingErrorIsDisplayed) {
			return;
		}
		this.frameSeed = Math.floor(Math.random() * 0x80000000);

		/// #if EDITOR
		this.__time++;

		if (!game.__EDITOR_mode && this.currentScene && this.currentScene.name === 'preloader') {
			this.loadingProgress = Math.round(Math.min(100, game.time / 3));
		}

		/*
		/// #endif
		this.time++;
		//*/

		if ((this.pixiApp.renderer as any).gl.isContextLost()) {
			if (game.isVisible) {
				contextLoseTime++;
				if (contextLoseTime === 60) {
					game._reloadGame();
				}
			}
			return;
		}
		contextLoseTime = 0;

		this.emit('update'); //99999

		if (game._isWaitingToHideFader) {
			if (game.loadingsFinished === game.loadingsInProgress) {
				game._processScenesStack();
				if (!game.currentScene._onShowCalled) {
					game.currentScene._onShowCalled = true;
					game.currentScene.onShow();
					game.currentScene.emit('on-scene-show');
					loadDynamicTextures();
					if (game.currentScene.name === PRELOADER_SCENE_NAME) {
						game._hideCurrentFaderAndStartScene();
						/// #if EDITOR
						/*
						/// #endif
						this.loadingAdd('assets-main load');
						import('.tmp/assets-main', {assert: { type: 'json' }}).then((mainAssets: AssetsDescriptor) => {
							this.loadingRemove('assets-main load');
							game.addAssets(mainAssets.default);
						}).catch((er) => {
							console.error(er);
							game.showLoadingError('assets-main.json');
						});
						//*/
					}
				} else {
					game._hideCurrentFaderAndStartScene();
				}
			}
			if (this.currentContainer && (this.currentContainer !== this.currentScene)) {
				this.currentContainer.update();
			}
		} else if (this.currentContainer) {
			if (!currentFader || (this.currentContainer !== this.currentScene) || (hidingModals.length < 1)) {
				this.currentContainer.update();
			}
		}

		if (currentFader) {
			/// #if EDITOR
			__isCurrentFaderUpdateInProgress = true;
			/// #endif
			currentFader.update();
			/// #if EDITOR
			__isCurrentFaderUpdateInProgress = false;
			/// #endif
		}
		let fi = hidingFaders.length - 1;
		while (fi >= 0) {
			let fader = hidingFaders[fi];
			currentHidingFaderInUpdate = fader;
			fader.update();
			fi--;
		}
		if (!currentFader) {
			let i = hidingModals.length - 1; //hide modals process
			while (i >= 0) {
				let m = hidingModals[i];
				m.alpha -= 0.1;
				if (m.alpha <= 0.01) {
					Lib.destroyObjectAndChildren(m);
					hidingModals.splice(i, 1);
					/// #if EDITOR
					game.editor.refreshTreeViewAndPropertyEditor();
					/// #endif
				}
				i--;
			}
		}
		this.keys.update();
		this.emit('updated');//99999
		Lib._cleanupRemoveHolders();
	}

	get currentFader() {
		return currentFader;
	}

	_hideCurrentFaderAndStartScene() {
		(currentFader as Container).gotoLabelRecursive('hide fader');
		hidingFaders.unshift(currentFader as Container);
		/// #if EDITOR
		this.editor.refreshTreeViewAndPropertyEditor();
		/// #endif
		currentFader = undefined;
		game.classes?.BgMusic?._recalculateMusic();
		game._isWaitingToHideFader = false;
	}

	_processScenesStack() {
		assert(game.loadingsFinished === game.loadingsInProgress, 'Attempt to change stack during loading');
		while (true) { // eslint-disable-line no-constant-condition
			let topStackElement = scenesStack[scenesStack.length - 1] as Scene;
			if (topStackElement === game.currentScene) {
				break;
			}
			if (game.currentScene) {
				if (game.currentScene._onShowCalled) {
					game.currentScene.onHide();
				}
				tryToRemoveCurrentScene();
			}
			topStackElement = scenesStack[scenesStack.length - 1] as Scene;
			scenesStack[scenesStack.length - 1] = game._setCurrentSceneContent(topStackElement);
		}
	}

	_reloadGame() {
		if (game.onGameReload) {
			game.onGameReload();
		}
		if (Lib.hasPrefab('final-fader')) {
			game.showModal('final-fader');
		}
		window.location.reload();
	}

	showScene(scene: Scene | string, faderType?: string) {
		/// #if EDITOR
		checkSceneName(scene);
		/// #endif
		scenesStack.push(scene);
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			scenesStack = [scene];
		}
		/// #endif
		game._startFaderIfNeed(faderType);
	}

	loadingAdd(owner: any) {
		/// #if DEBUG
		assert(owner, 'game.loadingAdd: wrong loading owner.');
		loadingsInProgressOwners.add(owner);
		/// #endif

		if (this.loadingsFinished === this.loadingsInProgress) {
			this.loadingsInProgress = 0;
			this.loadingsFinished = 0;
		}
		this.loadingsInProgress++;

		this._refreshLoadingProgress();
	}

	private _refreshLoadingProgress() {
		this.loadingProgress = this.loadingsInProgress ? Math.floor(this.loadingsFinished / this.loadingsInProgress * 100) : 0;
		assert(this.loadingProgress >= 0 && this.loadingProgress <= 100, 'game.loadingProgress out of range 0-100.');
	}

	loadingRemove(owner: any) {

		/// #if DEBUG
		assert(loadingsInProgressOwners.has(owner), 'game.loadingRemove: wrong loading owner.');
		loadingsInProgressOwners.delete(owner);
		/// #endif

		this.loadingsFinished++;
		this._refreshLoadingProgress();
	}

	replaceScene(scene: Scene | string, faderType?: string) {

		if (!scene) {
			scene = game.projectDesc.mainScene;
		}

		/// #if EDITOR
		checkSceneName(scene);
		/// #endif


		assert(scenesStack.length > 0, 'Can not replace scene. No scene to replace is present.');

		tryToRemoveScene(scenesStack.pop() as Scene);
		scenesStack.push(scene);
		game._startFaderIfNeed(faderType);
	}

	_startFaderIfNeed(faderType?: string) {
		if (scenesStack[scenesStack.length - 1] !== game.currentScene) {
			/// #if EDITOR
			if (game.__EDITOR_mode) {
				let i = scenesStack.length - 1;
				this.__destroyCurrentScene();
				let s = this._setCurrentSceneContent(scenesStack[i] as Scene);
				scenesStack[i] = s;
				return;
			}
			/// #endif
			hideTheseModalsUnderFader = modals.slice();
			if (!currentFader) {
				assert(!game._isWaitingToHideFader, '_isWaitingToHideFader is true when no currentFader exists.');
				if (!faderType) {
					if (this.currentScene && this.currentScene.faderType) {
						faderType = this.currentScene.faderType;
					} else {
						faderType = DEFAULT_FADER_NAME;
					}
				}
				currentFader = Lib.loadPrefab(faderType!);
				this.stage.addChild(currentFader);
				game.classes?.BgMusic?._recalculateMusic();
			}
			/// #if EDITOR
			this.editor.refreshTreeViewAndPropertyEditor();
			/// #endif
		}
	}

	closeCurrentScene(faderType?: string) {
		/// #if EDITOR
		if (scenesStack.length <= 1) {
			game.editor.ui.modal.notify('It is no other scene in stack to close current scene.');
			return;
		}
		/// #endif
		assert(scenesStack.length > 1, 'Can\'t close latest scene', 10035);
		tryToRemoveScene(scenesStack.pop() as Scene);
		game._startFaderIfNeed(faderType);
	}

	closeAllScenes(faderType?: string) {
		while (scenesStack.length > 1) {
			game.closeCurrentScene(faderType);
		}
	}

	showQuestion(title: string, message: string, yesLabel?: string, onYes?: () => void, noLabel?: string, onNo?: () => void, easyClose = true, prefab = 'ui/sure-question') {
		let o = Lib.loadPrefab(prefab);
		sureQuestionInit(o, title, message, yesLabel, onYes, noLabel, onNo, easyClose);
		return game.showModal(o);
	}

	showModal(container: Container | string, callback?: () => void
		/// #if EDITOR
		, __noAssertEditorMode = false
		/// #endif
	) {
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			assert(__noAssertEditorMode, 'Attempt to show modal in editor mode: ' + ((container as any).name || container), 10047);
		}
		/// #endif
		if (typeof container === 'string') {
			container = Lib.loadPrefab(container);
		}
		assert(container instanceof Container, 'Attempt to show not DisplayObject as modal');
		assert(!(container instanceof Scene), 'Scene can not be used as modal', 10037);
		modals.push(container);

		if (callback) {
			const promise = SceneLinkedPromise.promise(() => { /*empty*/ }, container);
			promise.name = 'modal-promise-awaiter';
			promise.then(callback);
		}

		container.interactiveChildren = false;
		game.stage.addChild(container);
		game.classes?.BgMusic?._recalculateMusic();
		/// #if EDITOR
		game.editor.refreshTreeViewAndPropertyEditor();
		/// #endif
		game.emit('modal-shown');
		return container;
	}

	hideModal(container?: Container, instantly = false) {
		let modalToHide: Container;
		if (!container) {
			assert(modals.length > 0, 'Attempt to hide modal when modal list is empty.', 10038);
			modalToHide = modals.pop()!;
		} else {
			let i = modals.indexOf(container);
			assert(i >= 0, 'Attempt to hide modal object which is not in modal list.', 10039);
			modalToHide = container;
			modals.splice(i, 1);
		}

		const promise = modalToHide.getChildByName('modal-promise-awaiter') as SceneLinkedPromise;
		if (promise
			/// #if EDITOR
			&& !game.__EDITOR_mode
			/// #endif
		) {
			promise.resolve(modalToHide);
			promise.update();
		}

		if (instantly
			/// #if EDITOR
			||
			game.__EDITOR_mode
			/// #endif
		) {
			Lib.destroyObjectAndChildren(modalToHide);
		} else {
			modalToHide.interactiveChildren = false;
			hidingModals.push(modalToHide);
		}
		game.classes?.BgMusic?._recalculateMusic();

		/// #if EDITOR
		game.editor.refreshTreeViewAndPropertyEditor();
		/// #endif
	}

	__togglePause() {
		game.__paused = !game.__paused;
	}

	__oneStep() {
		game.__doOneStep = true;
	}

	/** call when fader covered the stage */
	faderShoot() {
		/// #if EDITOR
		assert(__isCurrentFaderUpdateInProgress, 'faderShoot() called not by fader.', 10033);
		assert(!(currentFader as Container).__nodeExtendData.isFaderShootCalledForThisFader, 'faderShoot() already called for this fader.', 10034);
		(currentFader as Container).__nodeExtendData.isFaderShootCalledForThisFader = true;
		/// #endif
		while (hideTheseModalsUnderFader.length > 0) {
			let m = hideTheseModalsUnderFader.pop() as Container;
			let i = modals.indexOf(m);
			if (i >= 0) {
				modals.splice(i, 1);
				Lib.destroyObjectAndChildren(m);
			}
		}
		while (hidingModals.length > 0) {
			let m = hidingModals.pop();
			Lib.destroyObjectAndChildren(m as Container);
		}
		game._isWaitingToHideFader = true;
	}

	faderEnd() {
		if (currentHidingFaderInUpdate) {
			let i = hidingFaders.indexOf(currentHidingFaderInUpdate);
			assert(i >= 0, 'hidingFaders list is corrupted');
			hidingFaders.splice(i, 1);
			Lib.destroyObjectAndChildren(currentHidingFaderInUpdate);
			currentHidingFaderInUpdate = null;
			/// #if EDITOR
			game.editor.refreshTreeViewAndPropertyEditor();
			/// #endif
		}
	}

	openUrl(url: string, target = '_blank') {
		addOnClickOnce(() => {
			window.open(url, target);
		});
	}

	showLoadingError(url: string) {
		/// #if DEBUG
		debugger;
		/// #endif
		/// #if EDITOR
		if (this.editor.buildProjectAndExit) {
			fs.exitWithResult(undefined, 'loading error: ' + url);
		}
		/// #endif

		if (game._loadingErrorIsDisplayed) {
			return;
		}
		game._loadingErrorIsDisplayed = true;
		game.classes?.BgMusic?._recalculateMusic();
		/// #if EDITOR
		this.editor.ui.modal.showError('Could not load file: ' + url);
		return;
		/// #endif

		let e = document.createElement('div');// eslint-disable-line no-unreachable

		e.innerHTML = ERROR_HTML.replace('$TITLE$', game.projectDesc.title
		/// #if DEBUG
			+ '<br>' + (url || '').replace(/\n/gm, '<br>')
		/// #endif
		);
		document.body.appendChild(e);
		document.addEventListener('click', () => {
			game._reloadGame();
		});
	}

	_setCurrentScene(scene: Scene | null) {
		//DODO: cleanup
		if (scene) {
			game.all = scene.all;
		} else {
			game.all = null as any;
		}
		/// #if EDITOR
		__currentSceneValue = scene as Scene;
		return;
		/*
		/// #endif
		game.currentScene = scene;
		//*/
	}

	_setCurrentSceneContent(scene: Scene) {
		//DODO: cleanup
		assert(!game.currentScene, 'Attempt to set current scene content with previous scene exists.');

		/// #if EDITOR
		const isFirstSceneShow = !__currentSceneValue;
		/// #endif

		scene = checkScene(scene);

		this._setCurrentScene(scene);
		scene.interactiveChildren = false;
		stage.addChildAt(scene, 0);
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			loadDynamicTextures();
		} else {
			if (isFirstSceneShow) {
				this.editor.selection.loadCurrentSelection();
			}
		}
		game.currentScene.__nodeExtendData.childrenExpanded = true;
		this.editor.refreshTreeViewAndPropertyEditor();

		this.editor.ui.viewport.resetZoom();

		/// #endif
		scene._onShowCalled = false;
		return scene;
	}

	__doOneStep = false;
	__paused = false;
	/// #if DEBUG
	protected _FPS = 0;
	FPS = 0;
	/// #endif

	_getScenesStack() {
		return scenesStack;
	}

	applyCSS(css: string) {
		let head = document.head || document.getElementsByTagName('head')[0];
		let style = document.createElement('style');
		style.appendChild(document.createTextNode(css));
		head.appendChild(style);
	}

	/// #if EDITOR
	__EDITOR_filterPropsSelection (propertyName:string) {
		return FILTERED_PROPS.has(propertyName);
	}

	__setCurrentContainerContent(o: Container) {
		assert(game.__EDITOR_mode, 'attempt to replace current container content in running mode');
		if (modals.length > 0) {
			this.hideModal();
			this.showModal(o, undefined, true);
		} else {
			if (!o.name) {
				(o as Scene).name = game.currentScene.name;
			}
			this.showScene(o as Scene);
		}
	}

	__destroyCurrentScene() {
		//DODO: cleanup
		if (this.currentScene) {
			Lib.destroyObjectAndChildren(this.currentScene);
			this._setCurrentScene(null);
		}
	}

	get __modalsCount() {
		return modals.length;
	}

	__clearStage() {
		while (this.__modalsCount > 0) {
			this.hideModal(undefined, true);
		}
		while (hidingModals.length > 0) {
			let m = hidingModals.pop();
			Lib.destroyObjectAndChildren(m as Container);
		}

		while (scenesStack.length > 0) {
			tryToRemoveScene(scenesStack.pop() as Scene);
		}

		tryToRemoveCurrentScene();

		if (currentFader) {
			Lib.destroyObjectAndChildren(currentFader);
			currentFader = undefined;
		}
		game._isWaitingToHideFader = false;
		while (hidingFaders.length > 0) {
			Lib.destroyObjectAndChildren(hidingFaders.pop() as Container);
		}
		Lib.__clearStaticScenes();
		game.classes?.BgMusic?._recalculateMusic();
	}

	/// #endif

	/// #if DEBUG
	_reanimateTicker() {
		requestAnimationFrame((game.pixiApp.ticker as any)._tick);
	}

	__showDebugError(txt: string, errorCode = 90000) {
		/// #if EDITOR
		this.editor.ui.modal.showError(txt, errorCode);
		return;
		/// #endif
		alert(txt); // eslint-disable-line no-unreachable
	}
	/// #endif
}

const loadedFonts = new Set() as Set<string>;
let fontHolder: HTMLSpanElement;
function loadFonts() {
	if (game.projectDesc.webfontloader?.custom?.families?.length || game.projectDesc.webfontloader?.google?.families?.length) {
		game.loadingAdd('FontsLoading');
		if (game.projectDesc.fontHolderText) {
			if (!fontHolder) {
				fontHolder = document.createElement('span');
				fontHolder.style.opacity = '0';
				fontHolder.style.userSelect = 'none';
				fontHolder.style.color = 'rgba(0,0,0,0.01)';
				fontHolder.style.position = 'absolute';
				fontHolder.style.zIndex = '-1';
			}

			for (let fontsProviderName in game.projectDesc.webfontloader) {
				let families = (game.projectDesc.webfontloader as KeyedObject)[fontsProviderName].families;
				if (families) {
					for (let family of families) {
						if (!loadedFonts.has(family)) {
							loadedFonts.add(family);
							if (fontsProviderName === 'custom') {

								family = family.replace(/ /g, '');
								let fontPath = 'fonts/' + family.replace(/ /g, '') + '.woff';
								let fontPath2 = fontPath + '2';

								/// #if EDITOR
								fontPath = fs.getFileByAssetName(fontPath, AssetType.FONT).fileName;
								fontPath2 = fs.getFileByAssetName(fontPath2, AssetType.FONT).fileName;
								/*
								/// #endif
								fontPath = Lib.fonts[fontPath];
								fontPath2 = Lib.fonts[fontPath2];
								//*/
								game.applyCSS(`
@font-face {
	font-family: '` + family + `';
	src: url('` + fontPath2 + `') format('woff2'),
	url('` + fontPath + `') format('woff');
}
									`);
							} else if (fontsProviderName === 'google') {
								const link = document.createElement('link');
								link.rel = 'stylesheet';
								link.type = 'text/css';
								link.href = 'https://fonts.googleapis.com/css?family=' + family;
								document.head.appendChild(link);
							}

							let a = family.split(':');
							let fontName = a[0];
							let weights = a[1] ? a[1].split(',') : ['normal'];

							for (let w of weights) {
								let span = document.createElement('span');
								span.style.fontFamily = `"${fontName}"`;
								span.style.fontWeight = w;
								span.style.position = 'absolute';
								span.innerHTML = game.projectDesc.fontHolderText;
								fontHolder.appendChild(span);
							}
						}
					}
				}
			}
			document.body.appendChild(fontHolder);
		}

		document.fonts.ready.then(() => {
			game.loadingRemove('FontsLoading');
		});
	}
}

function tryToRemoveCurrentScene() {
	let s = game.currentScene;
	game._setCurrentScene(null);
	tryToRemoveScene(s);
}

function tryToRemoveScene(s: Scene) {


	if ((s instanceof Scene) && (s !== game.currentScene)) {
		/// #if EDITOR
		if (s.__nodeExtendData.isSelected) {
			game.editor.selection.remove(s);
			game.editor.refreshTreeViewAndPropertyEditor();
		}
		/// #endif

		if (!s.isStatic && (scenesStack.indexOf(s) < 0)) {
			Lib.destroyObjectAndChildren(s);
		} else {
			s.detachFromParent();
		}
	}
}

function checkScene(scene: Scene | string) {
	if (typeof scene === 'string') {
		scene = Lib.loadScene(scene);
	}
	assert(scene instanceof Scene, 'Scene instance expected.');
	assert(scene.name, 'Scene name is empty.');
	return scene;
}

/// #if EDITOR
function checkSceneName(sceneName: string | Scene) {
	if (typeof sceneName === 'string') {
		assert(Lib.hasScene(sceneName), 'No scene with name \'' + sceneName + '\'', 10046);
	} else {
		assert(sceneName instanceof Scene, 'Scene expected.');
	}
}
let __isCurrentFaderUpdateInProgress = false;
let __currentSceneValue: Scene;

/// #endif

const game = new Game();
export default game;
export { DEFAULT_FADER_NAME, loadFonts, PRELOADER_SCENE_NAME, processOnResize };
export type { FixedViewportSize };

/// #if EDITOR

(window as any).game = game;

(Game.prototype.forAllChildrenEverywhereBack as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Game.prototype.forAllChildrenEverywhere as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Game.prototype.init as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Game.prototype.applyProjectDesc as SelectableProperty).___EDITOR_isHiddenForChooser = true;

(Game.prototype.closeAllScenes as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.closeAllScenes as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.loadingAdd as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.loadingRemove as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.showLoadingError as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.applyCSS as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;

(Game.prototype.closeCurrentScene as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.closeCurrentScene as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.faderEnd as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.faderEnd as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.faderShoot as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.faderShoot as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(FullScreen as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.hideModal as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.hideModal as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(game.isMobile as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Keys as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.openUrl as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.replaceScene as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.showModal as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.showModal as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.showQuestion as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.showQuestion as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Game.prototype.showScene as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Game.prototype.showScene as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
Object.defineProperty(game.openUrl, '___EDITOR_isHiddenForChooser', ButtonOnlyPropertyDesc);

(Game.prototype.showModal as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return game.editor.choosePrefab('Choose prefab to show as modal:');
};
(Game.prototype.showScene as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return game.editor.chooseScene('Choose scene to open:');
};
(Game.prototype.replaceScene as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return game.editor.chooseScene('Choose scene which will replace current scene:');
};

(Game.prototype.showQuestion as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return new Promise((resolve) => {
		game.editor.ui.modal.showPrompt('Enter title to show', 'Question Title', undefined, game.editor.validateCallbackParameter).then((enteredTitle) => {
			if (enteredTitle) {
				game.editor.ui.modal.showPrompt('Enter message to show', 'Question text', undefined, game.editor.validateCallbackParameter, undefined, true).then((enteredText) => {
					if (enteredText) {
						resolve([enteredTitle, enteredText]);
					}
				});
			}
		});
	});
};


/// #endif

document.addEventListener('visibilitychange', () => visibilityChangeHandler());
window.addEventListener('focus', () => focusChangeHandler(true));
window.addEventListener('blur', () => focusChangeHandler(false));

const focusChangeHandler = (focused: boolean) => {
	if (game.isFocused !== focused) {
		game.isFocused = focused;

		if (game.pixiApp) {
			window.setTimeout(() => {
				game.keys.resetAll();
			}, 10);
		}
	}
};

const visibilityChangeHandler = () => {
	const isVisible = document.visibilityState === 'visible';

	if (game.isVisible !== isVisible) {
		game.isVisible = isVisible;

		if (game.pixiApp) {
			Sound._onVisibilityChange(isVisible);
		}
		focusChangeHandler(isVisible);
	}
};
focusChangeHandler(true);
visibilityChangeHandler();

let pauseRuntimeHotKeysInitialized = false;
export function __pauseRuntimeHotKeysInit() { // 99999
	/// #if EDITOR
	return;
	/// #endif
	if (pauseRuntimeHotKeysInitialized) {
		return;
	}
	pauseRuntimeHotKeysInitialized = true;
	window.addEventListener('keydown', (ev) => {
		if (ev.keyCode === 80 && (ev.ctrlKey || ev.metaKey)) {
			game.__togglePause();
			ev.preventDefault();
		} else if (ev.keyCode === 219 && (ev.ctrlKey || ev.metaKey)) {
			game.__oneStep();
			ev.preventDefault();
		}
	});
}

/// #if DEBUG
__pauseRuntimeHotKeysInit();
/// #endif
</file>

<file path="src/engine/HowlSound.ts">
export const rootAudioContext = new AudioContext();


import game from 'thing-editor/src/engine/game';
import EDITOR_FLAGS from '../editor/utils/flags';

const volumeNodes = new Map<number, GainNode>();

export default class HowlSound {

	/// #if DEBUG
	__isEmptySound = false;
	/// #endif

	audioBuffer!: AudioBuffer;
	source?: AudioBufferSourceNode;
	volumeNode?: GainNode;
	src: string;

	attempt = 0;

	constructor(src: string) {
		this.src = src;
		this.onEnded = this.onEnded.bind(this);
		/// #if EDITOR
		if (game.editor?.buildProjectAndExit) {
			return;
		}
		/// #endif
		this.load();
	}

	load () {
		game.loadingAdd(this);
		fetch(this.src)
			.then(res => res.arrayBuffer())
			.then((buff) => {
				rootAudioContext.decodeAudioData(buff).then((audioBuffer) => {
					this.audioBuffer = audioBuffer;
					/// #if EDITOR
					if (!this.preciseDuration) {
						this.preciseDuration = audioBuffer.duration;
					}
					/// #endif
					game.loadingRemove(this);
				}).catch(() => {
					game.loadingRemove(this);
				});
			}).catch(() => {
				if (this.attempt < 3 && !game._loadingErrorIsDisplayed) {
					this.attempt++;
					window.setTimeout(() => {
						this.load();
					}, this.attempt * 1000);
				}
				game.loadingRemove(this);
			});
	}

	stop() {
		if (this.source) {
			this.source.stop();
			this.source.disconnect();
			this.source = undefined;
		}
	}

	onEnded() {
		this.source?.removeEventListener('ended', this.onEnded);
		this.source = undefined;
	}

	play(volume = 1, rate = 1, seek = 0) {
		if (volume < 0.001 || !this.audioBuffer) {
			return;
		}
		if (this.source) {
			this.source.removeEventListener('ended', this.onEnded);
		}
		this.source = rootAudioContext.createBufferSource();
		this.source.addEventListener('ended', this.onEnded);
		this.source.buffer = this.audioBuffer;

		/// #if EDITOR
		this.__lastTouch = EDITOR_FLAGS.__touchTime;
		/// #endif

		if (volume !== 1) {
			volume = Math.round(volume * 1000) / 1000;
			if (!volumeNodes.has(volume)) {
				const volumeNode = rootAudioContext.createGain();
				volumeNode.connect(game.Sound.outputs.FX);
				volumeNode.gain.setValueAtTime(volume, rootAudioContext.currentTime);
				volumeNodes.set(volume, volumeNode);
			}
			this.source.connect(volumeNodes.get(volume)!);
		} else {
			this.source.connect(game.Sound.outputs.FX);
		}
		if (this.source.playbackRate.value !== rate) {
			this.source.playbackRate.setValueAtTime(volume, rootAudioContext.currentTime);
		}
		this.source.start(0, seek);
	}

	/// #if EDITOR
	__lastTouch = 0;
	/// #endif

	unload() {
		if (this.source) {
			this.source.disconnect();
			this.source = null!;
			if (this.volumeNode) {
				this.volumeNode.disconnect();
				this.volumeNode = null!;
			}
		}
	}

	lastPlayStartFrame = 0;

	preciseDuration = 0;
}
</file>

<file path="src/engine/lib.ts">
import type { Container, Spritesheet } from 'pixi.js';
import { Assets, Cache, MIPMAP_MODES, Texture, WRAP_MODES } from 'pixi.js';
import type { FileDesc, FileDescImage, FileDescPrefab, FileDescSound } from 'thing-editor/src/editor/fs';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import TLib from 'thing-editor/src/editor/prefabs-typing';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import EDITOR_FLAGS, { EDITOR_BACKUP_PREFIX } from 'thing-editor/src/editor/utils/flags';
import getPrefabDefaults, { invalidatePrefabDefaults } from 'thing-editor/src/editor/utils/get-prefab-defaults';
import { checkForOldReferences, markOldReferences } from 'thing-editor/src/editor/utils/old-references-detect';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import __refreshPrefabRefs, { __refreshPrefabRefsPrepare } from 'thing-editor/src/editor/utils/refresh-prefabs';
import roundUpPoint from 'thing-editor/src/editor/utils/round-up-point';
import { getCurrentStack } from 'thing-editor/src/editor/utils/stack-utils';
import { __UnknownClass } from 'thing-editor/src/editor/utils/unknown-class';
import HowlSound from 'thing-editor/src/engine/HowlSound';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Scene, { __UnknownClassScene } from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import L from 'thing-editor/src/engine/utils/l';
import Pool from 'thing-editor/src/engine/utils/pool';
import RemoveHolder from 'thing-editor/src/engine/utils/remove-holder';
/// #if EDITOR
// run EDITOR to regenerate this files:
import 'thing-editor/src/editor/current-classes-typings';
import 'thing-editor/src/editor/current-scene-typings';

import waitForCondition from './lib/assets/src/utils/wait-for-condition';
/// #endif
import type { AssetsDescriptor } from '../editor/editor-env';
import Sound, { isFirefox } from './utils/sound';

let classes: GameClasses;
let scenes: KeyedMap<SerializedObject> = {};
let prefabs: KeyedMap<SerializedObject> = {};
let staticScenes: KeyedMap<Scene> = {};
let textures: KeyedMap<Texture> = {};
let soundsHowlers: KeyedMap<HowlSound> = {};

const removeHoldersToCleanup: RemoveHolder[] = [];

export const unHashedFileToHashed: Map<string, string> = new Map();

//@ts-ignore
const _initParsers = () => {
	const spriteSheetLoader = Assets.loader.parsers.find(p => p.name === 'spritesheetLoader');
	const originalParser = spriteSheetLoader!.parse!;
	spriteSheetLoader!.parse = (asset: any, options, ...args) => {
		const n = options!.src!.lastIndexOf('/') + 1;
		let url = options!.src!.substring(0, n) + asset.meta.image;
		asset.meta.image = unHashedFileToHashed.get(url)!.split('/').pop();
		return originalParser(asset, options, ...args);
	};

	const loadBitmapFont = Assets.loader.parsers.find(p => p.name === 'loadBitmapFont');
	const originalBMFParser = loadBitmapFont!.parse!;
	loadBitmapFont!.parse = (asset: string, options, ...args) => {
		const reg = /(file=")([^"]+)(")/gm;
		let result:RegExpExecArray |null;
		let fixedAsset:string = asset;
		while ((result = reg.exec(asset)) !== null) {
			const a = options!.src!.split('/');
			a.pop();
			const textureName = result![2];
			const fileName = a.join('/') + '/' + textureName;
			fixedAsset = fixedAsset.replace(textureName, unHashedFileToHashed.get(fileName)!.split('/').pop()!);
		}
		return originalBMFParser(fixedAsset, options, ...args);
	};
};

/// #if EDITOR
/*
/// #endif
_initParsers();
//*/

export default class Lib
	/// #if EDITOR
	extends TLib
/// #endif
{

	static ASSETS_ROOT = './assets/';

	static sounds: KeyedMap<HowlSound>;

	static resources: KeyedObject = {};

	static fonts: KeyedObject = {};

	static REMOVED_TEXTURE: Texture;

	/// #if EDITOR
	static __loadSceneNoInit(name: string): Scene {
		return (this.loadScene as any)(name, true);
	}

	/// #endif

	static loadScene(name: string): Scene {

		/// #if EDITOR
		const omitInitialization = arguments[1] || game.__EDITOR_mode;
		/// #endif

		if (
			/// #if EDITOR
			!omitInitialization &&
			/// #endif
			staticScenes.hasOwnProperty(name)) {
			return staticScenes[name];
		}
		let isSceneExists = scenes.hasOwnProperty(name);
		assert(isSceneExists, 'No scene with name \'' + name + '\'', 10046);
		/// #if EDITOR

		let overrideName = name;
		if (!omitInitialization && (name === game.editor.currentSceneName)) {
			if (scenes[game.editor.currentSceneBackupName]) {
				overrideName = game.editor.currentSceneBackupName;
			}
		}

		if (!name.startsWith(EDITOR_BACKUP_PREFIX)) {
			scenes[name].p.name = name;
		}
		/// #endif

		/// #if EDITOR
		showedReplaces = {};
		/// #endif

		const s: Scene = Lib._deserializeObject(scenes[
			/// #if EDITOR
			overrideName ||
			/// #endif
			name]) as Scene;

		/// #if EDITOR
		if (!omitInitialization) {
			/// #endif
			constructRecursive(s);
			/// #if EDITOR
		}
		/// #endif

		if (s.isStatic
			/// #if EDITOR
			&& !omitInitialization
			/// #endif
		) {
			staticScenes[name] = s;
		}
		return s;
	}

	static _setClasses(_classes: GameClasses) {
		game._setClasses(_classes);
		classes = _classes;
		/// #if EDITOR
		return;
		/// #endif
		normalizeSerializedData();
		/// #if DEBUG
		__checkClassesForEditorOnlyMethods(_classes);
		/// #endif
	}

	static scenes: KeyedMap<SerializedObject>;
	static prefabs: KeyedMap<SerializedObject>;

	/// #if EDITOR
	static __outdatedReferencesDetectionDisabled = 0;
	/// #endif

	static hasPrefab(name: string) {
		return prefabs.hasOwnProperty(name);
	}

	static hasScene(name: string) {
		return scenes.hasOwnProperty(name);
	}

	static hasTexture(name: string) {
		return textures.hasOwnProperty(name);
	}

	static _unloadTexture(name: string) {
		let texture = textures[name];
		if (!texture) {
			return;
		}
		Texture.removeFromCache(texture);
		texture.destroy(true);
	}

	/// #if EDITOR
	static removeAtlas(file: FileDesc) {
		Cache.remove(file.fileName);
		for (const textureName in (file.asset as KeyedObject).frames) {
			fs.removeSubAsset(textureName, AssetType.IMAGE);
			Lib.__deleteTexture(textureName);
		}
	}
	/// #endif

	static __parsersLoadingPromises = [] as Promise<true>[];

	static async addResource(name: string, url: string, attempt = 0
		/// #if EDITOR
		, parentAsset?: FileDesc
		/// #endif
	) {
		game.loadingAdd(url);

		await Promise.all(Lib.__parsersLoadingPromises);

		Assets.load(
			/// #if EDITOR
			getVersionedFileName(parentAsset!) ||
			/// #endif
			url).then((atlas: Spritesheet) => {
			if (atlas.textures) {
				for (const textureName in atlas.textures) {
					const texture = atlas.textures[textureName];
					textures[textureName] = texture;

					/// #if EDITOR
					const existingAsset = fs.getFileByAssetName(textureName, AssetType.IMAGE);
					if (existingAsset) {
						existingAsset.asset = texture;
						existingAsset.parentAsset = parentAsset;
					} else {
						const cloneAsset = Object.assign({}, parentAsset);
						cloneAsset.asset = texture;
						cloneAsset.assetName = textureName;
						cloneAsset.parentAsset = parentAsset;
						cloneAsset.assetType = AssetType.IMAGE;
						fs.addSubAsset(cloneAsset);
					}
				/// #endif
				}
			}
			Lib.resources[name] = atlas;
			game.loadingRemove(url);
			/// #if EDITOR
			game.editor.ui.refresh();
			/// #endif
		}).catch((_er) => {
			/// #if EDITOR
			debugger;
			attempt = 3;
			/// #endif
			if (attempt < 3 && !game._loadingErrorIsDisplayed) {
				attempt++;
				window.setTimeout(() => {
					Lib.addResource(name, url + ((attempt === 1) ? '?a' : 'a'), attempt
						/// #if EDITOR
						, parentAsset
						/// #endif
					);
					game.loadingRemove(url);
				}, attempt * 1000);
			} else {
				game.showLoadingError(url
					/// #if DEBUG
					+ '; ' + _er.stack
					/// #endif
				);
			}
		});
	}

	static addTexture(name: string, textureURL: string | Texture, attempt = 0) {
		/// #if EDITOR
		if (game.editor.buildProjectAndExit) {
			if (typeof textureURL === 'string') {
				textureURL = Texture.WHITE;
			}
		}
		/// #endif

		if (typeof textureURL === 'string') {

			game.loadingAdd(textureURL);

			/// #if EDITOR
			const asset = fs.getFileByAssetName(name, AssetType.IMAGE) as FileDescImage;
			/// #endif
			Texture.fromURL(
				/// #if EDITOR
				getVersionedFileName(asset) ||
				/// #endif
				textureURL).then((newTexture) => {
				/// #if EDITOR
				if (textures[name]) {
					if (textures[name] && !Lib.__isSystemTexture(textures[name], name)) {
						Lib._unloadTexture(name);
					}
					const oldTexture = textures[name];
					Object.assign(oldTexture, newTexture);
					oldTexture.onBaseTextureUpdated(newTexture.baseTexture);
					oldTexture._updateID = Date.now();
				} else {
					/// #endif
					textures[name] = newTexture;
					/// #if EDITOR
				}
				/// #endif
				Lib._afterTextureLoaded(name);
				game.loadingRemove(textureURL);
			}).catch(() => {
				if (attempt < 3 && !game._loadingErrorIsDisplayed) {
					attempt++;
					window.setTimeout(() => {
						Lib.addTexture(name, textureURL + ((attempt === 1) ? '?a' : 'a'), attempt);
						game.loadingRemove(textureURL);
					}, attempt * 1000);
				} else {
					game.showLoadingError(textureURL as string);
				}
			});
		} else {
			textures[name] = textureURL;
			Lib._afterTextureLoaded(name);
		}
	}

	/* texture settings bits
	1 - load on demand
	2 - load on demand with early preCache
	4 - generate mip-maps
	8 - wrap mode repeat
	16 - wrap mode repeat mirror
	*/
	static _getTextureSettingsBits(name: string, mask: number) {
		let s = game.projectDesc.loadOnDemandTextures;
		return s.hasOwnProperty(name) ? (s[name] & mask) : 0;
	}

	static _afterTextureLoaded(name: string) {
		let baseTexture = textures[name].baseTexture;
		switch (Lib._getTextureSettingsBits(name, 24)) {
		case 0:
			baseTexture.wrapMode = WRAP_MODES.CLAMP;
			break;
		case 8:
			baseTexture.wrapMode = WRAP_MODES.REPEAT;
			break;
		default:
			baseTexture.wrapMode = WRAP_MODES.MIRRORED_REPEAT;
			break;
		}

		if (Lib._getTextureSettingsBits(name, 4)) {
			baseTexture.mipmap = MIPMAP_MODES.ON;
		}

		baseTexture.update();

		/// #if EDITOR
		editorEvents.emit('textureUpdated', name);
		/// #endif
	}

	/// #if EDITOR
	static __isSystemTexture(texture: Texture, imageName:string) {
		if (game.editor.buildProjectAndExit) {
			return imageName === 'EMPTY' || imageName === 'WHITE';
		}
		return texture.baseTexture === Lib.REMOVED_TEXTURE.baseTexture ||
			texture.baseTexture === textures.EMPTY.baseTexture ||
			texture.baseTexture === textures.WHITE.baseTexture;
	}
	/// #endif

	static getTexture(name: string) {

		/// #if EDITOR
		if (!textures.hasOwnProperty(name)) {
			textures[name] = Lib.REMOVED_TEXTURE.clone();
		}
		/// #endif
		/// #if DEBUG
		assert(textures.hasOwnProperty(name), 'wrong image name ' + name);
		/// #endif

		return textures[name];
	}

	static _getStaticScenes() {
		return staticScenes;
	}

	static hasSound(soundId: string) {
		return soundsHowlers.hasOwnProperty(soundId);
	}

	static getSound(soundId: string, __dynamicPreloading = false): HowlSound {
		assert(soundsHowlers.hasOwnProperty(soundId), 'No sound with id \'' + soundId + '\' found.');
		let s = soundsHowlers[soundId];
		/// #if EDITOR
		if (!game.__EDITOR_mode) {
			if (!s.audioBuffer) {
				game.editor.ui.status.error('Sound "' + soundId + '" is not preloaded. Please check-on preloading mode for this sound, or use Lib.preloadSound("' + soundId + '") in scene\`s onShow() method before using this sound.', 32008);
			} else if (!__dynamicPreloading && !s.audioBuffer) {
				game.editor.ui.status.warn('Sound "' + soundId + '" preloading is not finished. Please preload sounds inside onShow method of scene, to automatic insurance of complete sounds preloading.', 32009);
			}
			Lib.preloadSound(soundId);
		}
		/// #endif
		return s;
	}

	/// #if EDITOR
	static async __addSoundEditor(file: FileDescSound) {
		await waitForCondition(() => !fs.soundsRebuildInProgress());
		const fileName = getVersionedFileName(file)!.replace(/wav(\?|$)/, 'ogg?');
		soundsHowlers[file.assetName] = new HowlSound(fileName);
		file.asset = Lib.getSound(file.assetName);
		const soundsDirData = fs.soundsData.get(file.lib ? file.lib.dir : game.editor.currentProjectAssetsDir)!;
		if (soundsDirData) {
			const sndData = soundsDirData.soundInfo[file.fileName.substring(1)];
			if (sndData) {
				file.asset.preciseDuration = sndData.duration;
			}
		}

		game.editor.ui.refresh();
	}
	/// #endif

	static addSound(name: string, url: string, duration: number) {
		/// #if EDITOR
		assert(false, 'for editor mode use Lib.__addSoundEditor instead.');
		/// #endif
		const s = new HowlSound(url + '.' + (game.isMobile.apple.device ? 'aac' : 'ogg'));
		s.preciseDuration = duration;
		if (isFirefox) {
			s.preciseDuration = undefined as any;
		}
		soundsHowlers[name] = s;
		/// #if DEBUG
		Sound.__refreshDebugger();
		/// #endif
	}

	static preloadSound(soundId: string | null
		/// #if EDITOR
		, owner?: any// BgMusic
		/// #endif
	) {
		if (soundId) {
			/// #if EDITOR
			if (!soundsHowlers.hasOwnProperty(soundId)) {
				game.editor.ui.status.error('No sound with id \'' + soundId + '\' found.', 10043, owner);
				return;
			}
			/// #endif
			let s = soundsHowlers[soundId];
			if (!s.audioBuffer) {
				s.load();
				return true;
			}
		}
	}

	static _deserializeObject(src: SerializedObject
		/// #if EDITOR
		, isScene = false
		/// #endif
	): Container {

		/// #if EDITOR
		let ret: Container;


		deserializationDeepness++;

		if (src.hasOwnProperty('r')) { // prefab reference
			deserializationReferencesDeepness++;
			let replacedPrefabName: string | undefined;
			if (!Lib.hasPrefab(src.r!)) {
				replacedPrefabName = '___system/unknown-prefab';
				if (!showedReplaces[src.r!]) {
					showedReplaces[src.r!] = true;
					window.setTimeout(() => { // wait for id assign
						game.editor.ui.status.error('Reference to unknown prefab: \'' + src.r + '\'', 99999, ret);
					}, 1);
				}
			}
			const refName = replacedPrefabName || src.r!;
			prefabs[refName].__lastTouch = EDITOR_FLAGS.__touchTime;
			ret = Lib._deserializeObject(prefabs[refName]);
			ret.__nodeExtendData.__deserializedFromPrefab = refName;
			Object.assign(ret, src.p);

			if (replacedPrefabName) {
				ret.__nodeExtendData.unknownPrefab = src.r;
				ret.__nodeExtendData.unknownPrefabProps = src.p;
			}
			__preparePrefabReference(ret, src.r!);
			deserializationReferencesDeepness--;
		} else { // not a prefab reference


			let replaceClass: SourceMappedConstructor | undefined = undefined;
			let replaceClassName: string | undefined;

			if (!classes.hasOwnProperty(src.c!)) {
				replaceClass = (((Object.values(scenes).indexOf(src) >= 0) || isScene) ? __UnknownClassScene : __UnknownClass);
				replaceClassName = replaceClass.__className;
				if (!showedReplaces[src.c!]) {
					showedReplaces[src.c!] = true;
					if (game.editor.buildProjectAndExit) {
						game.editor.ui.status.error('Unknown class ' + src.c, 32012);
					} else {
						window.setTimeout(() => { // wait for id assign
							game.editor.ui.status.error('Unknown class ' + src.c, 32012, ret);
						}, 1);
					}
				}
			}
			if (!replaceClass) {
				assert(classes[src.c!].__defaultValues, 'Class ' + (replaceClassName || src.c) + ' has no default values set');
			}

			const constrictor = (replaceClass || classes[src.c!]);

			ret = Pool.create(constrictor as any);

			if (ret.__beforeDeserialization) {
				ret.__beforeDeserialization();
			}
			if (replaceClassName) {
				ret.__nodeExtendData.unknownConstructor = src.c;
				ret.__nodeExtendData.unknownConstructorProps = src.p;
			}

			Object.assign(ret, Object.assign({}, constrictor.__defaultValues, src.p));
		}

		/*
		/// #endif
		// production deserialization
		const ret = Pool.create(src.c as any as Constructor);
		Object.assign(ret, src.p);
		//*/

		if (src.hasOwnProperty(':')) {
			let childrenData: SerializedObject[] = src[':'] as SerializedObject[];

			/// #if EDITOR
			if (!game.__EDITOR_mode || deserializationReferencesDeepness) {
				childrenData = childrenData.filter(_filterStaticTriggers);
			}
			/// #endif
			for (let childData of childrenData) {
				/// #if EDITOR

				let isVisible = game.__EDITOR_mode || !childData.p.hasOwnProperty('name') || !childData.p.name || !childData.p.name.startsWith('___');
				if (isVisible) {
					isVisible = !childData.p.hasOwnProperty('name') || !childData.p.name || !childData.p.name.startsWith('____'); //99999
				}
				if (isVisible) {
					/// #endif
					ret.addChild(Lib._deserializeObject(childData));
					/// #if EDITOR
				}
				/// #endif
			}
		}

		/// #if EDITOR
		deserializationDeepness--;
		if (deserializationDeepness === 0) {
			src.__lastTouch = EDITOR_FLAGS.__touchTime;
			processAfterDeserialization(ret);
			ret.forAllChildren(processAfterDeserialization);
		}
		/// #endif

		return ret;
	}

	static getHashedFileName(assetName:string
		/// #if EDITOR
		, assetType = AssetType.IMAGE
		/// #endif
	) {
		/// #if EDITOR
		return fs.getFileByAssetName(assetName, assetType)?.fileName;
		/*
		/// #endif
		return Lib.ASSETS_ROOT + unHashedFileToHashed.get(Lib.ASSETS_ROOT + assetName);
		//*/
	}

	static addAssets(data: AssetsDescriptor, assetsRoot = Lib.ASSETS_ROOT) {

		for (const prefabName in data.prefabs) {
			if (!prefabs[prefabName]) {
				prefabs[prefabName] = data.prefabs[prefabName];
			}
		}

		for (const prefabName in data.scenes) {
			if (!scenes[prefabName]) {
				scenes[prefabName] = data.scenes[prefabName];
			}
		}

		if (game.classes) {
			normalizeSerializedData();
		}

		if (data.text) {
			L.setLanguagesAssets(data.text);
		}

		for (const textureName of data.images) {
			Lib.addTexture(Lib.unHashFileName(textureName, assetsRoot), assetsRoot + textureName);
		}

		for (const soundEntry of data.sounds) {
			Lib.addSound(Lib.unHashFileName(soundEntry[0], assetsRoot), assetsRoot + soundEntry[0], soundEntry[1]);
		}
		if (data.resources) {
			for (const name of data.resources) {
				Lib.addResource(Lib.unHashFileName(name, assetsRoot), assetsRoot + name + '.json');
			}
		}
		if (data.xmls) {
			for (const xmlName of data.xmls) {
				Assets.load(assetsRoot + xmlName + '.xml');
			}
		}
		if (data.fonts) {
			for (const fontName of data.fonts) {
				Lib.fonts[Lib.unHashFileName(fontName, assetsRoot)] = assetsRoot + fontName;
			}
		}
	}

	static unHashFileName (fileName: string, assetsRoot: string = Lib.ASSETS_ROOT): string {
		const n = fileName.lastIndexOf('.');
		if (n > 0) {
			const ret = fileName.substring(0, n - 9) + fileName.substring(n);
			unHashedFileToHashed.set(assetsRoot + ret, fileName);
			return ret;
		}
		return fileName.slice(0, -9);
	}

	static destroyObjectAndChildren(o: Container, itsRootRemoving?: boolean) {
		/// #if EDITOR

		if (EDITOR_FLAGS._root_initCalled.has(o)) {
			assert(false, 'Attempt to self remove inside init() method. Operation does not supported. Do not instance object if you going to just remove. Or remove it in parent.init() method before its init() method called.', 90000);
		}

		let extData = o.__nodeExtendData;
		editorUtils.exitPreviewMode(o);
		if (extData.constructorCalled) {

			EDITOR_FLAGS._root_onRemovedCalled.add(o);
			/// #endif

			o.onRemove();
			o._thing_initialized = false;
			/// #if EDITOR
			if (EDITOR_FLAGS._root_onRemovedCalled.has(o)) {
				game.editor.editClassSource(o);
				assert(false, 'onRemove method without super.onRemove() detected in class \'' + (o.constructor as SourceMappedConstructor).name + '\'', 10045);
				EDITOR_FLAGS._root_onRemovedCalled.delete(o);
			}

		}
		if (o.__beforeDestroy) {
			o.__beforeDestroy();
		}
		let needRefreshSelection = extData.isSelected;
		if (extData.isSelected) {
			game.editor.selection.remove(o);
		}
		/// #endif
		if (itsRootRemoving
			/// #if EDITOR
			&& !game.__EDITOR_mode
			/// #endif
		) {
			let r = Pool.create(RemoveHolder);
			/// #if EDITOR
			r.stack = getCurrentStack('removing with holder at ' + game.time + '; ' + o.name);
			constructRecursive(r);
			/// #endif
			let c = o.parent.children;
			c[c.indexOf(o)] = r;
			r.parent = o.parent;

			removeHoldersToCleanup.push(r);

			o.parent = null as any;
		} else {
			o.detachFromParent();
		}
		while (o.children.length > 0) {
			Lib.destroyObjectAndChildren(o.getChildAt(o.children.length - 1) as Container);
		}

		Pool.dispose(o);

		o.interactiveChildren = true;

		/// #if EDITOR
		o.__nodeExtendData = EMPTY_NODE_EXTEND_DATA;
		if (needRefreshSelection) {
			game.editor.refreshTreeViewAndPropertyEditor();
		}
		markOldReferences(o);
		/// #endif
	}

	static _cleanupRemoveHolders() {
		while (removeHoldersToCleanup.length > 0) {
			Lib.destroyObjectAndChildren(removeHoldersToCleanup[0]);
		}
	}

	static _loadClassInstanceById(id: string): Container {
		const Class = classes[id];
		/// #if DEBUG
		if (!Class) {
			assert(false, 'No class with id "' + id + '" found.', 99999);
		}
		/// #endif
		let ret = Pool.create(Class as any) as Container;
		Object.assign(ret, Class.__defaultValues);

		/// #if EDITOR
		if (ret instanceof Scene) {

			ret.all = '"scene.all" is not initialized yet.' as any;
		}
		if (!game.__EDITOR_mode) {
			/// #endif
			constructRecursive(ret);
			/// #if EDITOR
		}
		/// #endif
		return ret;
	}

	static _clearStaticScene(sceneName: string) {
		let s = staticScenes[sceneName];
		if (s) {
			let scenesStack = game._getScenesStack();
			if (!s.parent && scenesStack.indexOf(s) < 0 && scenesStack.indexOf(s.name as string) < 0) {
				Lib.destroyObjectAndChildren(s);
			}
			delete staticScenes[sceneName];
		}
	}

	/// #if EDITOR

	static __clearStaticScenes() {
		const scenes = Object.assign({}, staticScenes);
		for (let sceneName in scenes) {
			this._clearStaticScene(sceneName);
		}
	}

	static __serializeObject(o: Container): SerializedObject {

		editorUtils.exitPreviewMode(o);
		roundUpPoint(o);
		if (o.__beforeSerialization) {
			o.__beforeSerialization();
		}

		let ret: SerializedObject | undefined;
		if (!game.editor.disableFieldsCache) {
			ret = o.__nodeExtendData.serializationCache;
		}
		if (!ret) {
			let props: KeyedObject = {};
			let propsList = (o.constructor as SourceMappedConstructor).__editableProps;

			let defaults: KeyedObject = getPrefabDefaults(o);

			for (let p of propsList) {
				if (!p.notSerializable) {
					if (p.visible && !p.visible(o)) {
						continue;
					}
					let val = (o as KeyedObject)[p.name];
					if (p.arrayProperty) {
						if (!val) {
							val = [];
						} else if (!Array.isArray(val)) {
							val = [val];
						}
						val = val.filter((i: any) => i);
						if ((val.length === defaults[p.name].length &&
							defaults[p.name].every((v: any, i: number) => v === val[i])
						)) {
							val = defaults[p.name];
						}
					}
					if ((val != defaults[p.name]) && (typeof val !== 'undefined')) {
						if (p.type === 'rect') {
							props[p.name] = {
								x: val.x,
								y: val.y,
								w: val.w,
								h: val.h
							};
						} else {
							props[p.name] = val;
						}
					}
				}
			}

			if (o.__nodeExtendData.isPrefabReference) {
				ret = {
					r: o.__nodeExtendData.isPrefabReference,
					p: props
				};
				if (o.__nodeExtendData.unknownPrefab) {
					ret.r = o.__nodeExtendData.unknownPrefab;
					ret.p = o.__nodeExtendData.unknownPrefabProps!;
				}
			} else {
				ret = {
					c: (o.constructor as SourceMappedConstructor).__className as string,
					p: props
				};
				if (o.__nodeExtendData.unknownConstructor) {
					ret.c = o.__nodeExtendData.unknownConstructor;
					ret.p = Object.assign(o.__nodeExtendData.unknownConstructorProps as SerializedObjectProps, ret.p);
				}
			}

			if (o.children.length > 0) {
				let children = (o.children as Container[]).filter(__isSerializableObject).map(Lib.__serializeObject as () => SerializedObject);
				if (children.length > 0) {
					ret![':'] = children;
				}
			}
			o.__nodeExtendData.serializationCache = ret;
		}

		if (o.__afterSerialization) {
			o.__afterSerialization(ret);
		}

		return ret;
	}

	static __invalidateSerializationCache(o: Container) {
		let p = o;
		while ((p !== game.stage) && p) {
			p.__nodeExtendData.serializationCache = undefined;
			p = p.parent;
		}
	}

	static __deleteScene(_sceneName: string) {
		assert(scenes.hasOwnProperty(_sceneName), 'attempt to delete not existing scene: ' + _sceneName);
		delete scenes[_sceneName];
		return fs.deleteAsset(_sceneName, AssetType.SCENE);
	}

	static __saveScene(scene: Scene, name: string) {

		assert(game.__EDITOR_mode, 'attempt to save scene in running mode: ' + name);
		assert(typeof name === 'string', 'string expected');
		assert(scene instanceof Scene, 'attempt to save not Scene instance in to scenes list.');

		game.editor.disableFieldsCache = true;
		if (!name.startsWith(EDITOR_BACKUP_PREFIX)) {
			if (scene.name !== name) {
				game.editor.ui.sceneTree.refresh();
			}
			scene.name = name;
		}
		let sceneData = Lib.__serializeObject(scene);
		game.editor.disableFieldsCache = false;
		scenes[name] = sceneData;
		const ret = fs.saveAsset(name, AssetType.SCENE, sceneData);
		editorEvents.emit('sceneUpdate', name);
		return ret;
	}

	static __savePrefab(object: Container, name: string, libName?: string, saveFile = true) {
		invalidatePrefabDefaults();
		assert(game.__EDITOR_mode, 'attempt to save prefab in running mode: ' + name);
		assert(typeof name === 'string', 'Prefab name expected.');
		assert(!(object instanceof Scene), 'attempt to save Scene or not DisplayObject as prefab.');
		let tmpName = object.name;
		if (!name.startsWith(EDITOR_BACKUP_PREFIX)) {
			if (object.name !== name) {
				game.editor.ui.sceneTree.refresh();
			}
			object.name = name;
		}
		game.editor.disableFieldsCache = true;
		let prefabData = Lib.__serializeObject(object);
		prefabData.p.___prefabPivot = PrefabEditor.pivot;
		game.editor.disableFieldsCache = false;
		this.__savePrefabData(prefabData, name, libName, saveFile);
		object.name = tmpName;
	}

	static __savePrefabData(prefabData: SerializedObject, name: string, libName?: string, saveFile = true) {
		prefabs[name] = prefabData;
		if (saveFile) {
			fs.saveAsset(name, AssetType.PREFAB, prefabData, libName);
		}
		editorEvents.emit('prefabUpdated', name);
	}

	static __loadPrefabNoInit(prefabName: string) {
		return (Lib.loadPrefab as any)(prefabName, true);
	}

	static __preparePrefabReference(o: Container, prefabName: string) {
		__preparePrefabReference(o, prefabName);
	}

	static __loadPrefabReference(prefabName: string) {
		let ret = Lib.loadPrefab(prefabName);
		__preparePrefabReference(ret, prefabName);
		return ret;
	}

	static __callInitIfGameRuns(node: Container) {
		if (!game.__EDITOR_mode) {
			__callInitIfNotCalled(node);
		}
	}

	static __deleteSound(file: FileDescSound) {
		file.asset.unload();
		delete soundsHowlers[file.assetName];
	}

	static __deleteTexture(textureName: string) {
		if (textures[textureName]) {
			const texture = textures[textureName];
			let tmp = texture._updateID;
			Texture.removeFromCache(texture);
			Object.assign(texture, Lib.REMOVED_TEXTURE);
			texture._updateID = tmp;
			texture.onBaseTextureUpdated(texture.baseTexture);
		}
	}

	/// #endif

	/// #if DEBUG

	static get __soundsList() {
		return soundsHowlers;
	}

	/**
	* @protected
	*/
	static __overrideSound(soundId: string, src: string | HowlSound) {
		let s:HowlSound;
		if (src instanceof HowlSound) {
			s = src;
		} else {
			s = new HowlSound(src);
		}
		s.lastPlayStartFrame = 0;
		soundsHowlers[soundId] = s;
		game.emit('__sound-overridden', soundId);
	}

	/// #endif
}

const __isSerializableObject = (o: Container) => {
	let exData = o.__nodeExtendData;
	return !exData.hidden && !exData.noSerialize;
};

let deserializationDeepness = 0;
let deserializationReferencesDeepness = 0;

let constructRecursive = (o: Container) => {
	assert(!game.__EDITOR_mode, 'initialization attempt in editing mode.');

	if (o._thing_initialized) {
		return;
	}
	o._thing_initialized = true;

	/// #if EDITOR
	let extData = o.__nodeExtendData;
	assert(!extData.constructorCalled, 'init() method was already called for object ' + o.___info, 90001);

	EDITOR_FLAGS._root_initCalled.add(o);
	/// #endif

	o.init();

	/// #if EDITOR
	checkForOldReferences(o);
	if (EDITOR_FLAGS._root_initCalled.has(o)) {
		game.editor.editClassSource(o);
		assert(false, 'Class ' + (o.constructor as SourceMappedConstructor).__className + ' overrides init method without super.init() called.', 10042);
		EDITOR_FLAGS._root_initCalled.delete(o);
	}
	extData.constructorCalled = true;
	/// #endif

	let a: Container[] = o.children as Container[];
	let arrayLength = a.length;
	for (let i = 0; i < arrayLength; i++) {
		constructRecursive(a[i]);
	}
};

Lib.scenes = scenes;
Lib.prefabs = prefabs;

const normalizeSerializedDataRecursive = (data: SerializedObject) => {
	if (data.c) {
		if (typeof data.c === 'string') {

			assert(game.classes[data.c], 'Unknown class ' + data.c);

			data.c = game.classes[data.c] as any; // in runtime mode ".c" contains Class directly
			data.p = Object.assign({}, (data.c as any as SourceMappedConstructor).__defaultValues, data.p);
			if (data[':']) {
				for (const c of data[':']) {
					normalizeSerializedDataRecursive(c);
				}
			}
		}
	} else {
		const prefab = prefabs[data.r!];
		normalizeSerializedDataRecursive(prefab);

		delete data.r;
		data.c = prefab.c;
		data.p = Object.assign({}, prefab.p, data.p);

		if (prefab[':']) {
			if (data[':']) {
				data[':'] = prefab[':'].concat(data[':']);
			} else {
				data[':'] = prefab[':'];
			}
		}

		if (data[':']) {
			for (const c of data[':']) {
				normalizeSerializedDataRecursive(c);
			}
		}
	}
	if (data.p.timeline) {
		for (const f of data.p.timeline.f) {
			data.p[f.n] = f.t[0].v;
		}
	}
};

const normalizeSerializedData = () => {
	/// #if EDITOR
	assert(false, 'runtime feature only.');
	/// #endif

	Object.values(prefabs).forEach(_filterStaticTriggersRecursive);
	Object.values(scenes).forEach(_filterStaticTriggersRecursive);

	for (const name in prefabs) {
		normalizeSerializedDataRecursive(prefabs[name]);
	}
	for (const name in scenes) {
		normalizeSerializedDataRecursive(scenes[name]);
	}
};

/// #if EDITOR

const getVersionedFileName = (file: FileDesc) => {
	if (file) {
		if (file.v) {
			return file.fileName + '?v=' + file.v;
		}
		return file.fileName;
	}
};

export const EMPTY_NODE_EXTEND_DATA: NodeExtendData = { objectDeleted: 'Container was deleted and it`s extend data replaced with temporary object.' };
Object.freeze(EMPTY_NODE_EXTEND_DATA);

export { __onAssetAdded, __onAssetDeleted, __onAssetUpdated, constructRecursive };

const isAtlasAsset = (asset: any) => {
	return asset?.meta?.scale || asset?.skeleton;
};

const __onAssetAdded = (file: FileDesc) => {
	switch (file.assetType) {
	case AssetType.PREFAB:
		assert(!file.asset, 'asset reference of added file should be empty.');
		file.asset = Lib.prefabs[file.assetName] = fs.readJSONFile(file.fileName);
		game.editor.ui.refresh();
		break;
	case AssetType.SCENE:
		assert(!file.asset, 'asset reference of added file should be empty.');
		file.asset = Lib.scenes[file.assetName] = fs.readJSONFile(file.fileName);
		game.editor.ui.refresh();
		break;
	case AssetType.IMAGE:
		Lib.addTexture(file.assetName, (file as FileDescImage).asset || file.fileName);
		file.asset = Lib.getTexture(file.assetName);
		game.editor.ui.refresh();
		break;

	case AssetType.SOUND:
		Lib.__addSoundEditor(file as FileDescSound);
		break;
	case AssetType.RESOURCE:
		file.asset = fs.readJSONFile(file.fileName) as KeyedObject;
		if (isAtlasAsset(file.asset)) {
			Lib.addResource(file.assetName, file.fileName, 0, file);
		}
		break;
	case AssetType.BITMAP_FONT:
		Assets.load(file.fileName);
		break;
	case AssetType.L10N:
		file.asset = L._deserializeLanguage(fs.readJSONFile(file.fileName) as KeyedObject);
		game.editor.LanguageView.addAssets();
		break;
	}
};

const __onAssetUpdated = (file: FileDesc) => {
	let isAcceptChanges;
	switch (file.assetType) {
	case AssetType.PREFAB:
		isAcceptChanges = false;
		if (PrefabEditor.currentPrefabName !== file.assetName) {
			isAcceptChanges = true;
		} else {
			if (!game.editor.isCurrentContainerModified) {
				isAcceptChanges = true;
			} else {
				const answer = fs.showQuestion(
					'Do you want to load external changes?',
					'prefab "' + file.assetName + '" was changed externally.',
					'Keep editing',
					'Discard your changes and load external changes'/*,
						'Ignore external changes'*/);
				isAcceptChanges = answer === 1;
			}
		}
		if (isAcceptChanges) {
			__refreshPrefabRefsPrepare();
			file.asset = fs.readJSONFile(file.fileName);
			Lib.prefabs[file.assetName] = (file as FileDescPrefab).asset;
			__refreshPrefabRefs();
			if (PrefabEditor.currentPrefabName === file.assetName) {
				PrefabEditor.exitPrefabEdit();
				PrefabEditor.editPrefab(file.assetName);
			}
			game.editor.ui.refresh();
		}

		break;
	case AssetType.SCENE:
		//TODO
		break;
	case AssetType.IMAGE:
		Lib.addTexture(file.assetName, file.fileName);
		game.editor.ui.refresh();
		break;
	case AssetType.SOUND:
		Lib.__addSoundEditor(file as FileDescSound);
		break;
	case AssetType.RESOURCE:
		if (isAtlasAsset(file.asset)) {
			Lib.removeAtlas(file);
			file.asset = fs.readJSONFile(file.fileName) as KeyedObject;
			Lib.addResource(file.assetName, file.fileName, 0, file);
		}
		break;
	case AssetType.BITMAP_FONT:
		Assets.load(file.fileName + '?v=' + file.v);
		break;
	case AssetType.L10N:
		file.asset = L._deserializeLanguage(fs.readJSONFile(file.fileName) as KeyedObject);
		game.editor.LanguageView.addAssets();
		break;
	}
};

const __onAssetDeleted = (file: FileDesc) => {
	console.log('deleted: ' + file.fileName);
	switch (file.assetType) {
	case AssetType.PREFAB:
		delete Lib.prefabs[file.assetName];
		game.editor.ui.refresh();
		break;
	case AssetType.SCENE:
		delete Lib.scenes[file.assetName];
		game.editor.ui.refresh();
		break;
	case AssetType.IMAGE:
		Lib.__deleteTexture(file.assetName);
		game.editor.ui.refresh();
		break;
	case AssetType.RESOURCE:
		if (isAtlasAsset(file.asset)) {
			Lib.removeAtlas(file);
			game.editor.ui.refresh();
		}
		break;
	case AssetType.L10N:
		game.editor.LanguageView.removeAsset();
		break;
	case AssetType.SOUND:
		Lib.__deleteSound(file as FileDescSound);
		break;
	}
};

let showedReplaces: KeyedMap<true>;


const __preparePrefabReference = (o: Container, prefabName: string) => {
	if (game.__EDITOR_mode) {
		o.__nodeExtendData.isPrefabReference = prefabName;
		for (const c of o.children) {
			c.__nodeExtendData.hidden = true;
		}
	}
};
/// #endif

/// #if DEBUG
function __callInitIfNotCalled(node: Container) {
	assert(!game.__EDITOR_mode, 'Attempt to init object in editor mode.');
	if (!node._thing_initialized) {
		constructRecursive(node);
	}
}

const processAfterDeserialization = (o: Container) => {
	if (o.__afterDeserialization) {
		o.__afterDeserialization();
	}
};

const EDITOR_ONLY_METHODS = [
	'__beforeDeserialization',
	'__treeInjection',
	'__beforeSerialization',
	'__afterDeserialization',
	'__afterSerialization',
	'__beforeDestroy',
	'__EDITOR_onCreate',
	'__EDITOR_filterPropsSelection',
	'__goToPreviewMode',
	'__exitPreviewMode',
	'__onSelect',
	'__onUnselect',
	'__onChildSelected',
	'__isAnyChildSelected',
	'__shiftObject'
];

const EDITOR_ONLY_STATIC_METHODS = [
	'__isPropertyDisabled',
	'__EDITOR_tip',
	'__isScene',
	'__sourceCode',
	'__canAcceptParent',
	'__canAcceptChild',
	'__beforeChangeToThisType',
	'__validateObjectData'
];

const __checkClassesForEditorOnlyMethods = (classes: GameClasses) => {
	for (let key in classes) {
		const Class = classes[key];
		for (const propName of EDITOR_ONLY_METHODS) {
			if (Class.prototype.hasOwnProperty(propName)) {
				game.__showDebugError('Class ' + key + ' contains "' + propName + '" method, which has sense in editor only, and should be wrapped with "/// #if EDITOR", "/// #endif" tags', 99999);
			}
		}
		for (const propName of EDITOR_ONLY_STATIC_METHODS) {
			if (Class.hasOwnProperty(propName)) {
				game.__showDebugError('Class ' + key + ' contains "' + propName + '" static method, which has sense in editor only, and should be wrapped with "/// #if EDITOR", "/// #endif" tags', 99999);
			}
		}
	}
};
/// #endif

(Lib as any).loadPrefab = (name: string, omitInitialization = game.__EDITOR_mode): Container => { //moved here to keep auto typing generation (TLib) work
	assert(prefabs.hasOwnProperty(name), 'No prefab with name \'' + name + '\' registered in Lib', 10044);
	/// #if EDITOR
	if (!name.startsWith(EDITOR_BACKUP_PREFIX)) {
		prefabs[name].p.name = name;
	}
	showedReplaces = {};
	/// #endif
	const ret: Container = Lib._deserializeObject(prefabs[name]);
	/// #if EDITOR
	if (!omitInitialization) {
		/// #endif
		constructRecursive(ret);
		/// #if EDITOR
	}
	ret.__nodeExtendData.__deserializedFromPrefab = name;
	/// #endif
	return ret;
};

const _filterStaticTriggers = (childData: SerializedObject) => {
	return !childData[':'] || !childData[':'].some((cd) => {
		return (cd.c === 'StaticTrigger') && (!!cd.p.invert !== !getValueByPath(cd.p.dataPath || game.classes.StaticTrigger.__defaultValues.dataPath, game));
	});
};

const _filterStaticTriggersRecursive = (data: SerializedObject) => {
	if (data[':']) {
		let a = data[':'].filter(_filterStaticTriggers);
		data[':'] = a;
		a.forEach(_filterStaticTriggersRecursive);
	}
};

export { isAtlasAsset, removeHoldersToCleanup };

Lib.sounds = soundsHowlers;
</file>

<file path="src/engine/lib/~snd-convert-cache.json">
{"fileName":"thing-editor\\src\\engine\\lib\\~snd-convert-cache.json","thing-editor/src/engine/lib/assets/click.wav":{"mTime":1763050978853.523,"bitrate":48,"hash":"40e35329ebdb0eb0eb83bdc28a6b5d36","duration":0.114943},"thing-editor/src/engine/lib/assets/over.wav":{"mTime":1763050978853.523,"bitrate":48,"hash":"5b860f9e674bd7eb414cfeb24adaf22d","duration":0.033469}}
</file>

<file path="src/engine/lib/assets/___default_content/progressbar.p.json">
{
	"c": "ProgressBar",
	"p": {
		"name": "___default_content/progressbar",
		"x": 93,
		"y": 128,
		"interactive": true
	},
	":": [
		{
			"c": "Sprite",
			"p": {
				"name": "bg",
				"alpha": 0.5,
				"scale.y": 12.5,
				"image": "WHITE"
			}
		},
		{
			"c": "Sprite",
			"p": {
				"name": "bar",
				"scale.y": 13.666666666666666,
				"image": "WHITE",
				"tint": 65280
			}
		},
		{
			"c": "DSprite",
			"p": {
				"name": "cap",
				"x": 8,
				"scale.x": 1.5,
				"scale.y": 1.5,
				"image": "WHITE"
			}
		}
	]
}
</file>

<file path="src/engine/lib/assets/___system/backdrop.p.json">
{
	"c": "Container",
	"p": {
		"name": "___system/backdrop"
	},
	":": [
		{
			"c": "__SystemBackDrop",
			"p": {
				"name": "backdrop"
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.4,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": 99,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": 199,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": 299,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": 399,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -401,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -301,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -201,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -101,
				"y": -1001,
				"width": 2,
				"height": 2000,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011.416666666667,
				"y": -1,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.4,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": -101,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": -201,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": -301,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": -401,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": 399,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": 299,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": 199,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		},
		{
			"c": "Shape",
			"p": {
				"x": -1011,
				"y": 99,
				"width": 2000,
				"height": 2,
				"shapeFillAlpha": 0.2,
				"shapeFillColor": 16777215
			}
		}
	]
}
</file>

<file path="src/engine/lib/assets/___system/delay.c.ts">
/*
Usage:
	function callback() {

	}
	let d = Delay.delay(callback, 30); //30 frames (half of second) delay


	d.remove(); // to cancel delay.


	Why should you use this delay instead of standard JS window.setTimeout?
	This delay will be linked to current scene,
	and if user will close scene and return to main menu,
	or modal popup will appear,
	delay will be postponed until user return to scene which delay created in, and exactly 30 frames in scene will past.
	If scene will be destroyed, this delay will be canceled automatically.
	So you will avoid tons of bugs.

	You can see all currently scheduled delays in scene's tree in editor. Also you can see it`s 'delay' editable property and edit it due debugging purposes.
*/

import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import type { DebugStack } from 'thing-editor/src/editor/utils/stack-utils';
import { getCurrentStack, showStack } from 'thing-editor/src/editor/utils/stack-utils';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import { constructRecursive } from 'thing-editor/src/engine/lib';
import Pool from 'thing-editor/src/engine/utils/pool';


export default class Delay extends Container {

	static delay(callback: () => void, delayFrames: number, container = game.currentContainer): Delay {
		assert(!game.__EDITOR_mode, 'Attempt to create Delay.delay() in editing mode.', 10007);
		assert(callback, 'Delay.delay(). Function expected as first parameter, but ' + (typeof callback) + ' received.', 10008);
		assert(typeof delayFrames === 'number', 'Delay.delay(). Number expected as second parameter, but ' + (typeof delayFrames) + ' received.', 10009);

		if (delayFrames <= 0) {
			callback();
			/// #if DEBUG
			return 'call back was called immediately because time were: ' + delayFrames as any;
			/// #endif
		} else {

			let d = Pool.create(Delay);
			/// #if EDITOR
			constructRecursive(d);
			/// #endif
			d.delay = delayFrames;
			d.callback = callback;
			container.addChild(d);
			/// #if EDITOR
			d.name = container.name + '; ' + (callback.name || 'anonymous function');

			d.___stack = getCurrentStack('Delay');

			d.__description = d.___stack.stack;

			/// #endif
			return d;
		}
	}

	@editable()
	delay = 0;
	callback: null | (() => void) = null;

	@editable({ type: 'ref', onClick: showStack })
	___stack!: DebugStack;

	/// #if EDITOR

	static __canAcceptParent(_parent: Container) {
		return false;
	}

	onRemove() {
		super.onRemove();
		if (!game.__EDITOR_mode && !EDITOR_FLAGS.isStoppingTime) {
			if (this.callback) {
				game.editor.ui.status.warn('Delay was removed before its triggered', 32021, this, undefined, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
			}
		}
		this.callback = null;
	}
	/// #endif

	constructor() {
		super();
		this.visible = false;
	}

	skip() {
		this.callback!();
		this.callback = null;
		this.remove();
	}

	update() {
		this.delay--;
		if (this.delay < 1) {
			this.callback!();
			/// #if EDITOR
			this.callback = null;
			/// #endif
			this.remove();
		}
	}
}

/// #if EDITOR
Delay.__EDITOR_icon = 'tree/timer';
/// #endif
</file>

<file path="src/engine/lib/assets/___system/gizmo.p.json">
{
	"c": "Container",
	"p": {
		"name": "___system/gizmo"
	},
	":": [
		{
			"c": "__SystemBackDrop",
			"p": {
				"name": "camera-frame",
				"shapeFillAlpha": 0,
				"shapeLineWidth": 30,
				"shapeLineAlpha": 0.4,
				"isStageFrame": true
			}
		},
		{
			"c": "Trigger",
			"p": {
				"dataPath": "editor.isSafeAreaVisible",
				"pow": 0.2,
				"damp": 0.7
			},
			":": [
				{
					"c": "__SystemBackDrop",
					"p": {
						"name": "camera-fixed-frame",
						"shapeFillAlpha": 0,
						"shapeLineWidth": 12,
						"shapeLineAlpha": 0.1,
						"isFixedStageFrame": true
					}
				}
			]
		},
		{
			"c": "Trigger",
			"p": {
				"dataPath": "editor.isGizmoVisible",
				"pow": 0.2,
				"damp": 0.7,
				"scaleShift": -1
			},
			":": [
				{
					"c": "___Gizmo",
					"p": {
						"x": -22,
						"y": 6
					},
					":": [
						{
							"c": "Trigger",
							"p": {
								"name": "xy",
								"dataPath": "editor.ui.propsEditor.editableProps.x",
								"pow": 1,
								"damp": 0
							},
							":": [
								{
									"c": "Trigger",
									"p": {
										"name": "xy",
										"dataPath": "editor.ui.propsEditor.editableProps.y",
										"pow": 1,
										"damp": 0
									},
									":": [
										{
											"c": "___GizmoArrow",
											"p": {
												"name": "xy-axis",
												"x": -1,
												"y": -23,
												"interactive": true,
												"width": 24,
												"height": 24,
												"shapeFillAlpha": 0.2,
												"shapeFillColor": 16744193,
												"shapeLineWidth": 1,
												"shapeLineColor": 16744193,
												"shapeLineAlignment": 0,
												"dragX": true,
												"dragY": true
											},
											":": [
												{
													"c": "Shape",
													"p": {
														"name": "snap-xy-guide",
														"y": 23,
														"pivot.x": 400,
														"pivot.y": 1,
														"width": 800,
														"height": 2,
														"shapeFillAlpha": 0.75,
														"shapeFillColor": 16777215
													}
												}
											]
										}
									]
								}
							]
						},
						{
							"c": "Trigger",
							"p": {
								"name": "y",
								"dataPath": "editor.ui.propsEditor.editableProps.y",
								"pow": 1,
								"damp": 0
							},
							":": [
								{
									"c": "___GizmoArrow",
									"p": {
										"name": "y-axis",
										"interactive": true,
										"shape": 4,
										"shapeFillColor": 8308231,
										"shapeLineWidth": 1,
										"shapeLineColor": 292,
										"dragY": true,
										"cursor": "ns-resize",
										"_shapePoints": [
											{
												"x": -1,
												"y": -75
											},
											{
												"x": -4,
												"y": -76
											},
											{
												"x": 0,
												"y": -89
											},
											{
												"x": 4,
												"y": -76
											},
											{
												"x": 1,
												"y": -75
											},
											{
												"x": 1,
												"y": -1
											},
											{
												"x": -1,
												"y": 1
											}
										]
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"x": -5,
												"y": -89,
												"width": 10,
												"height": 73,
												"isItHitArea": true
											}
										}
									]
								}
							]
						},
						{
							"c": "Trigger",
							"p": {
								"name": "x",
								"dataPath": "editor.ui.propsEditor.editableProps.x",
								"pow": 1,
								"damp": 0
							},
							":": [
								{
									"c": "___GizmoArrow",
									"p": {
										"name": "x-axis",
										"rotation": 1.5707963267948966,
										"interactive": true,
										"shape": 4,
										"shapeFillColor": 14758734,
										"shapeLineWidth": 1,
										"shapeLineColor": 292,
										"dragX": true,
										"cursor": "ew-resize",
										"_shapePoints": [
											{
												"x": -1,
												"y": -75
											},
											{
												"x": -4,
												"y": -76
											},
											{
												"x": 0,
												"y": -89
											},
											{
												"x": 4,
												"y": -76
											},
											{
												"x": 1,
												"y": -75
											},
											{
												"x": 1,
												"y": 1
											},
											{
												"x": -1,
												"y": -1
											}
										]
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"x": -5,
												"y": -89,
												"width": 10,
												"height": 73,
												"isItHitArea": true
											}
										}
									]
								}
							]
						},
						{
							"c": "Trigger",
							"p": {
								"name": "rotation",
								"dataPath": "editor.ui.propsEditor.editableProps.rotation",
								"pow": 1,
								"damp": 0
							},
							":": [
								{
									"c": "___GizmoArrow",
									"p": {
										"name": "rotation-gizmo",
										"interactive": true,
										"shape": 2,
										"shapeRadius": 34,
										"shapeFillAlpha": 0.05,
										"shapeFillColor": 11161363,
										"shapeLineWidth": 2,
										"shapeLineColor": 11161363,
										"dragR": true,
										"cursor": "ns-resize"
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"shape": 4,
												"shapeFillAlpha": 0.65,
												"shapeFillColor": 10559777,
												"isItHitArea": true,
												"_shapePoints": [
													{
														"x": -2,
														"y": -39
													},
													{
														"x": 12,
														"y": -36
													},
													{
														"x": 26,
														"y": -29
													},
													{
														"x": 34,
														"y": -18
													},
													{
														"x": 38,
														"y": -2
													},
													{
														"x": 32,
														"y": -2
													},
													{
														"x": 28,
														"y": -16
													},
													{
														"x": 20,
														"y": -26
													},
													{
														"x": 9,
														"y": -31
													},
													{
														"x": -2,
														"y": -32
													},
													{
														"x": -14,
														"y": -30
													},
													{
														"x": -25,
														"y": -21
													},
													{
														"x": -31,
														"y": -9
													},
													{
														"x": -32,
														"y": 4
													},
													{
														"x": -25,
														"y": 21
													},
													{
														"x": -12,
														"y": 30
													},
													{
														"x": 5,
														"y": 32
													},
													{
														"x": 20,
														"y": 26
													},
													{
														"x": 29,
														"y": 16
													},
													{
														"x": 32,
														"y": 2
													},
													{
														"x": 38,
														"y": 2
													},
													{
														"x": 35,
														"y": 17
													},
													{
														"x": 23,
														"y": 31
													},
													{
														"x": 5,
														"y": 39
													},
													{
														"x": -15,
														"y": 36
													},
													{
														"x": -30,
														"y": 25
													},
													{
														"x": -39,
														"y": 9
													},
													{
														"x": -38,
														"y": -12
													},
													{
														"x": -28,
														"y": -26
													},
													{
														"x": -16,
														"y": -35
													}
												]
											}
										},
										{
											"c": "Trigger",
											"p": {
												"dataPath": "this.parent.isDowned"
											},
											":": [
												{
													"c": "Shape",
													"p": {
														"name": "rotation-guide",
														"pivot.x": 400,
														"pivot.y": 1,
														"width": 800,
														"height": 2,
														"shapeFillAlpha": 0.75,
														"shapeFillColor": 16777215,
														"shapeLineWidth": 1,
														"shapeLineColor": 0,
														"shapeLineAlpha": 0.5
													}
												}
											]
										},
										{
											"c": "Trigger",
											"p": {
												"dataPath": "this.parent.isShowAngle"
											},
											":": [
												{
													"c": "Shape",
													"p": {
														"name": "rotation-guide",
														"pivot.x": 1,
														"pivot.y": 1,
														"width": 35,
														"height": 2,
														"shapeFillAlpha": 0.75,
														"shapeFillColor": 16777215,
														"shapeLineWidth": 1,
														"shapeLineColor": 0,
														"shapeLineAlpha": 0.5
													},
													":": [
														{
															"c": "Shape",
															"p": {
																"name": "",
																"x": 14,
																"pivot.y": 1,
																"shape": 4,
																"shapeFillAlpha": 0.75,
																"shapeFillColor": 16777215,
																"_shapePoints": [
																	{
																		"x": 2,
																		"y": 3
																	},
																	{
																		"x": 21,
																		"y": 3
																	},
																	{
																		"x": -1,
																		"y": 11
																	}
																]
															}
														},
														{
															"c": "Shape",
															"p": {
																"name": "",
																"x": 14,
																"pivot.y": 1,
																"shape": 4,
																"shapeFillAlpha": 0.75,
																"shapeFillColor": 16777215,
																"_shapePoints": [
																	{
																		"x": 2,
																		"y": 1
																	},
																	{
																		"x": 21,
																		"y": 1
																	},
																	{
																		"x": -1,
																		"y": -8
																	}
																]
															}
														}
													]
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		}
	]
}
</file>

<file path="src/engine/lib/assets/___system/guide.p.json">
{
	"c": "___Guide",
	"p": {
		"name": "___system/guide",
		"timeline": {
			"l": {
				"refresh": 0
			},
			"p": 0.02,
			"d": 0.85,
			"f": [
				{
					"n": "alpha",
					"t": [
						{
							"v": 1,
							"t": 0,
							"m": 1
						},
						{
							"v": 1,
							"t": 39,
							"m": 1
						},
						{
							"v": 0,
							"t": 46,
							"m": 1,
							"a": "this.remove"
						}
					]
				}
			]
		}
	},
	":": [
		{
			"c": "Shape",
			"p": {
				"x": -512,
				"y": -0.5,
				"width": 1024,
				"height": 1,
				"shapeFillColor": 16777215
			}
		}
	]
}
</file>

<file path="src/engine/lib/assets/___system/rect-guide.p.json">
{
	"c": "___RectGuide",
	"p": {
		"name": "___system/rect-guide",
		"shapeFillAlpha": 0,
		"shapeLineWidth": 1,
		"shapeLineColor": 53546
	}
}
</file>

<file path="src/engine/lib/assets/___system/ruler.p.json">
{
	"c": "___Ruler",
	"p": {
		"name": "___system/ruler",
		"x": 15,
		"y": -13
	},
	":": [
		{
			"c": "__SystemBackDrop",
			"p": {
				"interactive": true,
				"shapeFillAlpha": 0.29
			}
		},
		{
			"c": "Container",
			"p": {
				"name": "start-point"
			},
			":": [
				{
					"c": "Shape",
					"p": {
						"name": "reflected-guide",
						"x": -100,
						"alpha": 0.7,
						"width": 200,
						"height": 56,
						"shapeFillAlpha": 0,
						"shapeLineWidth": 2
					}
				},
				{
					"c": "Shape",
					"p": {
						"name": "guide",
						"alpha": 0.2,
						"height": 28,
						"shapeFillAlpha": 0,
						"shapeLineWidth": 15,
						"shapeLineColor": 0
					}
				},
				{
					"c": "Shape",
					"p": {
						"name": "guide",
						"height": 28,
						"shapeFillAlpha": 0,
						"shapeLineWidth": 2
					}
				},
				{
					"c": "Shape",
					"p": {
						"name": "guide",
						"alpha": 0.6,
						"height": 28,
						"shapeFillAlpha": 0,
						"shapeLineWidth": 5
					}
				},
				{
					"c": "Container",
					"p": {
						"name": "zero-point-view"
					},
					":": [
						{
							"c": "Trigger",
							"p": {
								"visible": false,
								"dataPath": "mouse.gameClick",
								"invert": true,
								"pow": 1,
								"damp": 0
							},
							":": [
								{
									"c": "Shape",
									"p": {
										"alpha": 0.2,
										"shape": 4,
										"shapeFillColor": 16777215,
										"_shapePoints": [
											{
												"x": 0,
												"y": 0
											},
											{
												"x": 10,
												"y": 0
											},
											{
												"x": 10,
												"y": 4
											},
											{
												"x": 7,
												"y": 8
											},
											{
												"x": 2,
												"y": 10
											},
											{
												"x": 0,
												"y": 11
											}
										]
									}
								},
								{
									"c": "Shape",
									"p": {
										"rotation": -3.141592653589793,
										"alpha": 0.2,
										"shape": 4,
										"shapeFillColor": 16777215,
										"_shapePoints": [
											{
												"x": 0,
												"y": 0
											},
											{
												"x": 10,
												"y": 0
											},
											{
												"x": 10,
												"y": 4
											},
											{
												"x": 7,
												"y": 8
											},
											{
												"x": 2,
												"y": 10
											},
											{
												"x": 0,
												"y": 11
											}
										]
									}
								}
							]
						},
						{
							"c": "Trigger",
							"p": {
								"visible": false,
								"dataPath": "mouse.gameClick",
								"pow": 1,
								"damp": 0
							},
							":": [
								{
									"c": "Shape",
									"p": {
										"alpha": 0.2,
										"width": 3000,
										"height": 3000,
										"shapeFillColor": 16777215
									}
								},
								{
									"c": "Shape",
									"p": {
										"rotation": -3.141592653589793,
										"alpha": 0.2,
										"width": 3000,
										"height": 3000,
										"shapeFillColor": 16777215
									}
								}
							]
						},
						{
							"c": "Shape",
							"p": {
								"rotation": -3.141592653589793,
								"shape": 2,
								"shapeFillAlpha": 0,
								"shapeLineWidth": 1
							}
						}
					]
				},
				{
					"c": "Container",
					"p": {
						"name": "start-point-info"
					},
					":": [
						{
							"c": "Container",
							"p": {
								"x": -77,
								"y": -36
							},
							":": [
								{
									"c": "Trigger",
									"p": {
										"x": -50,
										"y": -13,
										"dataPath": "this.parent.parent.parent.parent.startPoint.x",
										"pow": 1,
										"damp": 0
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"x": -14,
												"y": -13,
												"alpha": 0.4,
												"shape": 1,
												"width": 128,
												"height": 28,
												"shapeRadius": 69
											}
										},
										{
											"c": "Label",
											"p": {
												"text": "X: 12",
												"style.fontSize": 32,
												"style.align": "left",
												"maxWidth": 105,
												"dataPath": "this.parent.parent.parent.parent.parent.startPoint.x",
												"refreshInterval": 0,
												"template": "X: %d",
												"isNumeric": true
											}
										}
									]
								},
								{
									"c": "Trigger",
									"p": {
										"x": -50,
										"y": 16,
										"dataPath": "this.parent.parent.parent.parent.startPoint.y",
										"pow": 1,
										"damp": 0
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"x": -14,
												"y": -14,
												"alpha": 0.4,
												"shape": 1,
												"width": 128,
												"height": 28,
												"shapeRadius": 69
											}
										},
										{
											"c": "Label",
											"p": {
												"text": "Y: 12",
												"style.fontSize": 32,
												"style.align": "left",
												"maxWidth": 105,
												"dataPath": "this.parent.parent.parent.parent.parent.startPoint.y",
												"refreshInterval": 0,
												"template": "Y: %d",
												"isNumeric": true
											}
										}
									]
								}
							]
						}
					]
				},
				{
					"c": "Container",
					"p": {
						"name": "size-info",
						"x": 99,
						"y": 27
					},
					":": [
						{
							"c": "Container",
							"p": {
								"x": 70,
								"y": 32
							},
							":": [
								{
									"c": "Trigger",
									"p": {
										"x": -50,
										"y": -13,
										"dataPath": "this.parent.parent.parent.parent.W",
										"pow": 1,
										"damp": 0
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"x": -14,
												"y": -13,
												"alpha": 0.4,
												"shape": 1,
												"width": 128,
												"height": 28,
												"shapeRadius": 69
											}
										},
										{
											"c": "Label",
											"p": {
												"text": "W: 12",
												"style.fontSize": 32,
												"style.align": "left",
												"maxWidth": 105,
												"dataPath": "this.parent.parent.parent.parent.parent.W",
												"refreshInterval": 0,
												"template": "W: %d",
												"isNumeric": true
											}
										}
									]
								},
								{
									"c": "Trigger",
									"p": {
										"x": -50,
										"y": 16,
										"dataPath": "this.parent.parent.parent.parent.H",
										"pow": 1,
										"damp": 0
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"x": -14,
												"y": -14,
												"alpha": 0.4,
												"shape": 1,
												"width": 128,
												"height": 28,
												"shapeRadius": 69
											}
										},
										{
											"c": "Label",
											"p": {
												"text": "H: 12",
												"style.fontSize": 32,
												"style.align": "left",
												"maxWidth": 105,
												"dataPath": "this.parent.parent.parent.parent.parent.H",
												"refreshInterval": 0,
												"template": "H: %d",
												"isNumeric": true
											}
										}
									]
								}
							]
						},
						{
							"c": "Shape",
							"p": {
								"name": "size-info-rect",
								"x": 3,
								"y": 3,
								"alpha": 0,
								"width": 134,
								"height": 61,
								"shapeFillColor": 16711680
							}
						}
					]
				}
			]
		}
	]
}
</file>

<file path="src/engine/lib/assets/___system/scene-linked-promise.c.ts">
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import { getCurrentStack, showStack } from 'thing-editor/src/editor/utils/stack-utils';
import assert from 'thing-editor/src/engine/debug/assert';
import game, { PRELOADER_SCENE_NAME } from 'thing-editor/src/engine/game';
import { constructRecursive } from 'thing-editor/src/engine/lib';
import Pool from 'thing-editor/src/engine/utils/pool';

const EMPTY_RESULT_SYMBOL = {};
let promiseIDCounter = 0;

/**
	### single promise
```
	SceneLinkedPromise.promise((resolve, reject, promise) => {
		resolve(data);
	}, owner).then((data) => {

	}).catch((error) => {

	}).finally(() => {

	});
```
	### list of promises
```
	SceneLinkedPromise.all([promise, promise], owner). then((dataArray) => {

	});
```
### resolved promise
```
	SceneLinkedPromise.resolve(result);
```
*/

export default class SceneLinkedPromise extends Container {

	static promise(handler: (resolve: (result: any) => void, reject: (result: any) => void, promise?: SceneLinkedPromise) => void, container?: Container) {
		assert(!game.__EDITOR_mode, 'Attempt to create SceneLinkedPromise.promise() in editing mode.', 10057);
		if (!container) {
			container = game.currentContainer || game.currentFader;
		}
		let promise = Pool.create(SceneLinkedPromise);
		/// #if EDITOR
		constructRecursive(promise);
		/// #endif
		container.addChild(promise);
		if (container === game.currentFader || ((container === game.currentScene) && (container.name === PRELOADER_SCENE_NAME))) {
			promise.loadingAdded = true;
			game.loadingAdd(promise);
		} else {
			promise.loadingAdded = false;
		}
		/// #if EDITOR
		promise.throttlingDelay = Math.round(Math.random() * 15);
		promise.name = 'Promise: ' + (handler.name || 'anonymous function');
		promise.___stack = getCurrentStack('SceneLinkedPromise');
		/// #endif
		promise._promiseWaitForResult = true;
		let promiseId = promiseIDCounter++;
		promise._promiseId = promiseId;

		handler(
			(data) => {
				if (promise._promiseId === promiseId) {
					promise.resolve(data);
				}
			},
			(error) => {
				if (promise._promiseId === promiseId) {
					assert(promise._promiseResultWaiting === EMPTY_RESULT_SYMBOL, 'SceneLinkedPromise is resolved already.', 10058);
					assert(promise._promiseErrorWaiting === EMPTY_RESULT_SYMBOL, 'SceneLinkedPromise is rejected already.', 10059);
					assert(promise._rejectHandlers.length, 'Unhandled SceneLinkedPromise rejection.', 99999);
					promise._promiseErrorWaiting = error;
				}
			}, promise);

		return promise;
	}

	static resolve(data: any, container?: Container) {
		return SceneLinkedPromise.promise((r) => {
			r(data);
		}, container);
	}

	static all(promises: SceneLinkedPromise[], container = game.currentContainer) {
		let results: any[] | null = [];
		let count = promises.length;
		return SceneLinkedPromise.promise((resolve: (result: any) => void, reject?: (result: any) => void, promise?: SceneLinkedPromise) => {
			promises.forEach((p, i) => {
				assert(p instanceof SceneLinkedPromise, 'SceneLinkedPromise expected', 10060);
				promise!.addChild(p);
				p.then((data: any) => {
					results![i] = data;
				});
				p.catch((error: any) => {
					results = [];
					results[i] = error;
					reject!(results);
					results = null;
				});
				p.finally(() => {
					assert(count > 0, 'SceneLinkedPromise.all has more resolves that expected.');
					count--;
					if (count === 0) {
						if (results) {
							resolve(results);
						}
					}
				});
			});

		}, container);
	}


	@editable({ name: '___stack', type: 'ref', onClick: showStack })

	_promiseWaitForResult = false;
	_promiseId = -1;

	_rejectHandlers: ((result?: any) => any)[] = [];
	_resolveHandlers: ((result?: any) => any)[] = [];
	_finallyHandlers: ((result?: any) => any)[] = [];

	visible = false;
	_promiseResultWaiting = EMPTY_RESULT_SYMBOL;
	_promiseErrorWaiting = EMPTY_RESULT_SYMBOL;

	loadingAdded = false;

	/// #if EDITOR
	throttlingDelay = 0;
	/// #endif

	/// #if DEBUG
	___stack: any;
	__passedHandlersDebug: { handler: ((result?: any) => any); currentResult: any }[] = [];
	/// #endif

	onRemove() {
		super.onRemove();
		/// #if EDITOR
		if (!game.__EDITOR_mode && !EDITOR_FLAGS.isStoppingTime) {
			if (this._promiseWaitForResult) {
				game.editor.ui.status.warn('SceneLinkedPromise was removed before its resolved or rejected.', 10061, this, undefined, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
			}
		}
		/// #endif

		if (this._promiseWaitForResult) {
			this._promiseWaitForResult = false;
			this._handleFinally();
		}

		this._promiseId = -1;
		this._rejectHandlers.length = 0;
		this._resolveHandlers.length = 0;
		this._finallyHandlers.length = 0;
		this._promiseResultWaiting = EMPTY_RESULT_SYMBOL;
		this._promiseErrorWaiting = EMPTY_RESULT_SYMBOL;
	}

	resolve(data: any) {
		assert(this._promiseResultWaiting === EMPTY_RESULT_SYMBOL, 'SceneLinkedPromise is resolved already.', 10058);
		assert(this._promiseErrorWaiting === EMPTY_RESULT_SYMBOL, 'SceneLinkedPromise is rejected already.', 10059);
		this._promiseResultWaiting = data;
	}

	then(handler: (result: any) => any) {
		assert(this._promiseWaitForResult, 'Promise is already finished.', 10073);
		this._resolveHandlers.push(handler);
		return this;
	}

	catch(handler: (result: any) => any) {
		assert(this._promiseWaitForResult, 'Promise is already finished.', 10073);
		this._rejectHandlers.push(handler);
		return this;
	}

	finally(handler: (result: any) => any) {
		assert(this._promiseWaitForResult, 'Promise is already finished.', 10073);
		this._finallyHandlers.push(handler);
		return this;
	}

	constructor() {
		super();
		assert(arguments.length === 0, 'Please use SceneLinkedPromise.promise((resolve, reject) => {}), instead of \'new SceneLinkedPromise\'');
	}

	_handleFinally() {
		/// #if DEBUG
		let id = this._promiseId;
		let errorTimeout = window.setTimeout(() => {
			if (id === this._promiseId) {
				this._turnPromiseRejected('Exception in SceneLinkedPromise finally handler.');
			}
			game._reanimateTicker();
		});

		/// #endif
		while (this._finallyHandlers.length > 0) {
			/// #if DEBUG
			(this._finallyHandlers.shift()!)();
			continue;
			/// #endif

			try { // eslint-disable-line no-unreachable
				(this._finallyHandlers.shift()!)();
			} catch (err) { // eslint-disable-line no-empty
				window.setTimeout(() => {
					throw (err);
				}, 0);
				this._turnPromiseRejected(err); // eslint-disable-line no-unreachable
				return;
			}
		}
		/// #if DEBUG
		clearTimeout(errorTimeout);
		/// #endif
		this._promiseWaitForResult = false;
		if (this.loadingAdded) {
			game.loadingRemove(this);
			this.loadingAdded = false;
		}
	}

	_turnPromiseRejected(err: any) {
		if (this._promiseErrorWaiting === EMPTY_RESULT_SYMBOL) {
			this._resolveHandlers.length = 0;
			this._promiseResultWaiting = EMPTY_RESULT_SYMBOL;
			this._promiseErrorWaiting = err;
		}
	}

	/// #if EDITOR
	static __canAcceptParent(_parent: Container) {
		return false;
	}
	/// #endif

	update() {
		/// #if EDITOR
		if (this.throttlingDelay > 0) {
			this.throttlingDelay--;
			return;
		}
		/// #endif

		if (this._promiseErrorWaiting !== EMPTY_RESULT_SYMBOL) {
			let r = this._promiseErrorWaiting;
			/// #if DEBUG
			this.__passedHandlersDebug = [];

			/// #endif
			if (this._rejectHandlers.length === 0) {
				window.setTimeout(() => {
					console.error('SceneLinkedPromise unhandled rejection.');
					throw r;
				}, 0);
			}
			while (this._rejectHandlers.length > 0) {
				/// #if DEBUG

				let handler = this._rejectHandlers.shift()!;
				let currentResult = handler(r);
				this.__passedHandlersDebug.push({ handler, currentResult });
				if (typeof currentResult !== 'undefined') {
					r = currentResult;
				}
				continue;
				/// #endif

				try { // eslint-disable-line no-unreachable
					let currentResult = (this._rejectHandlers.shift()!)(r);
					if (typeof currentResult !== 'undefined') {
						r = currentResult;
					}
				} catch (err) { // eslint-disable-line no-empty
					if (this._rejectHandlers.length === 0) {
						window.setTimeout(() => {
							throw (err);
						}, 0);
					}
				}
			}
			this._handleFinally();
		} else if (this._promiseResultWaiting !== EMPTY_RESULT_SYMBOL) {

			let r = this._promiseResultWaiting;
			/// #if DEBUG
			this.__passedHandlersDebug = [];

			let id = this._promiseId;
			let errorTimeout = window.setTimeout(() => {
				if (id === this._promiseId) {
					this._turnPromiseRejected('Exception in SceneLinkedPromise handler.');
				}
				game._reanimateTicker();
			});

			/// #endif
			while (this._resolveHandlers.length > 0) {
				/// #if DEBUG
				let handler = this._resolveHandlers.shift()!; //in debug build no catch errors to
				let currentResult = handler(r);
				this.__passedHandlersDebug.push({ handler, currentResult });
				if (typeof currentResult !== 'undefined') {
					r = currentResult;
				}
				continue;
				/// #endif

				try { // eslint-disable-line no-unreachable
					let currentResult = (this._resolveHandlers.shift()!)(r);
					if (typeof currentResult !== 'undefined') {
						r = currentResult;
					}
				} catch (err) { // eslint-disable-line no-empty
					if (this._rejectHandlers.length === 0) {
						window.setTimeout(() => {
							throw (err);
						}, 0);
					}

					this._turnPromiseRejected(err); // eslint-disable-line no-unreachable
					return;
				}
			}
			/// #if DEBUG
			clearTimeout(errorTimeout);
			/// #endif

			this._handleFinally();
		}

		super.update();
		if (!this._promiseWaitForResult) {
			this.remove();
		}
	}
}

/// #if EDITOR
SceneLinkedPromise.__EDITOR_icon = 'tree/promise';
/// #endif
</file>

<file path="src/engine/lib/assets/___system/unknown-prefab.p.json">
{
	"c": "Container",
	"p": {
		"name": "___system/unknown-prefab"
	},
	":": [
		{
			"c": "Shape",
			"p": {
				"x": -60,
				"y": -40,
				"width": 120,
				"height": 80,
				"shapeFillColor": 11537420,
				"shapeLineWidth": 2
			}
		},
		{
			"c": "Text",
			"p": {
				"text": "Unknown\nprefab\nreference"
			}
		}
	]
}
</file>

<file path="src/engine/lib/assets/fader/default.p.json">
{
	"c": "Container",
	"p": {
		"name": "fader/default",
		"__prefabPivot": "left-top"
	},
	":": [
		{
			"c": "MovieClip",
			"p": {
				"tint": 0,
				"timeline": {
					"l": {
						"hide fader": 120
					},
					"p": 0.02,
					"d": 0.85,
					"f": [
						{
							"n": "alpha",
							"t": [
								{
									"v": 0,
									"t": 0,
									"m": 1
								},
								{
									"v": 1,
									"t": 11,
									"m": 1,
									"a": "faderShoot"
								},
								{
									"v": 1,
									"t": 69,
									"m": 1,
									"a": "this.stop"
								},
								{
									"v": 1,
									"t": 122,
									"m": 1
								},
								{
									"v": 0,
									"t": 131,
									"m": 1,
									"a": "faderEnd"
								}
							]
						}
					]
				},
				"__previewFrame": 8,
				"alpha": 0
			},
			":": [
				{
					"c": "BackDrop",
					"p": {}
				}
			]
		}
	]
}
</file>

<file path="src/engine/lib/assets/final-fader.p.json">
{
	"c": "MovieClip",
	"p": {
		"name": "final-fader",
		"alpha": 0,
		"__prefabPivot": "left-top",
		"timeline": {
			"l": {},
			"p": 0.02,
			"d": 0.85,
			"f": [
				{
					"n": "alpha",
					"t": [
						{
							"v": 0,
							"t": 0,
							"m": 1
						},
						{
							"v": 1,
							"t": 6,
							"m": 1,
							"a": "this.stop"
						}
					]
				}
			]
		}
	},
	":": [
		{
			"c": "BackDrop",
			"p": {}
		}
	]
}
</file>

<file path="src/engine/lib/assets/index.html">
<!DOCTYPE html>
<html>
<head>
<style>
    html {
        height: 100%;
        margin: 0;
        padding: 0;
    }

    body {
        background:#000000;
        color: #ffffff;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: 0;
        padding: 0;
        overflow: visible;
        width: 100%;
        height: 100vh;
    }

    canvas {
        position: fixed;
    }
</style>
<meta content='user-scalable=no, width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, viewport-fit=cover' name='viewport'>
<meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<script src="%__project-assets-dir__%/src/index.ts" type="module"></script>
</body>
</html>
</file>

<file path="src/engine/lib/assets/particle-green.p.json">
{
	"c": "ParticleShort",
	"p": {
		"name": "particle-green",
		"image": "WHITE",
		"tint": 65280
	}
}
</file>

<file path="src/engine/lib/assets/preloader.s.json">
{
	"c": "Scene",
	"p": {
		"name": "preloader",
		"backgroundColor": 1052690
	},
	":": [
		{
			"c": "Resizer",
			"p": {
				"relativeX": true,
				"xPos": 0.5,
				"relativeY": true,
				"yPos": 0.5
			},
			":": [
				{
					"c": "Text",
					"p": {
						"x": 17,
						"y": -30,
						"text": "L O A D I N G . . .",
						"style.fontSize": 51,
						"style.fontWeight": "lighter"
					}
				},
				{
					"c": "Trigger",
					"p": {
						"name": "loaderShow",
						"x": 1,
						"y": 169,
						"state": true
					},
					":": [
						{
							"c": "ProgressBar",
							"p": {
								"x": -151,
								"y": 39,
								"rotation": -1.5707963267948966,
								"dataPath": "loadingProgress",
								"height": 300,
								"capMargin": 0,
								"refreshInterval": 0,
								"onFinish": "this.parent.toggle",
								"onChanged": "",
								"smooth": true,
								"smoothStep": 0.1
							},
							":": [
								{
									"c": "Sprite",
									"p": {
										"name": "bg",
										"alpha": 0.5,
										"interactive": true,
										"scale.y": 18.75,
										"image": "WHITE"
									}
								},
								{
									"c": "Sprite",
									"p": {
										"name": "bar",
										"interactive": true,
										"scale.y": 7.5600000000000005,
										"image": "WHITE",
										"tint": 65280
									}
								},
								{
									"c": "Container",
									"p": {
										"name": "cap",
										"x": 8,
										"interactive": true,
										"scale.x": 2,
										"scale.y": 2
									},
									":": [
										{
											"c": "Spawner",
											"p": {
												"x": -2,
												"prefabToSpawn": "particle-green",
												"speed": 0,
												"speedRandom": 1,
												"container": ""
											}
										}
									]
								}
							]
						},
						{
							"c": "MovieClip",
							"p": {
								"x": -77,
								"y": -83,
								"image": "WHITE",
								"timeline": {
									"l": {},
									"p": 0.02,
									"d": 0.85,
									"f": [
										{
											"n": "scale.x",
											"t": [
												{
													"v": 2,
													"t": 0
												},
												{
													"v": 0.5,
													"t": 15
												},
												{
													"v": 2,
													"t": 30,
													"j": 0
												}
											]
										},
										{
											"n": "scale.y",
											"t": [
												{
													"v": 2,
													"t": 0
												},
												{
													"v": 0.5,
													"t": 15
												},
												{
													"v": 2,
													"t": 30,
													"j": 0
												}
											]
										}
									]
								}
							}
						},
						{
							"c": "MovieClip",
							"p": {
								"y": -83,
								"image": "WHITE",
								"timeline": {
									"l": {},
									"p": 0.02,
									"d": 0.85,
									"f": [
										{
											"n": "scale.x",
											"t": [
												{
													"v": 2,
													"t": 0
												},
												{
													"v": 0.5,
													"t": 15
												},
												{
													"v": 2,
													"t": 30,
													"j": 0
												}
											]
										},
										{
											"n": "scale.y",
											"t": [
												{
													"v": 2,
													"t": 0
												},
												{
													"v": 0.5,
													"t": 15
												},
												{
													"v": 2,
													"t": 30,
													"j": 0
												}
											]
										}
									]
								},
								"delay": 5
							}
						},
						{
							"c": "MovieClip",
							"p": {
								"x": 77,
								"y": -83,
								"image": "WHITE",
								"timeline": {
									"l": {},
									"p": 0.02,
									"d": 0.85,
									"f": [
										{
											"n": "scale.x",
											"t": [
												{
													"v": 2,
													"t": 0
												},
												{
													"v": 0.5,
													"t": 15
												},
												{
													"v": 2,
													"t": 30,
													"j": 0
												}
											]
										},
										{
											"n": "scale.y",
											"t": [
												{
													"v": 2,
													"t": 0
												},
												{
													"v": 0.5,
													"t": 15
												},
												{
													"v": 2,
													"t": 30,
													"j": 0
												}
											]
										}
									]
								},
								"delay": 10
							}
						}
					]
				},
				{
					"c": "Trigger",
					"p": {
						"dataPath": "all.loaderShow.state",
						"invert": true
					},
					":": [
						{
							"c": "Button",
							"p": {
								"name": "play-button",
								"y": 155,
								"onClick": [
									"replaceScene"
								],
								"sndClick": "click"
							},
							":": [
								{
									"c": "Shape",
									"p": {
										"x": -0.05660000000000309,
										"y": -1,
										"shape": 2,
										"shapeRadius": 46,
										"shapeFillColor": 12065049
									},
									":": [
										{
											"c": "MovieClip",
											"p": {
												"timeline": {
													"l": {},
													"p": 0.02,
													"d": 0.85,
													"f": [
														{
															"n": "x",
															"t": [
																{
																	"v": 0,
																	"t": 0
																},
																{
																	"v": -5,
																	"t": 18
																},
																{
																	"v": 0,
																	"t": 39
																},
																{
																	"v": -5,
																	"t": 61
																},
																{
																	"v": 0,
																	"t": 251,
																	"j": 0
																}
															]
														}
													]
												}
											},
											":": [
												{
													"c": "Shape",
													"p": {
														"x": -2,
														"y": -1,
														"shape": 4,
														"shapeFillColor": 16777215,
														"_shapePoints": [
															{
																"x": -10,
																"y": -26
															},
															{
																"x": 30,
																"y": 0
															},
															{
																"x": -10,
																"y": 30
															}
														]
													}
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		}
	]
}
</file>

<file path="src/engine/lib/assets/src/___system/___rect-guide.c.ts">
import type { Renderer } from 'pixi.js';
import { Point } from 'pixi.js';
import overlayLayer from 'thing-editor/src/editor/ui/editor-overlay';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';
import Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';

const p = new Point();
const p2 = new Point();

export default class ___RectGuide extends Shape {

	owner!: Container;
	rect!: EditableRect;
	field!: EditablePropertyDesc;
	rectKey!: string;

	render(renderer: Renderer): void {
		if (!this.owner) {
			super.render(renderer);
			return;
		} else if (!this.isShouldBeRemoved()) {

			this.rotation = this.owner.parent.getGlobalRotation();
			this.shapeLineColor = this.field.guideColor || 53546;
			p.x = this.rect.x + this.owner.pivot.x;
			p.y = this.rect.y + this.owner.pivot.y;

			this.parent.toLocal(p, this.owner, this);

			p.x += this.rect.w;
			p.y += this.rect.h;
			let tmpX = this.owner.scale.x;
			let tmpY = this.owner.scale.y;
			if (this.field.rectScaleIgnore) {
				this.owner.scale.x = this.owner.scale.y = 1;
			}
			this.toLocal(p, this.owner, p2);
			if (this.field.rectScaleIgnore) {
				this.owner.scale.x = tmpX;
				this.owner.scale.y = tmpY;
			}
			this.width = p2.x;
			this.height = p2.y;
			this.shapeLineWidth = Math.ceil(game.editor.ui.viewport.viewportScale);
			this.updateTransform();
			super.render(renderer);
		}
	}

	isShouldBeRemoved() {
		if (!this.owner.__nodeExtendData || (this.owner.__nodeExtendData as KeyedObject)[this.rectKey] !== this) {
			return true;
		}
		if (!this.owner.__nodeExtendData.isSelected || (this.owner as KeyedObject)[this.field.name] !== this.rect) {
			delete (this.owner.__nodeExtendData as KeyedObject)[this.rectKey];
			return true;
		}
	}

	update(): void {
		if (this.isShouldBeRemoved()) {
			this.owner = null!;
			this.__nodeExtendData.constructorCalled = false;
			this.remove();
		} else {
			this.visible = (!this.field.visible) || this.field.visible(this.owner);
			super.update();
		}
	}

	static show(owner: Container, field: EditablePropertyDesc, rect: EditableRect) {
		let rectGuide: ___RectGuide;
		const rectKey = '___rectangleRef_' + field.name;
		if (!owner.__nodeExtendData.hasOwnProperty(rectKey)) {
			rectGuide = Lib.loadPrefab('___system/rect-guide') as ___RectGuide;
			rectGuide.owner = owner;
			rectGuide.rect = rect;
			rectGuide.field = field;
			rectGuide.rectKey = rectKey;
			(owner.__nodeExtendData as KeyedObject)[rectKey] = rectGuide;
			overlayLayer.addChild(rectGuide);
		}
	}
}
</file>

<file path="src/engine/lib/assets/src/___system/backdrop.c.ts">
import type { Renderer } from 'pixi.js';
import { Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { PREFAB_PIVOT } from 'thing-editor/src/editor/ui/viewport';
import PrefabEditor from 'thing-editor/src/editor/utils/prefab-editor';
import game from 'thing-editor/src/engine/game';
import Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';

const zeroPoint = new Point();
const p = new Point();

export default class __SystemBackDrop extends Shape {

	@editable()
	isStageFrame = false;

	@editable()
	isFixedStageFrame = false;

	@editable({ name: 'x', notSerializable: true, override: true, disabled: () => true })
	@editable({ name: 'y', notSerializable: true, override: true, disabled: () => true })
	@editable({ name: 'width', notSerializable: true, override: true, disabled: () => true })
	@editable({ name: 'height', notSerializable: true, override: true, disabled: () => true })

	render(renderer: Renderer): void {

		if (this.isFixedStageFrame) { // safe frame
			this.parent.toLocal(zeroPoint, game.stage, this, false);
			this.width = (game.isPortrait ? game.projectDesc.portraitWidth : game.projectDesc.width) * game.stage.scale.x;
			this.height = (game.isPortrait ? game.projectDesc.portraitHeight : game.projectDesc.height) * game.stage.scale.y;
			if (PrefabEditor.currentPrefabName) {
				this.x -= (game.W * game.stage.scale.x) / 2;
				this.y -= (game.H * game.stage.scale.x) / 2;
			}
			this.x += (game.W * game.stage.scale.x - this.width) / 2;
			this.y += (game.H * game.stage.scale.y - this.height) / 2;
		} else if (this.isStageFrame) { //screen frame
			this.parent.toLocal(zeroPoint, game.stage, this, false);
			this.width = game.W * game.stage.scale.x;
			this.height = game.H * game.stage.scale.y;
			if (PrefabEditor.currentPrefabName) {
				this.x -= this.width / 2;
				this.y -= this.height / 2;
			}
		} else { //prefab editor back drop
			this.parent.toLocal(zeroPoint, game.stage.parent, this, false);
			p.x = game.W;
			p.y = game.H;
			this.toLocal(p, game.stage.parent, p, false);
			this.width = p.x;
			this.height = p.y;

		}
		if (PrefabEditor.currentPrefabName && (this.isFixedStageFrame || this.isStageFrame)) {
			switch (PrefabEditor.pivot) {
			case PREFAB_PIVOT.LEFT_TOP:
				this.x += game.W / 2 * game.stage.scale.x;
				this.y += game.H / 2 * game.stage.scale.x;
				break;
			}
		}

		this.updateTransform();
		super.render(renderer);
	}
}
</file>

<file path="src/engine/lib/assets/src/___system/gizmo-arrow.c.ts">
import type { Container, FederatedPointerEvent } from 'pixi.js';
import { Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { stopRightButtonMoving } from 'thing-editor/src/editor/ui/editor-overlay';
import StatusBar from 'thing-editor/src/editor/ui/status-bar';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import game from 'thing-editor/src/engine/game';
import ___Gizmo from 'thing-editor/src/engine/lib/assets/src/___system/gizmo.c';
import Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';

let startObjectXShift = 0;
let startObjectYShift = 0;

let startMouseX = 0;
let startMouseY = 0;

let startObjectRotation = 0;

let invertedY = false;

const mouseHandlerGlobalUp = () => {
	if (___GizmoArrow.draggedArrow) {
		___GizmoArrow.draggedArrow.stopDragging();
	}
};

const p = new Point();

const mouseHandlerGlobalMove = (ev: PointerEvent) => {
	if (___GizmoArrow.draggedArrow && (!game.mouse.click || !game.editor.selection.length)) {
		___GizmoArrow.draggedArrow.stopDragging();
	}
	if (___GizmoArrow.draggedArrow) {

		const gizmo = ___GizmoArrow.draggedArrow.findParentByType(___Gizmo)!;

		if (___GizmoArrow.draggedArrow.dragX && ___GizmoArrow.draggedArrow.dragY && ev.shiftKey) {
			const dx = game.__mouse_uncropped.x - startMouseX;
			const dy = game.__mouse_uncropped.y - startMouseY;
			let angle = Math.atan2(dy, dx);
			let len = Math.sqrt(dx * dx + dy * dy);
			angle = Math.round((angle - gizmo.rotation) / (Math.PI / 4)) * (Math.PI / 4) + gizmo.rotation;
			p.x = startMouseX + Math.cos(angle) * len + startObjectXShift;
			p.y = startMouseY + Math.sin(angle) * len + startObjectYShift;
			___GizmoArrow.draggedArrow.snapGuide!.visible = true;
			___GizmoArrow.draggedArrow.snapGuide!.rotation = angle - gizmo.rotation;

		} else if (___GizmoArrow.draggedArrow.dragX || ___GizmoArrow.draggedArrow.dragY) {
			const dx = game.__mouse_uncropped.x - startMouseX;
			const dy = game.__mouse_uncropped.y - startMouseY;
			let angle = Math.atan2(dy, dx);
			let len = Math.sqrt(dx * dx + dy * dy);
			if (!___GizmoArrow.draggedArrow.dragY) {
				len *= Math.abs(Math.cos(angle - gizmo.rotation));
				angle = Math.round((angle - gizmo.rotation) / Math.PI) * Math.PI + gizmo.rotation;
			} else if (!___GizmoArrow.draggedArrow.dragX) {
				len *= Math.abs(Math.sin(angle - gizmo.rotation));
				angle = Math.round((angle - gizmo.rotation - Math.PI / 2) / Math.PI) * Math.PI + gizmo.rotation + Math.PI / 2;
			}
			p.x = startMouseX + Math.cos(angle) * len + startObjectXShift;
			p.y = startMouseY + Math.sin(angle) * len + startObjectYShift;
		}

		if (___GizmoArrow.draggedArrow.dragX || ___GizmoArrow.draggedArrow.dragY) {
			gizmo?.moveXY(p, (ev.ctrlKey || ev.metaKey));
		}

		if (___GizmoArrow.draggedArrow.dragR) {
			let targetFullShift = (game.__mouse_uncropped.y - startMouseY) / -50;
			if (invertedY) {
				targetFullShift *= -1;
			}
			targetFullShift += startObjectRotation;
			if (ev.shiftKey) {
				targetFullShift = Math.round(targetFullShift / Math.PI * 8) * Math.PI / 8;
			}
			const dY = targetFullShift - game.editor.selection[0].rotation;
			game.editor.editProperty('rotation', dY, true);
		}
	}
};

window.addEventListener('pointermove', mouseHandlerGlobalMove);
window.addEventListener('pointerup', mouseHandlerGlobalUp);

export default class ___GizmoArrow extends Shape {

	static overedArrow?: ___GizmoArrow;
	static draggedArrow?: ___GizmoArrow;

	@editable()
	dragX = false;

	@editable()
	dragY = false;

	@editable()
	dragR = false;

	@editable()
	cursor = 'move';

	isDowned = false;

	baseColor = 0;
	baseLineColor = 0;

	snapGuide?: Container;


	init() {
		super.init();
		this.on('pointerover', this.onPointerOver);
		this.on('pointerleave', this.onPointerOut);
		this.on('pointerdown', this.onPointerDown);
		this.baseColor = this.shapeFillColor;
		this.baseLineColor = this.shapeLineColor;
		this.snapGuide = this.findChildByName('snap-xy-guide');
		if (this.snapGuide) {
			this.snapGuide.visible = false;
		}
	}

	get isShowAngle() {
		return game.editor.selection.length && game.editor.selection[0].rotation !== 0;
	}

	onPointerOver() {
		if (!___GizmoArrow.draggedArrow) {
			StatusBar.addStatus('Alt + drag to clone object', 'gizmo-alt');
			if (this.dragR && this.isShowAngle) {
				StatusBar.addStatus('Right click to reset rotation', 'gizmo-right-click');
			}
			___GizmoArrow.overedArrow = this;
			this.shapeFillColor = 0xffff00;
			this.shapeLineColor = 0xffff00;
		}
	}

	onSelectionChange() {
		if (!game.__EDITOR_mode) {
			this.interactive = false; // pass first click to the game object.
			if (___GizmoArrow.overedArrow === this) {
				this.onPointerOut();
			}
		}
	}

	update(): void {
		super.update();
		if (!this.interactive) {
			this.interactive = !game.mouse.click;
		}
		if (___GizmoArrow.overedArrow === this && ((this.worldAlpha < 0.8) || !this.worldVisible)) {
			this.onPointerOut();
		}
	}

	onPointerOut() {
		___GizmoArrow.overedArrow = undefined;
		this._refreshColor();
		StatusBar.removeStatus('gizmo-alt');
		if (this.dragR) {
			StatusBar.removeStatus('gizmo-right-click');
		}
	}

	onPointerDown(ev: FederatedPointerEvent) {
		if (!game.editor.selection.length) {
			return;
		}
		if (ev.buttons === 1) {

			invertedY = this.dragR && game.__mouse_uncropped.x > game.editor.selection[0].worldTransform.tx;

			startMouseX = game.__mouse_uncropped.x;
			startMouseY = game.__mouse_uncropped.y;

			game.stage.toLocal(game.editor.selection[0], game.editor.selection[0].parent, p);

			startObjectXShift = p.x - game.__mouse_uncropped.x;
			startObjectYShift = p.y - game.__mouse_uncropped.y;

			startObjectRotation = game.editor.selection[0].rotation;

			if (ev.altKey) {
				editorUtils.clone();
			}

			if (this.dragX && this.dragY) {
				StatusBar.addStatus('Shift - to snap direction', 'gizmo', 1);
			} else if (this.dragR) {
				StatusBar.addStatus('Shift - to snap angle', 'gizmo', 1);
			}

			___GizmoArrow.draggedArrow = this;
			this.isDowned = true;
		} else if (ev.buttons === 2 && this.dragR) {
			game.editor.editProperty('rotation', 0);
			stopRightButtonMoving();
		}
	}

	stopDragging() {
		___GizmoArrow.draggedArrow = undefined;
		if (this.snapGuide) {
			this.snapGuide.visible = false;
		}

		StatusBar.removeStatus('gizmo');

		this.isDowned = false;
		this._refreshColor();
	}

	_refreshColor() {
		if (___GizmoArrow.overedArrow !== this && ___GizmoArrow.draggedArrow !== this) {
			this.shapeFillColor = this.baseColor;
			this.shapeLineColor = this.baseLineColor;
		}
	}
}
</file>

<file path="src/engine/lib/assets/src/___system/gizmo.c.ts">
import type { Point } from 'pixi.js';
import { Container } from 'pixi.js';
import { moveSelectionToGlobalPoint } from 'thing-editor/src/editor/ui/editor-overlay';
import game from 'thing-editor/src/engine/game';
import ___GizmoArrow from 'thing-editor/src/engine/lib/assets/src/___system/gizmo-arrow.c';

let lastSelected: Container | null;

export default class ___Gizmo extends Container {

	rotationGuides!: Container[];

	init() {
		super.init();
		this.rotationGuides = this.findChildrenByName('rotation-guide') as Container[];

	}

	moveXY(p: Point, withoutChildren = false) {
		moveSelectionToGlobalPoint(p, withoutChildren);
	}

	update(): void {
		super.update();
		if (!game.mouse.click) {
			this.interactiveChildren = true;
		}
		let selected = game.editor.selection[0];
		if (selected !== lastSelected) {
			this.interactiveChildren = false;
			const a = this.findChildrenByType(___GizmoArrow);
			for (const g of a) {
				g.onSelectionChange();
			}
		}
		if (selected) {
			this.visible = true;
			try {
				this.parent.toLocal(selected, selected.parent, this);

				this.rotation = selected.parent.getGlobalRotation();
				for (const guide of this.rotationGuides) {
					guide.rotation = selected.rotation;
				}
				this.scale.x = this.scale.y = game.editor.ui.viewport.viewportScale;
			} catch (_er) {
				this.visible = false;
			}
		} else {
			this.visible = false;
		}
		lastSelected = selected;
	}
}
</file>

<file path="src/engine/lib/assets/src/___system/guide.c.ts">
import type { Container } from 'pixi.js';
import { Point } from 'pixi.js';
import overlayLayer from 'thing-editor/src/editor/ui/editor-overlay';
import Lib from 'thing-editor/src/engine/lib';
import MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';

const all: Map<string, ___Guide> = new Map();

const p = new Point();

export default class ___Guide extends MovieClip {

	id?: string;

	remove() {
		all.delete(this.id!);
		Lib.destroyObjectAndChildren(this);
	}

	refresh(x: number, y: number, rotation: number, owner: Container) {
		p.x = x;
		p.y = y;
		this.parent.toLocal(p, owner, this);
		this.rotation = owner.getGlobalRotation() + rotation;
		this.gotoLabelRecursive('refresh');
	}

	static hide(id: string) {
		all.get(id)?.remove();
	}

	static show(x: number, y: number, rotation: number, id: string, owner: Container) {
		let guide: ___Guide;
		if (!all.has(id)) {
			guide = Lib.loadPrefab('___system/guide') as ___Guide;
			guide.id = id;
			all.set(id, guide);
			overlayLayer.addChild(guide);
		} else {
			guide = all.get(id)!;
		}
		guide.refresh(x, y, rotation, owner);
	}
}
</file>

<file path="src/engine/lib/assets/src/___system/ruler.c.ts">
import { Point } from 'pixi.js';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import type { SelectionData } from 'thing-editor/src/editor/utils/selection';
import game from 'thing-editor/src/engine/game';
import Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';
import type Shape from '../extended/shape.c';

const p = new Point();

export default class ___Ruler extends Container {

	startPoint = new Point();
	startPointView!: Container;
	startContainer!: Container;
	startPointInfo!: Container;
	sizeInfo!: Container;
	zeroPointView!: Container;
	sizeInfoRect!: Container;
	guides!: Shape[];
	reflectedGuide!: Shape;

	selectionSavedData!: SelectionData;

	currentContainer!: Container;

	W = 0;
	H = 0;

	interval = 0;


	constructor() {
		super();
		this.updateRuler = this.updateRuler.bind(this);
		this.onPlayToggle = this.onPlayToggle.bind(this);
	}

	initRuler() {

		this.interval = window.setInterval(this.updateRuler, 16);
		editorEvents.on('playToggle', this.onPlayToggle);
		this.startPoint.y =
		this.startPoint.x = 0;

		EDITOR_FLAGS.blockSelectByStageClick++;
		this.zeroPointView = this.findChildByName('zero-point-view') as Shape;
		this.startPointInfo = this.findChildByName('start-point-info') as Shape;
		this.startPointView = this.findChildByName('start-point') as Shape;
		this.sizeInfo = this.findChildByName('size-info') as Shape;
		this.sizeInfoRect = this.findChildByName('size-info-rect') as Shape;
		this.reflectedGuide = this.findChildByName('reflected-guide') as Shape;
		this.guides = this.findChildrenByName('guide') as Shape[];
		this.startContainer = game.editor.selection[0] || game.currentContainer;

		this.parent.toLocal(this.startContainer, this.startContainer.parent, this);
		this.selectionSavedData = game.editor.selection.saveSelection();

		game.editor.selection.clearSelection();

		this.currentContainer = game.currentContainer;

		game.mouse.gameClick = false;
		game.mouse.click = 0;
	}

	updateRuler() {

		if (
			this.currentContainer !== game.currentContainer ||
			game.mouse.click === 2 ||
			game.keys.isKeycodePressed(27)
		) {
			this.removeRuler();
			return;
		}

		super.update();

		if (this.startContainer) {
			this.parent.toLocal(this.startContainer, this.startContainer.parent, this);
		}

		if (game.mouse.click === 1 && game.mouse.gameClick) {
			this.startContainer.toLocal(game.__mouse_uncropped, game.currentContainer, this.startPoint);
		}

		this.startPointView.parent.toLocal(this.startPoint, this.startContainer, this.startPointView);

		this.startPointView.toLocal(game.__mouse_uncropped, game.currentContainer, p);

		if (game.keys.shiftKey) {
			const size = Math.max(Math.abs(p.x), Math.abs(p.y));
			p.x = Math.sign(p.x) * size;
			p.y = Math.sign(p.y) * size;
		}


		for (const g of this.guides) {
			g.visible = !!(Math.abs(p.x) > 0.5 && Math.abs(p.y) > 0.5);
			if (g.visible) {
				g.width = Math.abs(p.x);
				if (p.x > 0) {
					g.x = 0;
				} else {
					g.x = p.x;
				}
				g.height = Math.abs(p.y);
				if (p.y > 0) {
					this.startPointInfo.scale.y = 1;
					g.y = 0;
				} else {
					this.startPointInfo.scale.y = -1;
					g.y = p.y;
				}
			}
		}

		if (p.x > -1) {
			this.startPointInfo.scale.x = 1;
		} else {
			this.startPointInfo.scale.x = -1;
		}
		if (p.y > -1) {
			this.startPointInfo.scale.y = 1;
		} else {
			this.startPointInfo.scale.y = -1;
		}

		this.W = Math.round(Math.abs(p.x / game.stage.scale.x));
		this.H = Math.round(Math.abs(p.y / game.stage.scale.x));

		this.sizeInfo.x = p.x;
		this.sizeInfo.y = p.y;

		this.sizeInfo.scale.x = this.startPointInfo.scale.x;
		this.sizeInfo.children[0].scale.x =
		this.startPointInfo.children[0].scale.x = Math.sign(this.startPointInfo.scale.x);

		this.sizeInfo.scale.y = this.startPointInfo.scale.y;
		this.sizeInfo.children[0].scale.y =
		this.startPointInfo.children[0].scale.y = Math.sign(this.startPointInfo.scale.y);

		this.reflectedGuide.visible = this.guides[0].visible;
		this.reflectedGuide.width = this.guides[0].width * 2;
		this.reflectedGuide.height = this.guides[0].height * 2;
		this.reflectedGuide.x = this.reflectedGuide.width / -2;
		this.reflectedGuide.y = this.reflectedGuide.height / -2;


		this.parent.toLocal(this.sizeInfoRect, this.sizeInfoRect.parent, p);
		const leftEdge = this.sizeInfoRect.width;
		const topEdge = this.sizeInfoRect.height;
		const rightEdge = game.W - this.sizeInfoRect.width;
		const bottomEdge = game.H - this.sizeInfoRect.height;
		if (p.x < leftEdge) {
			this.sizeInfo.x += leftEdge - p.x;
		}
		if (p.x > rightEdge) {
			this.sizeInfo.x -= (p.x - rightEdge);
		}
		if (p.y < topEdge) {
			this.sizeInfo.y += topEdge - p.y;
		}
		if (p.y > bottomEdge) {
			this.sizeInfo.y -= (p.y - bottomEdge);
		}
		this.zeroPointView.scale.x = this.zeroPointView.scale.y = game.stage.scale.x;

	}

	onPlayToggle() {
		this.removeRuler();
	}

	removeRuler() {
		clearInterval(this.interval);
		game.editor.selection.loadSelection(this.selectionSavedData);
		this.startPointView = null!;
		this.sizeInfoRect = null!;
		this.sizeInfo = null!;
		this.zeroPointView = null!;
		this.startContainer = null!;
		this.reflectedGuide = null!;
		this.currentContainer = null!;
		editorEvents.off('playToggle', this.onPlayToggle);
		EDITOR_FLAGS.blockSelectByStageClick--;
		this.remove();
	}
}
</file>

<file path="src/engine/lib/assets/src/basic/b-g-music.c.ts">
import { Container } from 'pixi.js';

import editable from 'thing-editor/src/editor/props-editor/editable';
import type { SelectEditorItem } from 'thing-editor/src/editor/ui/props-editor/props-editors/select-editor';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import MusicFragment, { MIN_VOL_THRESHOLD } from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music/music-fragment';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import Sound from 'thing-editor/src/engine/utils/sound';

const allActiveMusics: BgMusic[] = [];

let musicRecalculationIsScheduled = false;

/// #if EDITOR
const selectOutput = () => {
	const ret = Object.keys(Sound.outputs).map(name => { return {name, value: name} as SelectEditorItem; });
	ret.unshift({name: 'default (MUSIC)', value: null});
	ret.forEach(i => {
		if (i.name === 'Sound.soundsVol') {
		 i.name += ' (FX)';
		}
	});
	return ret;
};
/// #endif

export default class BgMusic extends Container {

	_externalVolume = 0;

	init() {
		this._externalVolume = 0;
		super.init();
		assert(allActiveMusics.indexOf(this) < 0, 'BgMusic reference already registered');
		allActiveMusics.push(this);

		BgMusic._recalculateMusic();
		if (!this.dynamicPreloading) {
			Lib.preloadSound(this.intro
				/// #if EDITOR
				, this
				/// #endif
			);
			Lib.preloadSound(this.loop
				/// #if EDITOR
				, this
				/// #endif
			);
		}
		this.applyResetPosition();
		BgMusic._recalculateMusic();
	}

	_intro: string | null = null;

	@editable({ type: 'sound', filterName: 'musSelector' })
	get intro() {
		return this._intro;
	}

	set intro(v) {
		if (this._intro !== v) {
			this._intro = v;
			this.musicFragmentHash = (this._intro || '') + '#' + (this._loop || '');
			BgMusic._recalculateMusic();
		}
	}

	_loop: string | null = null;

	@editable({ type: 'sound', filterName: 'musSelector' })
	get loop() {
		return this._loop;
	}

	set loop(v) {
		if (this._loop !== v) {
			this._loop = v;
			this.musicFragmentHash = (this._intro || '') + '#' + (this._loop || '');
			BgMusic._recalculateMusic();
		}
	}

	_isPlaying = true;

	@editable()
	get isPlaying() {
		return this._isPlaying;
	}

	set isPlaying(v) {
		if (this._isPlaying !== v) {
			this._isPlaying = v;
			BgMusic._recalculateMusic();
		}
	}

	@editable()
	resetPositionOnPlay = true;

	_volume = 1;

	@editable({ default: 1, min: 0, max: 1, step: 0.01 })
	get volume() {
		return this._volume;
	}

	set volume(v) {
		if (this._volume !== v) {
			this._volume = v;
			BgMusic._recalculateMusic();
		}
	}

	@editable({ type: 'data-path', select: selectOutput})
	globalVolumePath: string | null = null;

	@editable({ min: 0, step: 0.01 })
	fadeOut = 0.2;

	@editable({ min: 0, step: 0.01 })
	fadeIn = 0.2;

	@editable({ min: 0, max: 1.0, step: 0.01 })
	volumeUnderModals = 0.25;

	@editable({ type: 'callback' })
	onIntroFinish: string | null = null;

	@editable()
	dynamicPreloading = false;

	musicFragmentHash!: string;
	_fade?: number = undefined;
	_appliedPathVol = 0;

	onRemove() {
		super.onRemove();
		let i = allActiveMusics.indexOf(this);
		if (i >= 0) { // could be removed before initialization in parent init method
			allActiveMusics.splice(i, 1);
		}
		BgMusic._recalculateMusic();
		MusicFragment.onMusicRemove(this);
		this.musicFragmentHash = undefined as any;
		this._loop = null;
		this._intro = null;
		this._externalVolume = 0;
		this._fade = undefined;
		this.onIntroFinish = null;
	}

	setVolume(v: number) {
		this.volume = v;
	}

	/// #if EDITOR
	update() {
		super.update();
		if (this._isPlaying) {
			if (this.intro) {
				Lib.getSound(this.intro).__lastTouch = EDITOR_FLAGS.__touchTime;
			}
			if (this.loop) {
				Lib.getSound(this.loop).__lastTouch = EDITOR_FLAGS.__touchTime;
			}
		}
	}
	/// #endif

	applyResetPosition() {
		if (this.isPlaying && this.resetPositionOnPlay) {
			this.resetPosition();
		}
	}

	_getTargetVol() {
		if (!this._isPlaying) {
			return 0;
		}
		assert(!isNaN(this._volume * this._externalVolume * Sound.musicVol), 'MgMusic volume is invalid');
		return this._volume * this._externalVolume || 0;
	}

	play(fade = this.fadeIn) {
		if (!this.isPlaying) {
			this._fade = fade;
			this.isPlaying = true;
			this.applyResetPosition();
		}
	}

	stop(fade = this.fadeOut) {
		if (this.isPlaying) {
			this._fade = fade;
			this.isPlaying = false;
		}
	}

	resetPosition() {
		MusicFragment.resetPosition(this.musicFragmentHash);
	}

	_onIntroFinish() {
		if (this.onIntroFinish) {
			callByPath(this.onIntroFinish, this);
		}
	}

	_takeFade() {
		if (typeof(this._fade) === 'number') {
			const ret = this._fade;
			this._fade = undefined;
			return ret;
		}
		return 0.2;
	}

	static _recalculateMusic() {
		if (!musicRecalculationIsScheduled) {
			window.setTimeout(recalculateMusic, 1);
			musicRecalculationIsScheduled = true;
		}
	}

	set fade(val: number) { // transition from fade to fadeIn fadeOut
		this.fadeIn = val;
		this.fadeOut = val;
	}

	/// #if DEBUG
	static __onSoundOverride(name: string) {
		if (!game.currentContainer) {
			return;
		}
		for (let bgm of game.currentContainer.findChildrenByType(BgMusic)) {
			if (bgm.isPlaying && (bgm.intro === name || bgm.loop === name)) {
				bgm.stop(0);
				MusicFragment.__stopAll();
				window.setTimeout(() => {
					if ((bgm.intro === name || bgm.loop === name)) {
						bgm.play();
					}
				}, 60);
			}
		}
	}

	/// #endif

	/// #if EDITOR
	static get __allActiveMusics() {
		return allActiveMusics;
	}

	get __isLoopPos() {
		return MusicFragment.__isLoopPosition(this.musicFragmentHash);
	}

	get __currentFragment() {
		if (this._getTargetVol() > MIN_VOL_THRESHOLD) {
			return MusicFragment.__getFragment(this.musicFragmentHash);
		}
		return undefined;
	}
	/// #endif
}


const FADER_MUSIC_PRIORITY = 1000000;
const CURRENT_CONTAINER_MUSIC_PRIORITY = 100000;

function recalculateMusic() {

	musicRecalculationIsScheduled = false;

	/// #if EDITOR
	if (!game.projectDesc) {
		return;
	}
	/// #endif

	if (game._isWaitingToHideFader) {
		return;
	}
	let priorities = [];
	let musicsMap: Map<number, BgMusic[]> = new Map();

	let currentFader = game.currentFader;

	if (currentFader) { //to enforce mute all musics under fader
		musicsMap.set(FADER_MUSIC_PRIORITY, []);
		priorities.push(FADER_MUSIC_PRIORITY);
	}

	for (let m of allActiveMusics) {
		let root = m.getRootContainer();
		let priority;
		if (root === game.currentContainer) {
			priority = CURRENT_CONTAINER_MUSIC_PRIORITY;
		} else if (root === currentFader) {
			priority = FADER_MUSIC_PRIORITY;
		} else if (root.parent) {
			priority = root.parent.getChildIndex(root);
		} else {
			m._externalVolume = 0;
			continue;
		}
		if (!musicsMap.has(priority)) {
			priorities.push(priority);
			musicsMap.set(priority, []);
		}
		musicsMap.get(priority)!.push(m);
	}

	priorities.sort(sortReverted);
	let muteAllNext = Sound.isSoundsLockedByBrowser || game._loadingErrorIsDisplayed;

	/// #if EDITOR
	muteAllNext = muteAllNext || game.__EDITOR_mode;
	/// #endif
	for (let priority of priorities) {
		let a = musicsMap.get(priority)!;
		for (let m of a) {
			if (muteAllNext) {
				m._externalVolume = 0;
			} else if (priority < CURRENT_CONTAINER_MUSIC_PRIORITY) {
				m._externalVolume = m.volumeUnderModals;
			} else {
				m._externalVolume = 1;
			}
		}
		muteAllNext = true;
	}

	let playingFragments = [];

	for (let m of allActiveMusics) {
		let vol = m._getTargetVol();
		if ((vol >= MIN_VOL_THRESHOLD) && (m._loop || m._intro)) {
			playingFragments.push(m);
		}
	}
	MusicFragment.setPlayingBGMusics(playingFragments);
}

const sortReverted = (a: number, b: number) => {
	return b - a;
};

/// #if DEBUG
game.on('__sound-overridden', BgMusic.__onSoundOverride);
/// #endif

/// #if EDITOR

BgMusic.__EDITOR_icon = 'tree/music';

(BgMusic.prototype.play as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(BgMusic.prototype.stop as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/b-g-music/music-fragment.ts">
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import { rootAudioContext } from 'thing-editor/src/engine/HowlSound';
import Lib from 'thing-editor/src/engine/lib';
import type BgMusic from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music.c';
import Sound, { slideAudioParamTo } from 'thing-editor/src/engine/utils/sound';
import { stepTo } from 'thing-editor/src/engine/utils/utils';

export const MIN_VOL_THRESHOLD = 0.001;

const FADE_INTERVAL = 50;
const FADE_INTERVAL_SECONDS = 1 / (1000 / FADE_INTERVAL);

const allFragments: KeyedMap<MusicFragment> = {};

const allActiveFragments: KeyedMap<MusicFragment> = {};


window.setInterval(() => {
	for (let h in allActiveFragments) {
		allActiveFragments[h]._updateFading();
	}
}, FADE_INTERVAL);

export default class MusicFragment {

	volumeNode = rootAudioContext.createGain();
	fadingToVolume = 0;
	intro: string | null;
	loop: string | null;
	musicFragmentHash!: string;
	source?: AudioBufferSourceNode;
	_fadeToVol!: number;
	_fadeSpeed!: number;
	owners: Set<BgMusic> = new Set();
	_preciseDuration = 0;
	introFinished = false;

	constructor(bgMusic: BgMusic) {
		this.volumeNode.connect(Sound.outputs.MUSIC);

		if (bgMusic.dynamicPreloading) {
			bgMusic.loop && Lib.preloadSound(bgMusic.loop
				/// #if EDITOR
				, bgMusic
				/// #endif
			);
			bgMusic.intro && Lib.preloadSound(bgMusic.intro
				/// #if EDITOR
				, bgMusic
				/// #endif
			);
		}
		this.onIntroEnd = this.onIntroEnd.bind(this);
		this.intro = bgMusic.intro;
		this.loop = bgMusic.loop;
		this.musicFragmentHash = bgMusic.musicFragmentHash;
	}

	_updateFading() {
		assert(this.source, 'MusicFragment wrongly registered as active');
		let curVol = this._fadeToVol;
		if (curVol !== this.fadingToVolume) {
			if (this._fadeSpeed > 0) {
				const from = this.fadingToVolume;
				const to = stepTo(from, curVol, FADE_INTERVAL_SECONDS / this._fadeSpeed);
				this.fadingToVolume = to;
				slideAudioParamTo(this.volumeNode.gain, to * to, FADE_INTERVAL_SECONDS, from * from);
			} else {
				this.volumeNode.gain.cancelScheduledValues(rootAudioContext.currentTime);
				this.volumeNode.gain.setValueAtTime(curVol * curVol, rootAudioContext.currentTime);
				this.fadingToVolume = curVol;
			}
		}
	}

	getVolume() {
		assert(this.source, 'BgMusic component is not paying to getVolume.');
		return this.volumeNode.gain.value;
	}

	static onMusicRemove(bgMusic: BgMusic) {
		for (let h in allActiveFragments) {
			let f = allActiveFragments[h];
			if (f.owners.has(bgMusic)) {
				clearFragmentsOwner(f, bgMusic);
			}
		}
	}

	static resetPosition(musicFragmentHash: string) {
		if (allFragments.hasOwnProperty(musicFragmentHash)) {
			allFragments[musicFragmentHash].resetPosition();
		}
	}

	resetPosition() {
		this.introFinished = false;
		this._releaseCurrentFragment();
	}

	startPlay() {

		if (this.source) {
			this.source.start(undefined, 0, this._preciseDuration);
			return;
		} else if (this.intro && !this.introFinished) {
			this.source = this._playMusicFragment(this.intro, 0, this._fadeToVol);
			if (this.source) {
				this.source!.loop = false;

				this.source!.addEventListener('ended', this.onIntroEnd);
				return;
			}
		}
		if (this.loop) {
			this.source = this._playMusicFragment(this.loop);
			if (this.source) {
				this.source!.loop = true;
			}
		}
	}

	onIntroEnd() {
		this.introFinished = true;
		if (this.source) {
			if (this.owners.size) {
				let vol = this.getVolume();
				this._releaseCurrentFragment();
				this.source = this._playMusicFragment(this.loop, 0, vol);
				if (this.source) {
				this.source!.loop = true;
				}
			} else {
				this._releaseCurrentFragment();
			}
		}

		this.owners.forEach((bgMusic) => {
			bgMusic._onIntroFinish();
		});
	}

	_playMusicFragment(s: string | null, pos = 0, startVol = 0.001) {
		if (s) {
			try {
				const snd = Lib.getSound(s, true);
				if (!snd.audioBuffer) {
					return;
				}

				const source = rootAudioContext.createBufferSource();
				source.buffer = snd.audioBuffer;
				source.playbackRate.setValueAtTime(
					/// #if DEBUG
					game.pixiApp.ticker.speed
					/*
				/// #endif
				1
				//*/
					, rootAudioContext.currentTime);

				/// #if EDITOR
				Sound.__highlightPlayedSound(s);
				/// #endif

				source.start(undefined, pos, snd.preciseDuration);

				assert(!allActiveFragments[this.musicFragmentHash], 'Music fragment already exists');
				allActiveFragments[this.musicFragmentHash] = this;
				this.volumeNode.gain.cancelScheduledValues(rootAudioContext.currentTime);
				this.volumeNode.gain.setValueAtTime(startVol, rootAudioContext.currentTime);
				this.fadingToVolume = startVol;
				source!.connect(this.volumeNode);
				this._preciseDuration = snd.preciseDuration;
				source.buffer;

				return source;
			} catch (_er) {
				/// #if EDITOR
				debugger;
				/// #endif
			}
		}
	}

	_releaseCurrentFragment() {
		if (this.source) {
			this.source.removeEventListener('ended', this.onIntroEnd);
			this.source.stop();
			assert(allActiveFragments[this.musicFragmentHash] === this, 'allActiveFragments map corrupted.');
			this.source = undefined;
			delete allActiveFragments[this.musicFragmentHash];
		}
	}

	static setPlayingBGMusics(bgMusics: BgMusic[]) {
		let hashesToPlay: KeyedMap<boolean> = {};
		for (let bgMusic of bgMusics) {
			let fragment: MusicFragment;

			hashesToPlay[bgMusic.musicFragmentHash] = true;

			if (!allFragments.hasOwnProperty(bgMusic.musicFragmentHash)) {
				fragment = new MusicFragment(bgMusic);
				allFragments[bgMusic.musicFragmentHash] = fragment;
			} else {
				fragment = allFragments[bgMusic.musicFragmentHash];
				assert(fragment.musicFragmentHash === bgMusic.musicFragmentHash, 'allFragments map corrupted');
			}

			fragment._fadeToVol = bgMusic._getTargetVol();
			fragment._fadeSpeed = bgMusic._takeFade();
			fragment.owners.add(bgMusic);
			if (!allActiveFragments.hasOwnProperty(bgMusic.musicFragmentHash)) {
				fragment.startPlay();
			}
		}

		for (let h in allActiveFragments) {
			if (!hashesToPlay.hasOwnProperty(h)) {
				allActiveFragments[h]._fadeToVol = 0;
				if (allActiveFragments[h].owners.size) {
					allActiveFragments[h].owners.forEach((bgMusic) => {
						clearFragmentsOwner(allActiveFragments[h], bgMusic);
					});
				}
			}
		}
	}

	static __applyGameSpeed(rate: number) {
		for (let h in allActiveFragments) {
			let f = allActiveFragments[h];
			if (f.source) {
				f.source.playbackRate.setValueAtTime(rate, rootAudioContext.currentTime);
			}
		}
	}
	/// #if EDITOR

	static __isLoopPosition(musicFragmentHash: string) {
		return allActiveFragments[musicFragmentHash]?.source?.loop;
	}

	static __getFragment(musicFragmentHash: string) {
		return allActiveFragments[musicFragmentHash];
	}
	/// #endif

	/// #if DEBUG
	static __stopAll() {
		for (let h in allActiveFragments) {
			MusicFragment.resetPosition(h);
		}
	}
	/// #endif

}

function clearFragmentsOwner(fragment: MusicFragment, ownerBgMusic:BgMusic) {
	fragment._fadeSpeed = ownerBgMusic._takeFade();
	fragment.owners.delete(ownerBgMusic);
}
</file>

<file path="src/engine/lib/assets/src/basic/back-drop.c.ts">
import type { Renderer } from 'pixi.js';
import { Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';

const zeroPoint = new Point();
const sizePoint = new Point();

export default class BackDrop extends Shape {
	@editable({ name: 'interactive', default: true, override: true })

	/// #if EDITOR
	__afterSerialization(data: SerializedObject): void {
		delete data.p.width;
		delete data.p.height;
		delete data.p.x;
		delete data.p.y;
	}

	/// #endif

	render(renderer: Renderer): void {
		this.parent.toLocal(zeroPoint, game.stage, sizePoint, false);
		if (!isNaN(sizePoint.x) && !isNaN(sizePoint.y)) {
			this.x = sizePoint.x;
			this.y = sizePoint.y;
			sizePoint.x = game.W;
			sizePoint.y = game.H;
			this.toLocal(sizePoint, game.stage, sizePoint, false);
			this.updateTransform();
			this.width = sizePoint.x;
			this.height = sizePoint.y;
			super.render(renderer);
		}
	}
}
</file>

<file path="src/engine/lib/assets/src/basic/bitmap-text.c.ts">
import type { Text, TextStyleAlign } from 'pixi.js';
import { BitmapFont, BitmapFontData, BitmapText as BitmapTextOriginal, MIPMAP_MODES, Texture } from 'pixi.js';

import { _editableEmbed } from 'thing-editor/src/editor/props-editor/editable';
import LanguageView from 'thing-editor/src/editor/ui/language-view';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import L from 'thing-editor/src/engine/utils/l';
import ___Guide from '../___system/guide.c';

const CENTER = 'center';
const LEFT = 'left';
const RIGHT = 'right';
const TOP = 'top';
const BOTTOM = 'bottom';

const alignValues = {
	center: 0.5,
	left: 0.0,
	right: 1.0,
	top: 0.0,
	bottom: 1.0
};
const EMPTY_FONT_NAME = 'EMPTY';

assert(BitmapFont.install instanceof Function, 'Thing editor needs refactoring of BitmapFont atlases error handling.');
const origin_font_install = BitmapFont.install;
BitmapFont.install = function (this : typeof BitmapFont, _data: any, textures: Texture | Texture[]): BitmapFont | undefined {
	try {
		Object.values(textures instanceof Texture ? [textures] : textures).forEach((texture) => {
			if (!texture || texture === Texture.EMPTY) return;
			texture.baseTexture.mipmap = MIPMAP_MODES.ON;
		});
		return origin_font_install.apply(this, arguments as any);
	} catch (er) {
		game.showLoadingError(
			'BitmapFont installing error: ' + (er as Error).message + (_data ? JSON.stringify(_data, null, ' ') : '')
		);
	}
} as any;

const emptyFontData = new BitmapFontData();
emptyFontData.info[0] = { face: EMPTY_FONT_NAME, size: 32 };
emptyFontData.page[0] = { id: 0, file: '' };
emptyFontData.common[0] = { lineHeight: 32 };
BitmapFont.install(emptyFontData, Texture.EMPTY);

export default class BitmapText extends BitmapTextOriginal {

	constructor() {
		super('', { fontName: EMPTY_FONT_NAME, fontSize: 32 });
	}

	textProvider: string | null = null;

	_textProvider: Text | null = null;

	_maxW = 0;

	_translatableText: string | null = null;

	init() {
		super.init();
		this.updateText();
		if (this.textProvider) {
			this._textProvider = getValueByPath(this.textProvider, this);
		} else {
			this._textProvider = null;
		}
	}

	updateText() {
		if (this.fontName === EMPTY_FONT_NAME) {
			return;
		}

		/// #if EDITOR
		if (!BitmapFont.available[this.fontName]) {
			setTimeout(() => {
				game.editor.ui.status.error('BitmapFont is not exists: ' + this._fontName, 32053, this, 'fontName');
			}, 0);
			return;
		}
		if (this.fontSize === 0) {
			this.fontSize = BitmapFont.available[this.fontName].size;
		}
		/// #endif
		super.updateText();
		this.maxW = this._maxW || 0; // recalculate max width
		/// #if EDITOR
		for (const c of this.children) {
			c.__nodeExtendData = {};
			c._thing_initialized = true;
		}
		/// #endif
	}

	forAllChildren(cb:any) {
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			super.forAllChildren(cb);
		}
		/// #endif
	}

	get maxW() {
		return this._maxW;
	}

	set maxW(val) {
		this._maxW = val;
		if (this._maxW !== 0) {
			if (this._textWidth > this._maxW) {
				var q = this._maxW / this._textWidth;
				if (this.scale.x !== q || this.scale.y !== q) {
					this.scale.x = q;
					this.scale.y = q;
					if (this.parent) {
						this.updateTransform();
					}
				}
			} else {
				if (this.scale.x !== 1 || this.scale.y !== 1) {
					this.scale.x = 1;
					this.scale.y = 1;
					if (this.parent) {
						this.updateTransform();
					}
				}
			}
		}
	}

	clearBitmapText() {
		this.removeChildren();
	}

	onRemove() {
		super.onRemove();
		this.clearBitmapText();
	}

	update() {
		super.update();
		if (this._textProvider) {
			this.text = this._textProvider.text;
		}
	}

	set 'font.name'(v) {
		/// #if EDITOR
		let names = Object.keys(BitmapFont.available);
		if (!names.find((name) => name === v)) {
			game.editor.ui.status.warn(
				'It is no any bitmap font name \'' + v + '\' in \'/img\' subfolders.',
				99999,
				this,
				'font.name'
			);
			return;
		}

		/// #endif
		this.fontName = v;
		/// #if EDITOR
		this.validate();
		/// #endif
	}

	get 'font.name'() {
		return this.fontName;
	}

	set 'font.size'(v) {
		this.fontSize = v;
		/// #if EDITOR
		this.validate();
		/// #endif
	}

	get 'font.size'() {
		return this.fontSize;
	}

	set 'font.align'(v:string) {
		this.align = v as any;
		this.anchor.x = alignValues[v as 'center'];
		/// #if EDITOR
		this.validate();
		/// #endif
	}

	get 'font.align'() {
		return this.align;
	}

	_verticalAlign = CENTER as TextStyleAlign;

	set verticalAlign(v:TextStyleAlign) {
		this._verticalAlign = v;
		this.anchor.y = alignValues[v as 'center'];
	}

	get verticalAlign():TextStyleAlign {
		return this._verticalAlign;
	}

	onLanguageChanged() {
		if (this._translatableText) {
			let t = this._translatableText;
			this._translatableText = null;
			this.translatableText = t;
		}
	}

	get translatableText() {
		return this._translatableText;
	}

	set translatableText(val) {
		if (this._translatableText !== val) {
			if (val) {
				/// #if EDITOR
				if (!L.has(val)) {
					game.editor.ui.status.warn(
						'translatableText refers to not existing key.',
						32032,
						this,
						'translatableText'
					);
				}
				/// #endif
				this.text = L(val);
			}
			this._translatableText = val;
		}
	}

	/// #if EDITOR

	render(renderer:any) {
		super.render(renderer);
		for (const c of this.children) {
			if (!c.__nodeExtendData) {
				c.__nodeExtendData = {};
			}
		}
	}

	__beforeSerialization() {
		if (this._translatableText) {
			this.text = '';
		}

		this.clearBitmapText();

		if (this.maxW > 0) {
			this.scale.x = 1;
			this.scale.y = 1;
		}
	}

	__afterSerialization() {
		if (this._translatableText) {
			this.text = L(this._translatableText);
		}
		this.updateText();
		if (this.maxW > 0) {
			let tmp = this.maxW;
			this.maxW = 0;
			this.maxW = tmp;
		}
	}

	__EDITOR_onCreate() {
		const fontName = Object.keys(BitmapFont.available).find((name) => name !== EMPTY_FONT_NAME);
		if (fontName) {
			this.text = 'New BitmapText 1';
			this.fontName = fontName;
			this.fontSize = BitmapFont.available[fontName].size;
		}
		this.__afterDeserialization();
	}

	__beforeDestroy() {
		this.text = '';
		this.clearBitmapText();
	}

	__afterDeserialization() {
		this.__hideChildren = true;
	}

	static __canAcceptChild() {
		return false;
	}

	/// #endif
}

/// #if EDITOR

_editableEmbed(BitmapText, 'text', {
	type: 'string',
	default: '',
	disabled: (node:BitmapText) => {
		return node.translatableText;
	},
	multiline: true
});

_editableEmbed(BitmapText, 'translatableText', { type: 'l10n' });

_editableEmbed(BitmapText, 'Edit text', {
	type: 'btn',
	helpUrl: 'components.Text#edit-text',
	title: 'Edit or create new translatable key.',
	onClick: (o: BitmapText) => {
		LanguageView.editKey(o.translatableText);
	}
});

_editableEmbed(BitmapText, 'font.name', {
	type: 'string',
	default: EMPTY_FONT_NAME,
	select: () => {
		let names = Object.keys(BitmapFont.available);
		if (!names.find((name) => name !== EMPTY_FONT_NAME)) {
			setTimeout(() => {
				game.editor.ui.status.warn(
					'There is no any bitmap fonts (xml) in \'/assets\' folder.',
					32046,
					game.editor.selection[0]
				);
			}, 0);
		}
		return names.map((n) => {
			return { name: n, value: n };
		});
	}
});

_editableEmbed(BitmapText, 'font.size', {
	type: 'number', min: 0
});

_editableEmbed(BitmapText, 'Reset font size', {
	type: 'btn',
	onClick: () => {
		for (const t of game.editor.selection as any) {
			if (t._font) {
				game.editor.onObjectsPropertyChanged(t, 'font.size', t._font.size);
			}
		}
	}
});

_editableEmbed(BitmapText, 'font.align', {
	type: 'string',
	select: [
		{ name: CENTER, value: CENTER },
		{ name: LEFT, value: LEFT },
		{ name: RIGHT, value: RIGHT }
	],
	default: CENTER
});

_editableEmbed(BitmapText, 'verticalAlign', {
	type: 'string',
	select: [
		{ name: TOP, value: TOP },
		{ name: CENTER, value: CENTER },
		{ name: BOTTOM, value: BOTTOM }
	],
	default: CENTER
});

_editableEmbed(BitmapText, 'letterSpacing', {
	type: 'number',
	noNullCheck: true
});

_editableEmbed(BitmapText, 'maxW', { afterEdited: () => { let o = game.editor.selection[0] as BitmapText; afterEdited(o, o.maxW); }, min: 0});


_editableEmbed(BitmapText, 'tint', {
	type: 'number',
	basis: 16,
	noNullCheck: true,
	default: 0xffffff,
	max: 0xffffff,
	min: 0
});

_editableEmbed(BitmapText, 'textProvider', {
	type: 'data-path',
	isValueValid: (o) => {
		return o && (typeof o === 'object') && ('text' in o);
	}
});

_editableEmbed(BitmapText, '__hideChildren', {
	override: true,
	default: true,
	disabled: () => true
});


BitmapText.__EDITOR_icon = 'tree/bitmap-text';

function afterEdited(overrideO:BitmapText, x:number) {
	let o = overrideO || (game.editor.selection[0] as BitmapText);
	if (x === 0) {
		for (let t of game.editor.selection) {
			t.scale.x = 1;
			t.scale.y = 1;
		}
		___Guide.hide('bitmapFontMaxWidthLeft');
	} else {
		switch (o.align) {
		case CENTER:
			x *= 0.5;
			break;
		case RIGHT:
			x *= -1;
			break;
		}
		let tmpScale = o.scale.x;
		o.scale.x = 1;
		o.scale.y = 1;
		___Guide.show(x, 0, Math.PI / 2, 'bitmapFontMaxWidthLeft', o);
		___Guide.show(-x, 0, Math.PI / 2, 'bitmapFontMaxWidthLeft', o);
		o.scale.x = tmpScale;
		o.scale.y = tmpScale;
	}
}

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/button.c.ts">
import type { FederatedPointerEvent, Renderer } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import { mouseHandlerGlobal } from 'thing-editor/src/engine/utils/game-interaction';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import Sound from 'thing-editor/src/engine/utils/sound';

/// #if EDITOR
import R from 'thing-editor/src/editor/preact-fabrics';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import isEventFocusOnInputElement from 'thing-editor/src/editor/utils/is-event-focus-on-input-element';
/// #endif

let latestClickTime = 0;
const SCROLL_THRESHOLD = 30;

export default class Button extends DSprite {

	onClickCallback?: () => void;

	@editable({ name: 'interactive', default: true, override: true, disabled: () => 'Please use "enabled" property instead.' })

	@editable({ type: 'image' })
	hoverImage = null;
	@editable({ type: 'image' })
	pressImage = null;
	@editable({ type: 'image' })
	disabledImage = null;

	@editable({ visible: (o) => { return !o.disabledImage; }, min: 0, max: 1, step: 0.01, default: 0.76 })
	disabledAlpha = 0;

	@editable({ important: true })
	enabled = true;

	@editable({ type: 'callback', important: true })
	onClick: string[] = [];

	@editable()
	hotkey = 0;

	@editable({ type: 'sound' })
	sndClick: string | null = null;

	@editable({ type: 'sound' })
	sndOver: string | null = null;

	get scrollable() {
		if (game.classes.ScrollLayer) {
			const parentScrollLayer = this.findParentByType(game.classes.ScrollLayer);
			return parentScrollLayer &&
				((parentScrollLayer.fullArea.w > parentScrollLayer.visibleArea.w) ||
					(parentScrollLayer.fullArea.h > parentScrollLayer.visibleArea.h)
				);
		}
		return false;
	}

	initialScale!: number;
	initialImage!: string | null;

	curDelay = 0;

	@editable({ min: 0 })
	repeatDelay = 0;

	@editable({ min: 0 })
	repeatInterval = 0;

	pointerStartPos?: { x: number; y: number };

	init() {

		assert(!this.onClickCallback, 'Button onClickCallback was not clean properly.');
		super.init();

		this.on('pointerdown', this.onDown);
		this.on('pointerup', this.onUp);
		this.on('pointerover', this.onOver);
		this.on('pointerout', this.onOut);

		assert(!game.__EDITOR_mode, '\'init()\' called in edition mode');
		assert(allActiveButtons.indexOf(this) < 0, 'Button already in active list.');
		allActiveButtons.unshift(this);

		this.initialScale = this.scale.x;
		this.initialImage = this.image;
		if (this.enabled) {
			this.enable();
		} else {
			this.disable();
		}

		this.pointerStartPos = undefined;
	}

	onRemove() {
		super.onRemove();
		this.onOut();

		this.removeListener('pointerdown', this.onDown);
		this.removeListener('pointerup', this.onUp);
		this.removeListener('pointerover', this.onOver);
		this.removeListener('pointerout', this.onOut);

		let i = allActiveButtons.indexOf(this);
		/// #if DEBUG
		assert((!this._thing_initialized) || (i >= 0), 'Button is not in active list.');
		this._thing_initialized = false;
		/// #endif

		if (i >= 0) { // could be removed before initialization in parent init method
			allActiveButtons.splice(i, 1);
		}

		if (downedByKeycodeButton === this) {
			downedByKeycodeButton = undefined;
		}
		this.initialImage = null;
		this.enabled = false;

		if (this.hasOwnProperty('onClickCallback')) {
			delete (this.onClickCallback);
		}
	}

	/// #if EDITOR
	render(renderer: Renderer): void {
		super.render(renderer);
		if (this.isCanBePressed && this.worldAlpha > 0.1) {
			if (this.hoverImage && Lib.hasTexture(this.hoverImage)) {
				Lib.getTexture(this.hoverImage).baseTexture.touched = EDITOR_FLAGS.__touchTime;
			}
			if (this.pressImage && Lib.hasTexture(this.pressImage)) {
				Lib.getTexture(this.pressImage).baseTexture.touched = EDITOR_FLAGS.__touchTime;
			}
			if (this.disabledImage && Lib.hasTexture(this.disabledImage)) {
				Lib.getTexture(this.disabledImage).baseTexture.touched = EDITOR_FLAGS.__touchTime;
			}
			if (this.sndOver && Lib.hasSound(this.sndOver)) {
				Lib.getSound(this.sndOver).__lastTouch = EDITOR_FLAGS.__touchTime;
			}
			if (this.sndClick && Lib.hasSound(this.sndClick)) {
				Lib.getSound(this.sndClick).__lastTouch = EDITOR_FLAGS.__touchTime;
			}
		}
	}
	/// #endif

	disable() {
		if (this.initialImage) {
			this.onUp();
			this.onOut();
			if (this.disabledImage) {
				this.image = this.disabledImage;
			} else {
				this.alpha = this.disabledAlpha;
			}
		}
		this.enabled = false;
		this.cursor = 'default';
	}

	enable() {
		if (this.initialImage) {
			if (this.disabledImage) {
				this.image = this.initialImage;
			} else {
				this.alpha = 1;
			}
		}
		this.enabled = true;
		this.cursor = 'pointer';
	}

	static clickedButton: Button | null = null;
	static overedButton: Button | null = null;
	static downedButton: Button | null = null;

	get isOvered() {
		return this === Button.overedButton;
	}

	get isDowned() {
		return this === Button.downedButton;
	}

	click() {
		if (this.isCanBePressed) {
			this._executeOnClick('invoke');
		}
	}

	//@ts-ignore
	get isCanBePressed() {
		if (!this.enabled) return false;
		//@ts-ignore
		return super.isCanBePressed;
	}

	_executeOnClick(source/** optional tracking tag */?: string) {
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			return;
		}
		/// #endif
		assert(this.isCanBePressed, '_executeOnClick called for button which could not be pressed at the moment.');

		game.emit('button-click', this, source);

		Button.clickedButton = this;
		if (this.onClickCallback) {
			this.onClickCallback();
		}

		for (const action of this.onClick) {
			callByPath(action, this);
		}

		if (source === 'hotkey') {
			if (game.classes.ClickOutsideTrigger) {
				game.classes.ClickOutsideTrigger.shootAll(this);
			}
		}

		Button.clickedButton = null;

		if (this.sndClick) {
			Sound.play(this.sndClick);
		}

		latestClickTime = game.time;
	}

	_isNotPausable() {
		if (game.classes.UnPausableContainer) {
			return this.findParentByType(game.classes.UnPausableContainer);
		}
	}

	onDown(ev: PointerEvent | null | FederatedPointerEvent, source = 'pointerdown') {

		Sound._unlockSound();
		if (game.time === latestClickTime || game.__paused
		) {
			if (!this._isNotPausable()) {
				return;
			}
		}
		if (ev) {
			if (ev.buttons !== 1) {
				return;
			}
			mouseHandlerGlobal(ev);
		}
		if (this.isCanBePressed && ((Math.abs(latestClickTime - game.time) > 1) || this._isNotPausable())) {
			if (Button.downedButton !== this) {
				if (Button.downedButton) {
					Button.downedButton.onUp();
				}
				if (this.pressImage) {
					this.image = this.pressImage;
				} else {
					this.scale.x =
						this.scale.y = this.initialScale * (this.isOvered ? 1 : 0.9);
				}
				Button.downedButton = this;
				this.curDelay = this.repeatDelay;

				if (this.scrollable) {
					this.pointerStartPos = { x: game.mouse.x, y: game.mouse.y };
				} else {
					this._executeOnClick(source);
				}
			}
		}
	}

	update() {

		/// #if EDITOR
		if (this.isCanBePressed) {
			this.onClick.forEach((action, i) => {
				let f;
				try {
					f = getValueByPath(action, this, true);
				} catch (_er) { }
				if (typeof f !== 'function') {
					game.editor.ui.status.error('Wrong onClick handler: ' + action, 32054, this, 'onClick', i);
					getValueByPath(action, this, true);
				}
			});
		}
		/// #endif

		if (this.isDowned) {
			if ((!game.mouse.click && (downedByKeycodeButton !== this)) || !game.isFocused) {
				this.onUp();
			} else if (this.curDelay > 0) {
				this.curDelay--;
				if (this.curDelay === 0) {
					if (this.isCanBePressed && (Math.abs(latestClickTime - game.time) > 1)) {
						this._executeOnClick('autorepeat');
					}
					this.curDelay = this.repeatInterval;
				}
			}
		}
		super.update();
	}

	onUp(ev?: PointerEvent | KeyboardEvent | FederatedPointerEvent, src = 'pointerup') {
		if (Button.downedButton === this) {
			if (this.pressImage) {
				if (this.initialImage) {
					this.image = this.initialImage;
				}
			} else {
				this.scale.x =
					this.scale.y = this.initialScale * ((this.isOvered && !this.hoverImage) ? 1.05 : 1);
			}
			if (ev && this.scrollable && Math.hypot(game.mouse.x - this.pointerStartPos!.x, game.mouse.y - this.pointerStartPos!.y) <= SCROLL_THRESHOLD) {
				this._executeOnClick(src);
			}
			Button.downedButton = null;
		}
	}

	onOver() {
		/// #if EDITOR
		/*
		/// #endif
		if (game.isMobile.any) {
			return;
		}
		//*/
		if (this.enabled) {
			if (Button.overedButton !== this) {
				if (Button.overedButton) {
					Button.overedButton.onOut();
				}
				Button.overedButton = this;

				if (this.hoverImage) {
					this.image = this.hoverImage;
				} else {
					this.scale.x =
					this.scale.y = this.initialScale * 1.05;
				}

				if (this.sndOver) {
					Sound.play(this.sndOver);
				}
				this.gotoLabelRecursive('btn-over');

			}
		}
	}

	_onDisableByTrigger() {
		this.onOut();
	}

	onOut() {
		/// #if EDITOR
		/*
		/// #endif
		if (game.isMobile.any) {
			return;
		}
		//*/
		if (Button.overedButton === this) {
			Button.overedButton = null;

			if (this.hoverImage) {
				if (this.initialImage) {
					this.image = this.initialImage;
				}
			} else {
				this.scale.x =
				this.scale.y = this.initialScale;
			}

			this.onUp();
			this.gotoLabelRecursive('btn-out');
		}
	}

	static _tryToClickByKeycode(keyCode: number): Button | undefined {
		for (let b of allActiveButtons) {
			if ((b.hotkey === keyCode) && b.isCanBePressed) {
				b.onDown(null, 'hotkey');
				return b;
			}
		}
	}

	/// #if EDITOR

	__beforeSerialization(): void {
		this.interactive = true;
	}

	__afterDeserialization(): void {
		this.interactive = true;
	}

	__EDITOR_onCreate() {
		if (Lib.hasTexture('ui/button.png')) {
			this.image = 'ui/button.png';
		}
		if (Lib.hasSound('click')) {
			this.sndClick = 'click';
		}
		if (Lib.hasSound('over')) {
			this.sndOver = 'over';
		}
	}


	/// #endif

}

let downedByKeycodeButton: Button | undefined;

let allActiveButtons: Button[] = [];

window.addEventListener('keydown', (ev) => {
	if (ev.repeat) {
		return;
	}
	/// #if EDITOR
	if (game.__EDITOR_mode) {
		return;
	}
	if (isEventFocusOnInputElement(ev)) {
		return;
	}
	/// #endif

	downedByKeycodeButton = Button._tryToClickByKeycode(ev.keyCode);
	if (downedByKeycodeButton) {
		ev.preventDefault();
		ev.stopPropagation();
	}
});

window.addEventListener('keyup', (ev) => {
	if (downedByKeycodeButton && downedByKeycodeButton.hotkey === ev.keyCode) {
		downedByKeycodeButton.onUp(ev, 'hotkey');
		downedByKeycodeButton = undefined;
	}
});


/// #if EDITOR

Button.__EDITOR_icon = 'tree/button';

setTimeout(() => {
	const ACTION_ICON_ENABLE = R.img({ src: '/thing-editor/img/timeline/enable.png' });
	const ACTION_ICON_DISABLE = R.img({ src: '/thing-editor/img/timeline/disable.png' });
	(Button.prototype.enable as SelectableProperty).___EDITOR_actionIcon = ACTION_ICON_ENABLE;
	(Button.prototype.disable as SelectableProperty).___EDITOR_actionIcon = ACTION_ICON_DISABLE;
});
(Button.prototype.enable as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Button.prototype.disable as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Button.prototype.click as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/click-outside-trigger.c.ts">
import type { FederatedPointerEvent } from 'pixi.js';
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import overlayLayer from 'thing-editor/src/editor/ui/editor-overlay';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import game from 'thing-editor/src/engine/game';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import Button from './button.c';

const globalPointerDownEvents = (game.pixiApp.renderer.events.rootBoundary as any).mappingTable.pointerdown;

const all: ClickOutsideTrigger[] = [];

export default class ClickOutsideTrigger extends Container {
	@editable({ name: 'interactive', override: true, default: true })

	@editable({ type: 'callback', important: true })
	onClickOutside: string | null = null;

	@editable({ type: 'data-path' })
	additionalContainers: string[] = [];

	_insideContainers!: Container[];

	gameTime = 0;
	thisDownTime = 0;

	pointerDownListener = { fn: this.onStageDown.bind(this), priority: 10000 };

	constructor() {
		super();
		this.onThisDown = this.onThisDown.bind(this);
	}

	init() {
		/// #if EDITOR
		if (!this.onClickOutside) {
			game.editor.ui.status.warn('onClickOutside event handler is empty.', 32020, this, 'onClickOutside', undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
		}
		if (this.findParentByType(Button)) {
			game.editor.ui.status.warn('ClickOutsideTrigger can not work inside Button.', 99999, this, undefined, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
		}
		/// #endif

		super.init();

		all.push(this);

		this._insideContainers = [this
			/// #if EDITOR
			, overlayLayer
			/// #endif
		];
		if (this.additionalContainers) {
			for (let path of this.additionalContainers) {
				let c = getValueByPath(path, this);
				/// #if EDITOR
				if (!(c instanceof Container)) {
					game.editor.ui.status.error('Wrong "additionalContainers" entry: ' + path, 10070, this, 'additionalContainers');
					c = this;
					continue;
				}
				/// #endif
				this._insideContainers.push(c);
			}
		}
		globalPointerDownEvents.push(this.pointerDownListener);
		for (let o of this._insideContainers) {
			o.on('pointerdown', this.onThisDown);
		}
	}

	onRemove() {
		for (let o of this._insideContainers) {
			o.off('pointerdown', this.onThisDown);
		}
		all.splice(all.indexOf(this), 1);
		globalPointerDownEvents.splice(globalPointerDownEvents.indexOf(this.pointerDownListener), 1);
		super.onRemove();
	}

	onThisDown(ev: PointerEvent | FederatedPointerEvent) {
		if (ev.buttons !== 4 && (!ev.target || (ev.target as Container).isCanBePressed)) {
			this.thisDownTime = game.time;
		}
	}

	onStageDown(ev: PointerEvent) {
		if (ev.buttons !== 4) {
			if (this.thisDownTime !== game.time && game.time === this.gameTime) {
				this.fire();
			}
		}
	}

	fire() {
		if (this.onClickOutside) {
			callByPath(this.onClickOutside, this);
		}
	}

	update() {
		this.gameTime = game.time;
		super.update();
	}

	static shootAll(exceptContainer?: Container) {
		loop1: for (const o of all) {
			if (o.getRootContainer() === game.currentContainer) {
				if (exceptContainer) {
					let p = exceptContainer;
					while (p) {
						if (o._insideContainers.includes(p) && p.isCanBePressed) {
							continue loop1;
						}
						p = p.parent;
					}
				}
				o.fire();
			}
		}
	}

	/// #if EDITOR
	__EDITOR_onCreate() {
		window.setTimeout(() => {
			editorUtils.centralizeObjectToContent(this);
		}, 0);
	}
	/// #endif
}

/// #if EDITOR
ClickOutsideTrigger.__EDITOR_icon = 'tree/click-outside';
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/container.c.ts">
import type { Filter, Point } from 'pixi.js';
import { Container, DisplayObject } from 'pixi.js';
import { _editableEmbed } from 'thing-editor/src/editor/props-editor/editable.js';
import LabelsLogger from 'thing-editor/src/editor/ui/labels-logger';

import DataPathFixer from 'thing-editor/src/editor/utils/data-path-fixer';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags.js';
import { decorateGotoLabelMethods } from 'thing-editor/src/editor/utils/goto-label-consumer';
import roundUpPoint from 'thing-editor/src/editor/utils/round-up-point';
/// #if EDITOR
import R from 'thing-editor/src/engine/basic-preact-fabrics';
/// #endif
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import { PREFAB_PIVOT } from 'thing-editor/src/editor/ui/viewport';
import assert from 'thing-editor/src/engine/debug/assert.js';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import ___Guide from 'thing-editor/src/engine/lib/assets/src/___system/guide.c';
import Scene from './scene.c';

/** returns object rotation relative to it`s scene */
Container.prototype.getGlobalRotation = function getGlobalRotation() {
	let ret = this.rotation;
	let p = this.parent;
	while (p && p !== game.stage) {
		ret += p.rotation;
		p = p.parent;
	}
	return ret;
};

Container.prototype.getScenePosition = function getScenePosition(resultPoint: Point, skipUpdate = false) {
	return game.stage.toLocal(this, this.parent, resultPoint, skipUpdate);
};

Container.prototype.getRootContainer = function getRootContainer() {
	let p = this;
	while (p && (p.parent !== game.stage) && p.parent) {
		p = p.parent;
	}
	return p;
};

Container.prototype.detachFromParent = function detachFromParent() {
	if (this.parent) {
		this.parent.removeChild(this);
	}
};

Container.prototype.init = function init() {
	/// #if EDITOR
	EDITOR_FLAGS._root_initCalled.delete(this);
	/// #endif
};

Container.prototype.onRemove = function onRemove() {
	/// #if EDITOR
	EDITOR_FLAGS._root_onRemovedCalled.delete(this);
	assert(!game.__EDITOR_mode || EDITOR_FLAGS.isStoppingTime, '\'onRemove()\' called in edition mode');
	/// #endif
};

Container.prototype.remove = function remove() {
	Lib.destroyObjectAndChildren(this, true);
};

/// #if EDITOR
const ACTION_ICON_REMOVE = R.img({ src: '/thing-editor/img/timeline/remove.png' });
(Container.prototype.remove as SelectableProperty).___EDITOR_actionIcon = ACTION_ICON_REMOVE;
(Container.prototype.remove as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(Container.prototype.remove as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

/// #endif

Container.prototype.removeWithoutHolder = function remove() {
	Lib.destroyObjectAndChildren(this);
};

Container.prototype.findParentByType = function (classType) {
	assert(classType.prototype instanceof Container, 'Container inherited class expected.', 10053);
	let p = this.parent;
	while (p && !(p instanceof classType)) {
		p = p.parent;
	}
	return p;
};

Container.prototype.findParentByName = function (name) {
	let p = this.parent;
	while (p && p.name !== name) {
		p = p.parent;
	}
	return p;
};

Container.prototype.addFilter = function addFilter(f) {
	if (!this.filters) {
		this.filters = [f];
	} else {
		this.filters.push(f);
	}
};

Container.prototype.removeFilter = function removeFilter(this: Container, f) {
	let i = (this.filters as Filter[])?.indexOf(f);
	if (i >= 0) {
		(this.filters as Filter[]).splice(i, 1);
	}
};

/// #if EDITOR


Container.prototype.__onSelect = function __onSelect() {
	let p = this.parent;
	while (p !== game.stage) {
		if (p.__onChildSelected) {
			p.__onChildSelected();
		}
		p = p.parent;
	}
};

/// #endif


Container.prototype.update = function update() {
	for (let c of this.children) {
		c.update();
	}
};

let _findChildName = '';
let _findChildRet: Container | undefined;
const _findChildInner = (o: Container) => {
	if (o.name === _findChildName) {
		assert(!_findChildRet, 'More that one element with name "' + _findChildName + '" exists.', 10006);
		_findChildRet = o;
	}
};

Container.prototype.findChildByName = function findChildByName(name: string): Container | undefined {
	assert(name, 'Empty name received.', 10005);
	_findChildName = name;
	_findChildRet = undefined;
	this.forAllChildren(_findChildInner);
	return _findChildRet;
};

let findByTypeRet: Container[];
let findByTypeClass: SourceMappedConstructor;

const _findByTypeInner = (o: Container) => {
	if (o instanceof findByTypeClass) {
		findByTypeRet.push(o);
	}
};

/// #if DEBUG

Container.prototype.getChildByName = function (this: Container, name: string, debugThis: Container) {
	let ret;
	for (let c of this.children) {
		if (c.name === name) {
			if (ret) {
				let errorTxt = 'getChildByName called, but more that one object with name \'' + name + '\' present in container ' + this.___info;
				/// #if EDITOR
				game.editor.ui.status.error(errorTxt, 10052, debugThis || ret);
				/*
				/// #endif
				alert(errorTxt);
				//*/
				return null;
			}
			ret = c;
		}
	}
	return ret;
} as any;

/// #endif

Container.prototype.findChildrenByType = function <T extends Container>(classType: new () => T): T[] {
	assert(classType.prototype instanceof DisplayObject, 'Container inherited class expected.', 10053);
	findByTypeClass = classType as unknown as SourceMappedConstructor;
	findByTypeRet = [];
	this.forAllChildren(_findByTypeInner);
	return findByTypeRet as T[];
};

let findByNameName: string;

const _findByNameInner = (o: Container) => {
	if (o.name === findByNameName) {
		findByTypeRet.push(o);
	}
};

Container.prototype.findChildrenByName = function (name) {
	assert(name, 'Name expected', 10054);
	findByNameName = name;
	findByTypeRet = [];
	this.forAllChildren(_findByNameInner);
	return findByTypeRet;
};

assert(!Container.prototype.forAllChildren, 'forAllChildren method needs renaming, because of PIXI changes.');

Container.prototype.forAllChildren = function (callback) {
	for (let o of this.children) {
		callback(o);
		o.forAllChildren(callback);
	}
};


Object.defineProperty(Container.prototype, 'isCanBePressed', {
	get: function () {
		if (!this.interactive || game.isAllButtonsDisabled) return false;
		let p = this.parent;
		while (p !== game.stage && p.interactiveChildren && p.visible) {
			p = p.parent;
			if (!p) {
				return false;
			}
		}
		return p.interactiveChildren && p.visible;
	},
	enumerable: true
});


Object.defineProperties(Container.prototype, {
	'scale.x': {
		get: function () {
			return this.transform.scale.x;
		},
		set: function (val: number) {
			this.transform.scale.x = val;
		}, configurable: true
	}, 'scale.y': {
		get: function () {
			return this.transform.scale.y;
		},
		set: function (val: number) {
			this.transform.scale.y = val;
		}, configurable: true
	},
	'skew.x': {
		get: function () {
			return this.transform.skew.x;
		},
		set: function (val: number) {
			this.transform.skew.x = val;
		}, configurable: true
	}, 'skew.y': {
		get: function () {
			return this.transform.skew.y;
		},
		set: function (val: number) {
			this.transform.skew.y = val;
		}, configurable: true
	},
	'pivot.x': {
		get: function () {
			return this.transform.pivot.x;
		},
		set: function (val: number) {
			this.transform.pivot.x = val;
		}, configurable: true
	}, 'pivot.y': {
		get: function () {
			return this.transform.pivot.y;
		},
		set: function (val: number) {
			this.transform.pivot.y = val;
		}, configurable: true
	}
});


export default Container;

/// #if EDITOR

Object.defineProperties(Container.prototype, {
	'worldAlpha': {
		get: function (this: Container): number {
			return ((this.__hideInEditor || this.__nodeExtendData?.isolate) && game.__EDITOR_mode) ? 0 : (this as any)._worldAlpha;
		},
		set: function (v: number) {
			this._worldAlpha = v;
		}
	}
});


Object.defineProperties(Container.prototype, {
	'___info': {
		get: function () {
			let ret = getObjectInfo(this);
			let p = this.parent;
			while (p && (p !== game.stage)) {
				ret += ' > ' + getObjectInfo(p);
				p = p.parent;
			}
			return ret;
		}
	}
});

const FILTERED_PROPS = new Set([
	'zIndex',
	'transform',
	'tabIndex',
	'sortableChildren',
	'sortDirty',
	'skew',
	'scale',
	'renderable',
	'renderId',
	'position',
	'pivot',
	'localTransform',
	'isSprite',
	'isMask',
	'getLocalBounds',
	'eventMode',
	'destroyed',
	'cacheAsBitmap',
	'cullable',
	'accessibleType',
	'accessiblePointerEvents',
	'_tempDisplayObjectParent',
	'accessible',
	'accessibleChildren'
]);

Container.prototype.__EDITOR_filterPropsSelection = (propertyName:string): boolean => {
	return FILTERED_PROPS.has(propertyName);
};

Container.__EDITOR_filterPropsSelection = (propertyName:string): boolean => {
	return propertyName === 'defaultSortableChildren';
};

Container.prototype.__isAnyChildSelected = function __isAnyChildSelected(): boolean {
	for (let o of game.editor.selection) {
		while (o) {
			if (o === this) {
				return true;
			}
			o = o.parent;
		}
	}
	return false;
};

(Container.prototype.destroy as SelectableProperty).___EDITOR_isHiddenForChooser = true;
Container.__EDITOR_icon = 'tree/container';

const getObjectInfo = (o: Container) => {
	return ('[' + (o.constructor as SourceMappedConstructor).__className + ':' + o.name + ']');
};

const preventOverridingPop = {
	type: 'boolean',
	visible: (o:Container) => o === game.currentContainer,
	disabled: (o:Container) => o.__preventOverriding,
	beforeEdited: (val:boolean) => {
		if (val) {
			if (game.editor.selection.some((o) =>{
				const isScene = o instanceof Scene;
				const asset = fs.getFileByAssetName(o.name!, isScene ? AssetType.SCENE : AssetType.PREFAB);
				if (!asset.lib) {
					return true;
				}
			})) {
				return 'asset should be located in a library.';
			}
		}
	}
} as EditablePropertyDescRaw<Container>;

_editableEmbed(Container, '__root-splitter', { type: 'splitter', title: 'Basic props' });
_editableEmbed(Container, 'name', {
	type: 'string',
	parser: (name: string): string => {
		return name && name.replace('.', '_').replace('#', '_').replace('`', '_').replace(',', '_');
	},
	disabled: (node: Container) => {
		if (node.parent === game.stage) {
			return 'root object`s name can not be edited because it is always equal to scene`s or prefab`s name.';
		}
	},
	beforeEdited: (val: string) => {
		DataPathFixer.beforeNameEdit(val);
	},
	onBlur: () => {
		DataPathFixer.onNameBlur();
	}
});
_editableEmbed(Container, 'x', { animate: true });
_editableEmbed(Container, 'y', { animate: true });
_editableEmbed(Container, 'rotation', {
	step: 0.001, animate: true,
	afterEdited: () => {
		game.editor.selection.forEach((c, i) => {
			if (game.keys.shiftKey) {
				const prevRotation = c.rotation;
				const eatenRotation = (c.__nodeExtendData.eatenRotation || 0);
				c.rotation = Math.round((c.rotation + eatenRotation) / Math.PI * 8) * Math.PI / 8;
				c.__nodeExtendData.eatenRotation = eatenRotation + prevRotation - c.rotation;
			}
			___Guide.show(0, 0, 0, 'rotation' + i, c);
		});
	}
});
_editableEmbed(Container, 'alpha', {
	animate: true,
	step: 0.01,
	min: 0,
	max: 1
});
_editableEmbed(Container, 'visible', { animate: true });
_editableEmbed(Container, 'interactive');

_editableEmbed(Container, 'splitter-helpers', { type: 'splitter', title: 'Helpers' });

_editableEmbed(Container, 'angle', {
	notSerializable: true,
	afterEdited: () => {
		for (const o of game.editor.selection) {
			game.editor.onObjectsPropertyChanged(o, 'rotation', o.rotation);

		}
	}
});

_editableEmbed(Container, '__hideInEditor', { type: 'boolean', tip: 'hide object in viewport during editor mode' });
_editableEmbed(Container, '__doNotSelectByClick', { type: 'boolean', tip: 'prevent object to be selected by viewport click' });
_editableEmbed(Container, '__description', { type: 'string', multiline: true });
_editableEmbed(Container, '__prefabPivot', { type: 'string', disabled: () => true, default: PREFAB_PIVOT.MIDDLE, visible: (o) => {
	return !(o instanceof Scene) && o === game.currentContainer;
} });
_editableEmbed(Container, '__hideChildren', { type: 'boolean', tip: 'hide children in tree' });
_editableEmbed(Container, '__preventOverriding', preventOverridingPop);
_editableEmbed(Container, '___id', {
	type: 'number',
	noNullCheck: true,
	disabled: () => {
		return true;
	}
});

const alignX = () => { ///99999
	let firstObject = game.editor.selection[0];
	let p = firstObject.getRootContainer().toLocal(firstObject, firstObject.parent);
	for (let i = 1; i < game.editor.selection.length; i++) {
		let o = game.editor.selection[i];
		game.editor.onObjectsPropertyChanged(o, 'x', roundUpPoint(o.parent.toLocal(p, firstObject.getRootContainer())).x);
	}
};
_editableEmbed(Container, 'splitter-transform', { type: 'btn', name: 'Align X ↔', onClick: alignX });
const alignY = () => { ///99999
	let firstObject = game.editor.selection[0];
	let p = firstObject.getRootContainer().toLocal(firstObject, firstObject.parent);
	for (let i = 1; i < game.editor.selection.length; i++) {
		let o = game.editor.selection[i];
		game.editor.onObjectsPropertyChanged(o, 'y', roundUpPoint(o.parent.toLocal(p, firstObject.getRootContainer())).y);
	}
};
_editableEmbed(Container, 'splitter-transform', { type: 'btn', name: 'Align Y ↕', onClick: alignY });

_editableEmbed(Container, 'splitter-transform', { type: 'splitter', title: 'Transform' });
_editableEmbed(Container, 'scale.x', { step: 0.01, default: 1, animate: true });
_editableEmbed(Container, 'scale.y', { step: 0.01, default: 1, animate: true });
_editableEmbed(Container, 'skew.x', { step: 0.01, animate: true });
_editableEmbed(Container, 'skew.y', { step: 0.01, animate: true });
_editableEmbed(Container, 'pivot.x', { animate: true });
_editableEmbed(Container, 'pivot.y', { animate: true });
/// #endif


/// #if EDITOR
let goToLabelRecursionLevel = 0; // eslint-disable-line @typescript-eslint/no-unused-vars
/// #endif

Container.prototype.gotoLabelRecursive = function (labelName) {
	/// #if EDITOR
	if (!goToLabelRecursionLevel) {
		LabelsLogger.logGotoLabelRecursive(labelName, this);
	}
	goToLabelRecursionLevel++;
	/// #endif
	for (let c of this.children) {
		c.gotoLabelRecursive(labelName);
	}
	/// #if EDITOR
	goToLabelRecursionLevel--;
	/// #endif
};

/// #if EDITOR
decorateGotoLabelMethods(Container as any);
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/d-sprite.c.ts">
import { Sprite } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';

export default class DSprite extends Sprite {
	constructor() {
		super();
		this.anchor.set(0.5);
	}

	@editable({ step: 0.001, animate: true })
	xSpeed = 0;

	@editable({ step: 0.001, animate: true })
	ySpeed = 0;

	@editable({ step: 0.001, animate: true })
	rSpeed = 0;

	angleBySpeed() {
		this.rotation = Math.atan2(this.ySpeed, this.xSpeed);
	}

	update() {
		this.x += this.xSpeed;
		this.y += this.ySpeed;
		this.rotation += this.rSpeed;
		super.update();
	}
}

/// #if EDITOR
DSprite.__EDITOR_icon = 'tree/dsprite';
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/fill.c.ts">
import type { ITypedArray } from 'pixi.js';
import { Mesh, MeshMaterial, PlaneGeometry, Program, Texture, WRAP_MODES } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import Lib from 'thing-editor/src/engine/lib';

const PI_2 = Math.PI * 2;

const vertexSrc = `

	precision mediump float;

	attribute vec2 aVertexPosition;
	attribute float aColor;
	attribute vec2 aTextureCoord;

	uniform mat3 translationMatrix;
	uniform mat3 projectionMatrix;
	uniform vec4 uColor;

	varying vec2 vUvs;
	varying vec4 vColor;

	void main() {

	vUvs = aTextureCoord;
	vColor = uColor * aColor;
	gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

}`;

const fragmentSrc = `

	precision mediump float;

	varying vec4 vColor;
	varying vec2 vUvs;

	uniform sampler2D uSampler;

	void main() {

	gl_FragColor = texture2D(uSampler, vUvs) * vColor;
}`;


/// #if EDITOR
const isWrapDisabled = (o: Fill) => {
	if (!o.image) {
		return 'image property is not set.';
	}

	if (Lib.__isSystemTexture(o.texture, o.image)) {
		return 'System image ' + o.image + ' can not has wrapping mode.';
	}

	if (!o.texture.baseTexture.isPowerOfTwo) {
		return 'Texture should have size power of two (32, 64, 128, 256...) to be wrapped.';
	}
};

const TEXTURE_WRAP_MODE_DESC: EditablePropertyDescRaw<Fill> = {
	notSerializable: true,
	select: [
		{ name: 'CLAMP', value: WRAP_MODES.CLAMP },
		{ name: 'REPEAT', value: WRAP_MODES.REPEAT },
		{ name: 'MIRRORED_REPEAT', value: WRAP_MODES.MIRRORED_REPEAT }
	],
	disabled: isWrapDisabled as any
};

/// #endif

export default class Fill extends Mesh {

	_verticesX = 2;
	@editable({ min: 2, max: 30, important: true })
	set verticesX(v) {
		if (this._verticesX !== v) {
			this._verticesX = v;
			this.meshResized = true;
		}
	}

	get verticesX() {
		return this._verticesX;
	}

	_verticesY = 2;
	@editable({ min: 2, max: 30, important: true })
	set verticesY(v) {
		if (this._verticesY !== v) {
			this._verticesY = v;
			this.meshResized = true;
		}
	}

	get verticesY() {
		return this._verticesY;
	}

	_xRepeat = 1;
	@editable({ step: 0.001, min: 0.00001 })
	get xRepeat() {
		return this._xRepeat;
	}

	set xRepeat(v) {
		if (this._xRepeat !== v) {
			this._xRepeat = v;
			this.fillUpdated = true;
		}
	}

	_yRepeat = 1;
	@editable({ step: 0.001, min: 0.00001 })
	get yRepeat() {
		return this._yRepeat;
	}

	set yRepeat(v) {
		if (this._yRepeat !== v) {
			this._yRepeat = v;
			this.fillUpdated = true;
		}
	}

	_xShift = 0;
	@editable({ step: 0.0001 })
	get xShift() {
		return this._xShift;
	}

	set xShift(v) {
		if (this._xShift !== v) {
			this._xShift = v;
			this.fillUpdated = true;
		}
	}

	_yShift = 0;
	@editable({ step: 0.0001 })
	get yShift() {
		return this._yShift;
	}

	set yShift(v) {
		if (this._yShift !== v) {
			this._yShift = v;
			this.fillUpdated = true;
		}
	}

	@editable({ step: 0.0001 })
	xShiftSpeed = 0;
	/// #if EDITOR
	@editable()
	get ___xShiftSpeedPixels() : number {
		return this.xShiftSpeed * (this.texture ? this.texture.width : 0) / this.xRepeat * this.scale.x;
	}

	set ___xShiftSpeedPixels(val: number) {
		this.xShiftSpeed = val / (this.texture ? this.texture.width : 0) * this.yRepeat / this.scale.x;
	}
	/// #endif
	@editable({ step: 0.0001 })
	yShiftSpeed = 0;

	/// #if EDITOR
	@editable()
	get ___yShiftSpeedPixels() : number {
		return this.yShiftSpeed * (this.texture ? this.texture.height : 0) / this.yRepeat * this.scale.y;
	}

	set ___yShiftSpeedPixels(val: number) {
		this.yShiftSpeed = val / (this.texture ? this.texture.height : 1) * this.yRepeat / this.scale.y;
	}

	@editable(TEXTURE_WRAP_MODE_DESC)
	set TEXTURE_WRAP_MODE(v: number) {
		if (this.texture && this.image) {
			let bits = 0;
			if (v === WRAP_MODES.REPEAT) {
				bits = 8;
			} else if (v === WRAP_MODES.MIRRORED_REPEAT) {
				bits = 16;
			}
			editorUtils.__setTextureSettingsBits(this.image, bits, 24);
		}
	}

	get TEXTURE_WRAP_MODE() {
		return this.texture ? this.texture.baseTexture.wrapMode : WRAP_MODES.CLAMP;
	}
	/// #endif

	_xWaveAmp = 0;
	@editable({ step: 0.001 })
	@editable({ type: 'splitter', title: 'Wave effect:', name: 'wave-effect' })
	get xWaveAmp() {
		return this._xWaveAmp;
	}

	set xWaveAmp(v) {
		if (this._xWaveAmp !== v) {
			this._xWaveAmp = v;
			this.fillUpdated = true;
		}
	}

	_xWaveStep = 1;
	@editable({ step: 0.001, visible: o => o.xWaveAmp !== 0 })
	get xWaveStep() {
		return this._xWaveStep;
	}

	set xWaveStep(v) {
		if (this._xWaveStep !== v) {
			this._xWaveStep = v;
			this.fillUpdated = true;
		}
	}

	_xWavePhase = 0;
	@editable({ step: 0.001, min: 0, max: PI_2, visible: o => o.xWaveAmp !== 0 })
	get xWavePhase() {
		return this._xWavePhase;
	}

	set xWavePhase(v) {
		if (this._xWavePhase !== v) {
			this._xWavePhase = v;
			this.fillUpdated = true;
		}
	}

	@editable({ step: 0.0001, visible: o => o.xWaveAmp !== 0 })
	xWaveSpeed = 0;

	_yWaveAmp = 0;
	@editable({ step: 0.001 })
	get yWaveAmp() {
		return this._yWaveAmp;
	}

	set yWaveAmp(v) {
		if (this._yWaveAmp !== v) {
			this._yWaveAmp = v;
			this.fillUpdated = true;
		}
	}

	_yWaveStep = 1;
	@editable({ step: 0.001, visible: o => o.yWaveAmp !== 0 })
	get yWaveStep() {
		return this._yWaveStep;
	}

	set yWaveStep(v) {
		if (this._yWaveStep !== v) {
			this._yWaveStep = v;
			this.fillUpdated = true;
		}
	}

	_yWavePhase = 0;
	@editable({ step: 0.001, min: 0, max: PI_2, visible: o => o.yWaveAmp !== 0 })
	get yWavePhase() {
		return this._yWavePhase;
	}

	set yWavePhase(v) {
		if (this._yWavePhase !== v) {
			this._yWavePhase = v;
			this.fillUpdated = true;
		}
	}

	@editable({ step: 0.0001, visible: o => o.yWaveAmp !== 0 })
	yWaveSpeed = 0;

	transparencyUpdated = false;
	_transparentTop = false;

	@editable()
	@editable({ type: 'splitter', title: 'Transparency:', name: 'Transparency' })
	set transparentTop(v) {
		if (this._transparentTop !== v) {
			this._transparentTop = v;
			this.transparencyUpdated = true;
		}
	}

	get transparentTop() {
		return this._transparentTop;
	}

	_transparentBottom = false;
	@editable()
	set transparentBottom(v) {
		if (this._transparentBottom !== v) {
			this._transparentBottom = v;
			this.transparencyUpdated = true;
		}
	}

	get transparentBottom() {
		return this._transparentBottom;
	}

	_transparentLeft = false;
	@editable()
	set transparentLeft(v) {
		if (this._transparentLeft !== v) {
			this._transparentLeft = v;
			this.transparencyUpdated = true;
		}
	}

	get transparentLeft() {
		return this._transparentLeft;
	}

	_transparentRight = false;
	@editable()
	set transparentRight(v) {
		if (this._transparentRight !== v) {
			this._transparentRight = v;
			this.transparencyUpdated = true;
		}
	}

	get transparentRight() {
		return this._transparentRight;
	}


	constructor() {
		super(new PlaneGeometry(2, 2, 2, 2), new MeshMaterial(Texture.WHITE, {
			program: Program.from(vertexSrc, fragmentSrc)
		}));
		this.geometry.addAttribute('aColor',
			[0, 0, 1, 1], 1);

		/// #if EDITOR
		editorEvents.on('textureUpdated', (textureName: string) => {
			if (textureName === this.image) {
				this.refreshSize();
			}
		});

		/// #endif
	}

	_applied_verticesX = 0;
	_applied_verticesY = 0;
	fillUpdated = false;
	meshResized = false;

	refreshSize() {
		let g = this.geometry as PlaneGeometry;
		g.segWidth = this.verticesX;
		g.segHeight = this.verticesY;

		g.width = this.texture.width;
		g.height = this.texture.height;
		g.build();
		this._applied_verticesX = this.verticesX;
		this._applied_verticesY = this.verticesY;
		this.updateFilling();
		this.fillUpdated = false;
		this.updateTransparency();
	}

	cropLeftRight(leftSize: number, rightSize: number) {
		let textureW = this.texture.width;
		leftSize /= textureW;
		rightSize /= textureW;
		if (leftSize < 0) {
			leftSize = 0;
		}
		if (rightSize < 0) {
			rightSize = 0;
		}
		this.scale.x = Math.min(1, 1 - leftSize - rightSize);
		this.xRepeat = this.scale.x;
		this.xShift = leftSize;
	}

	cropTopBottom(topSize: number, bottomSize: number) {
		let textureH = this.texture.height;
		topSize /= textureH;
		bottomSize /= textureH;
		if (topSize < 0) {
			topSize = 0;
		}
		if (bottomSize < 0) {
			bottomSize = 0;
		}
		this.scale.y = Math.min(1, 1 - topSize - bottomSize);
		this.yRepeat = this.scale.y;
		this.yShift = topSize;
	}

	update() {
		if (this.xShiftSpeed !== 0) {
			this.xShift += this.xShiftSpeed;
			if (this._xShift > 2) {
				this._xShift -= 2;
			} else if (this._xShift < -2) {
				this._xShift += 2;
			}
		}
		if (this.yShiftSpeed !== 0) {
			this.yShift += this.yShiftSpeed;
			if (this._yShift > 2) {
				this._yShift -= 2;
			} else if (this._yShift < -2) {
				this._yShift += 2;
			}
		}

		if (this.xWaveSpeed !== 0) {
			this.xWavePhase += this.xWaveSpeed;
			if (this._xWavePhase > PI_2) {
				this._xWavePhase -= PI_2;
			} else if (this._xWavePhase < 0) {
				this._xWavePhase += PI_2;
			}
		}

		if (this.yWaveSpeed !== 0) {
			this.yWavePhase += this.yWaveSpeed;
			if (this._yWavePhase > PI_2) {
				this._yWavePhase -= PI_2;
			} else if (this._yWavePhase < 0) {
				this._yWavePhase += PI_2;
			}
		}
		super.update();
		/// #if EDITOR
		if (this.texture?.baseTexture) {
			this.texture.baseTexture.touched = EDITOR_FLAGS.__touchTime;
		}
		/// #endif
	}

	set texture(v) {
		if (v !== super.texture) {

			this.meshResized = this.meshResized ||
				/// #if EDITOR
				!super.texture.valid ||
				/// #endif
				(super.texture.width !== v.width || super.texture.height !== v.height);

			super.texture = v;
		}
	}

	get texture() {
		return super.texture;
	}

	render(renderer: any) {
		this.validateFill();
		super.render(renderer);
	}

	_renderCanvas(renderer: any) {
		this.validateFill();
		//@ts-ignore
		super._renderCanvas(renderer);
	}

	validateFill() {
		if (this.meshResized) {
			this.refreshSize();
			this.meshResized = false;
		}
		if (this.fillUpdated) {
			this.updateFilling();
			this.fillUpdated = false;
		}
		if (this.transparencyUpdated) {
			this.updateTransparency();
		}
	}

	calculateVertices() {
		if (this.meshResized) {
			this.refreshSize();
			this.meshResized = false;
		}
		super.calculateVertices();
	}

	updateTransparency() {
		let len = this.verticesX * this.verticesY;

		let buffer = this.geometry.buffers[3];

		if (buffer.data.length !== len) {
			buffer.data = new Float32Array(len) as unknown as ITypedArray;
		}
		let a = buffer.data;

		for (let i = 0; i < len; i++) {
			a[i] = 1;
		}

		if (this.transparentTop) {
			for (let i = this.verticesX - 1; i >= 0; i--) {
				a[i] = 0;
			}
		}

		if (this.transparentBottom) {
			for (let i = len - this.verticesX; i < len; i++) {
				a[i] = 0;
			}
		}

		if (this.transparentLeft) {
			for (let i = 0; i < len; i += this.verticesX) {
				a[i] = 0;
			}
		}

		if (this.transparentRight) {
			for (let i = this.verticesX - 1; i < len; i += this.verticesX) {
				a[i] = 0;
			}
		}

		buffer.update();
		this.transparencyUpdated = false;
	}

	updateFilling() {
		let a = this.uvBuffer.data;
		let i = 0;
		let curxShift, curyShift;
		curyShift = this._yShift;
		let stepsX = this.verticesX - 1;
		let stepsY = this.verticesY - 1;
		let xStep = this._xRepeat / stepsX;
		let yStep = this._yRepeat / stepsY;
		let xWaveStep = this._xWaveStep / stepsX;
		let yWaveStep = this._yWaveStep / stepsY;

		if (this._xWaveAmp !== 0 || this._yWaveAmp !== 0) {

			let curYWavePhase = this._yWavePhase;
			for (let y = 0; y <= stepsY; y++) {

				curxShift = this._xShift + Math.sin(curYWavePhase) * this._yWaveAmp;
				let curXWavePhase = this._xWavePhase;
				for (let x = 0; x <= stepsX; x++) {

					a[i++] = curxShift;
					a[i++] = curyShift + Math.sin(curXWavePhase) * this._xWaveAmp;
					curxShift += xStep;
					curXWavePhase += xWaveStep;
				}
				curYWavePhase += yWaveStep;
				curyShift += yStep;
			}
		} else {
			for (let y = 0; y <= stepsY; y++) {
				curxShift = this._xShift;
				for (let x = 0; x <= stepsX; x++) {
					a[i++] = curxShift;
					a[i++] = curyShift;
					curxShift += xStep;
				}
				curyShift += yStep;
			}
		}
		this.uvBuffer.update();
	}
}

/// #if EDITOR
Fill.__EDITOR_icon = 'tree/fill';
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/fly-text.c.ts">
import type { Container } from 'pixi.js';
import { Text } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';

export default class FlyText extends Text {

	phase = 0;

	init() {
		super.init();
		this.phase = 0;
	}

	hide() {
		this.phase = 0;
	}

	update() {
		super.update();
		this.y -= 1.0;
		this.phase--;
		if (this.phase <= 0) {
			this.alpha -= 0.05;
			if (this.alpha <= 0.0) {
				this.remove();
			}
		} else {
			if (this.alpha < 0.95) {
				this.alpha += 0.2;
			}
		}
	}

	static flyText(text: string, X: number | null = null, Y: number | null = null, type = 'fly-text', lengthAdd = 0, container?: Container | string) {
		assert(!game.__EDITOR_mode, 'Attempt to call FlyText.flyText() in editing mode.', 10010);
		assert(game.currentContainer, 'FlyText.flyText() can be invoked only after first scene has been shown', 10011);


		if (typeof X !== 'number') {
			X = game.W / 2;
		}
		if (typeof Y !== 'number') {
			Y = game.H / 2;
		}

		let f = Lib.loadPrefab(type) as FlyText;
		assert(f instanceof FlyText, 'FlyText instance expected.', 10011);
		if (typeof text !== 'string') {
			text = (text as any).toString();
		}
		f.text = text;
		f.phase = text.length * 6 + lengthAdd;

		if (container) {
			if (typeof container === 'string') {
				container = getValueByPath(container, game.currentContainer);
			}
		} else {
			container = game.currentContainer;
			let fld = (f.width / 2) + 5.0;

			if (X < fld) {
				X = fld;
			}

			if (X > (game.W - fld)) {
				X = (game.W - fld);
			}
		}

		f.alpha = 0.0;
		f.x = X;
		f.y = Y;

		(container as Container).addChild(f);
		return f;
	}
}


/// #if EDITOR

FlyText.__EDITOR_icon = 'tree/fly-text';

(FlyText as SelectableProperty).flyText.___EDITOR_isGoodForCallbackChooser = true;
(FlyText as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(FlyText as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;

(FlyText.flyText as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return game.editor.ui.modal.showPrompt('Enter text to show', 'Text-1', undefined, game.editor.validateCallbackParameter);
};
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/movie-clip.c.ts">
import editable from 'thing-editor/src/editor/props-editor/editable';
import LabelsLogger from 'thing-editor/src/editor/ui/labels-logger';
import Timeline from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline';
import getPrefabDefaults from 'thing-editor/src/editor/utils/get-prefab-defaults';
import { decorateGotoLabelMethods, gotoLabelHelper } from 'thing-editor/src/editor/utils/goto-label-consumer';
import makePathForKeyframeAutoSelect from 'thing-editor/src/editor/utils/movie-clip-keyframe-select-path';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import type { TimelineData, TimelineFieldData, TimelineFrameValuesCache, TimelineKeyFrame, TimelineLabelData, TimelineSerializedData, TimelineSerializedKeyFrame, TimelineSerializedLabelsData } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import FieldPlayer, { TimelineKeyFrameType } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip/field-player';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import Pool from 'thing-editor/src/engine/utils/pool';

/// #if EDITOR
import type { Container } from 'pixi.js';
import type { IGoToLabelConsumer } from 'thing-editor/src/editor/editor-env';
import R from 'thing-editor/src/editor/preact-fabrics';
import DataPathEditor from 'thing-editor/src/editor/ui/props-editor/props-editors/data-path-editor';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import { getCurrentStack, showStack } from 'thing-editor/src/editor/utils/stack-utils';
export const ACTION_ICON_STOP = R.img({ src: '/thing-editor/img/timeline/stop.png' });

const SELECT_LOG_LEVEL = [
	{ name: 'disabled', value: 0 },
	{ name: 'level 1', value: 1 },
	{ name: 'level 2', value: 2 },
	{ name: 'break on callbacks', value: 3 }
];
/// #endif

let idCounter = 1;

export default class MovieClip extends DSprite implements IGoToLabelConsumer {

	_seed = 0;

	fieldPlayers: FieldPlayer[] = [];

	_goToLabelNextFrame: string | false = false;

	@editable()
	isPlaying = true;

	@editable({ type: 'timeline', important: true, visible: (o) => !o.__nodeExtendData.isPrefabReference })
	set timeline(data: TimelineSerializedData) {
		this._goToLabelNextFrame = false;
		this._disposePlayers();

		if (data === null) {
			this._timelineData = null as any;
			return;
		}

		let desData!: TimelineData;

		if (!deserializeCache.has(data)
			/// #if EDITOR
			|| game.editor.disableFieldsCache
			/// #endif
		) {
			desData = MovieClip._deserializeTimelineData(data);
			/// #if EDITOR
			if (!game.editor.disableFieldsCache) {
				/// #endif
				deserializeCache.set(data, desData);
				/// #if EDITOR
				serializeCache.set(desData, data);
			}
			/// #endif
		} else {
			desData = deserializeCache.get(data);
		}

		assert(Array.isArray(data.f), 'Wrong timeline data?');
		this._timelineData = desData;

		let pow = desData.p;
		let damper = desData.d;
		let fieldsData = desData.f;
		for (let i = 0; i < fieldsData.length; i++) {
			let p = Pool.create(FieldPlayer);
			p.init(this, fieldsData[i], pow, damper);
			this.fieldPlayers.push(p);
		}
	}

	/// #if EDITOR
	//timeline reading has sense in editor mode only
	get timeline(): TimelineSerializedData | null { // -eslint-disable-line @typescript-eslint/adjacent-overload-signatures
		if (!this._timelineData) {
			return null;
		}
		if (!serializeCache.has(this._timelineData) ||
			game.editor.disableFieldsCache
		) {
			//console.warn("MovieClip serialization invoked >>>");
			let tl = this._timelineData;
			let fields = tl.f.map((f) => {
				return {
					n: f.n,
					t: f.t.map((k): TimelineSerializedKeyFrame => {
						let ret: TimelineSerializedKeyFrame = Object.assign({}, k);
						let tmpJ = ret.j as number;
						if (ret.j === ret.t && !k.___keepLoopPoint) {
							delete (ret.j);
						}

						if ((typeof (this as KeyedObject)[f.n]) !== 'number') {
							delete ret.s;
						}

						if (ret.m === 0) {
							delete ret.m;
						}
						if (ret.r === 0) {
							delete ret.r;
						} else if ((ret.r as number) > 0) {
							ret.r = Math.min(ret.r as number, (ret.n as TimelineKeyFrame).t as number - tmpJ - 1);
						}
						delete ret.n;
						return ret;
					})
				};
			});

			let labels: TimelineSerializedLabelsData = {};
			for (let key in tl.l) {
				let label = tl.l[key];
				labels[key] = label.t;
			}
			let c: TimelineSerializedData = {
				l: labels,
				p: tl.p,
				d: tl.d,
				f: fields
			};
			if (game.editor.disableFieldsCache) {
				return c;
			}
			serializeCache.set(this._timelineData, c);
		}
		return serializeCache.get(this._timelineData);
	}

	/// #endif

	@editable({ min: 0 })
	delay = 0;

	_timelineData!: TimelineData;

	update() {
		if (this.isPlaying) {
			if (this.delay > 0) {
				this.delay--;
			} else {
				if (this._goToLabelNextFrame) {
					let label = this._timelineData.l[this._goToLabelNextFrame];
					this._goToLabelNextFrame = false;
					let l = this.fieldPlayers.length;
					for (let i = 0; i < l; i++) {
						this.fieldPlayers[i].goto(label.t, label.n[i]);
					}
				}

				for (let p of this.fieldPlayers) {
					p.update();
				}
			}
		}
		super.update();
	}

	static _findNextKeyframe(timeLineData: TimelineKeyFrame[], time: number): TimelineKeyFrame {
		let ret;
		for (let f of timeLineData) {
			if (f.t > time) {
				return f;
			}
			ret = f;
		}
		return ret as TimelineKeyFrame;
	}

	static _deserializeTimelineData(timelineData: TimelineSerializedData): TimelineData {
		let fields: TimelineFieldData[] = timelineData.f.map((f) => {

			let fieldTimeline = f.t.map((k) => {
				/// #if EDITOR
				if (!k.hasOwnProperty('___react_id')) {
					k.___react_id = MovieClip.__generateKeyframeId();
				}
				/// #endif
				let ret = Object.assign({}, k);
				if (!ret.hasOwnProperty('j')) {
					ret.j = ret.t;
				}
				if (!ret.hasOwnProperty('m')) {
					ret.m = TimelineKeyFrameType.SMOOTH;
				}
				return ret;
			});
			for (let f of fieldTimeline) {
				f.n = MovieClip._findNextKeyframe(fieldTimeline as TimelineKeyFrame[], f.j as number);
			}
			return {
				n: f.n,
				t: fieldTimeline
			} as TimelineFieldData;
		});

		let labels: KeyedMap<TimelineLabelData> = {};
		for (let key in timelineData.l) {
			let labelTime = timelineData.l[key];
			let nextList = fields.map((field) => {
				return MovieClip._findNextKeyframe(field.t, labelTime - 1);
			});
			labels[key] = { t: labelTime, n: nextList, ___name: key };
		}

		const ret = {
			l: labels,
			p: timelineData.p,
			d: timelineData.d,
			f: fields
		};

		/// #if EDITOR
		fields.forEach((f, i) => {
			f.___timelineData = ret;
			f.___fieldIndex = i;
		});
		/// #endif

		return ret;
	}

	_disposePlayers() {
		while (this.fieldPlayers.length > 0) {
			Pool.dispose(this.fieldPlayers.pop());
		}
	}

	resetTimeline() {
		for (let p of this.fieldPlayers) {
			p.reset();
		}
	}

	hasLabel(labelName: string) {
		/// #if EDITOR
		if (!this._timelineData) {
			return;
		}
		/// #endif
		return this._timelineData.l.hasOwnProperty(labelName);
	}

	gotoLabel(labelName: string) {
		assert(this.hasLabel(labelName), 'Label \'' + labelName + '\' not found.', 10055);
		/// #if EDITOR
		if (this.__logLevel) {
			let stack = getCurrentStack('gotoLabel');
			if (this._goToLabelNextFrame && this._goToLabelNextFrame !== labelName) {
				game.editor.ui.status.warn(
					'CANCELED label: ' + this._goToLabelNextFrame + '; new label:' + labelName + '; time: ' + game.time,
					30021,
					this,
					undefined,
					true,
					undefined,
					StatusClearingCondition.LAUNCH_GAME
				);
			}
			game.editor.ui.status.warn(
				R.span(
					null,
					R.btn('Show stack...', () => {
						showStack(stack);
					}),
					(this._goToLabelNextFrame === labelName ? 'repeated gotoLabel: ' : 'gotoLabel: ') +
						labelName +
						'; time: ' +
						game.time
				),
				30020,
				this,
				undefined,
				true,
				undefined,
				StatusClearingCondition.LAUNCH_GAME
			);
		}
		/// #endif
		this._goToLabelNextFrame = labelName;
		this.play();
	}

	gotoRandomLabel() {
		assert(arguments.length > 1, 'Two or more arguments expected for method gotoRandomLabel.', 10056);

		const labelName = arguments[Math.floor(Math.random() * arguments.length)]; // eslint-disable-line prefer-rest-params

		if (labelName) {
			this.gotoLabel(labelName);
		}
	}

	gotoLabelIf(labelName: string, variablePath: string, invert?: boolean) {
		if ((!getValueByPath(variablePath, this)) !== (!invert)) {
			this.gotoLabel(labelName);
		}
	}

	play() {
		this.isPlaying = true;
	}

	stop() {
		this.isPlaying = false;
	}

	playRecursive() {
		this.isPlaying = true;
		for (let c of this.findChildrenByType(MovieClip)) {
			c.isPlaying = true;
		}
	}

	stopRecursive() {
		this.isPlaying = false;
		for (let c of this.findChildrenByType(MovieClip)) {
			c.isPlaying = false;
		}
	}

	gotoLabelRecursive(labelName: string): void {
		if (this.hasLabel(labelName)) {
			this.delay = 0;
			this.gotoLabel(labelName);
		}
		super.gotoLabelRecursive(labelName);
	}

	/// #if EDITOR

	init() {
		super.init();
		this._seed = Math.floor(Math.random() * 0x80000000);
		if ((this.constructor === MovieClip) && (!this._timelineData || !this._timelineData.f.length)) {
			game.editor.ui.status.warn('MovieClip ' + this.___info + ' has no timeline.', 32003, this, 'timeline', undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
		}

		let timelineData = this._timelineData;
		if (timelineData) {
			const fieldsData: TimelineFieldData[] = timelineData.f;
			for (let fieldNum = 0; fieldNum < fieldsData.length; fieldNum++) {
				const field = fieldsData[fieldNum];
				for (let kf of field.t) {
					if (kf.a === 'this.remove') {
						fieldNum++;
						for (; fieldNum < fieldsData.length; fieldNum++) {
							const field2 = fieldsData[fieldNum];
							for (let kf2 of field2.t) {
								if (kf2.a && kf2.a.startsWith('this.') && (kf.t === kf2.t)) {
									game.editor.ui.status.error(
										'MovieClip \'' + kf2.a + '\' action detected after \'this.remove\'. Its may cause invalid action. Please move \'this.remove\' action to the bottom field of the timeline.', 99999, this, makePathForKeyframeAutoSelect('timeline', field2, kf2));
								}
							}
						}
					}
				}
			}
		}
	}

	static __validateObjectData(data:SerializedObjectProps):SerializedDataValidationError | undefined {
		const timeline = data.timeline as TimelineData;
		if (timeline?.f.length === 1) {
			for (const f of timeline.f) {
				for (const k of f.t) {
					if (k.a?.startsWith('this.gotoLabel,')) {
						return {
							message: '"this.gotoLabel,..." action can be replaced with keyframe`s loop=' + timeline.l[k.a.split(',')[1]],
							findObjectCallback: (o:Container) => {
								return (o as MovieClip)._timelineData?.f.length === 1 && (o as MovieClip)._timelineData.f[0].t.some(_k => k.t === _k.t && _k.a?.startsWith('this.gotoLabel,'));
							},
							fieldName: 'timeline,' + f.n + ',' + k.t
						};
					}
				}
			}
		}
	}

	static __findPreviousKeyframe(timeLineData: TimelineKeyFrame[], time: number): TimelineKeyFrame {
		let ret;
		for (let f of timeLineData) {
			if (f.t > time) {
				return ret as TimelineKeyFrame;
			}
			ret = f;
		}
		return ret as TimelineKeyFrame;
	}

	__invalidateSerializeCache() {
		let timelineData = this._timelineData;
		Lib.__invalidateSerializationCache(this);
		deserializeCache.delete(serializeCache.get(timelineData));
		serializeCache.delete(timelineData);
		timelineData.f.forEach((f, i) => {
			f.___timelineData = timelineData;
			f.___fieldIndex = i;
		});
	}

	__onUnselect() {
		Timeline.deselectMovieClip(this);
	}


	static __generateKeyframeId() {
		return idCounter++;
	}

	__afterSerialization(data: SerializedObject) {
		if (data.p.timeline) { // remove animated props from object props
			for (let f of data.p.timeline.f) {
				delete data.p[f.n];
			}
		}
		if (this.__nodeExtendData.isPrefabReference) {
			delete data.p.timeline;
		}
	}

	__checkVisibilityForEditor() {
		if (game.__EDITOR_mode) {
			if (this._timelineData && this._timelineData.f) {
				let fields = this._timelineData.f;
				if (fields.find(f => f.n === 'visible')) {
					this.visible = this.visible || !this.__doNotSelectByClick;
				}
				if ((this.alpha < 0.1) && fields.find(f => f.n === 'alpha')) {
					this.alpha = 1;
				}
				if ((Math.abs(this.scale.x) < 0.02) && fields.find(f => f.n === 'scale.x')) {
					this.scale.x = 1;
				}
				if ((Math.abs(this.scale.y) < 0.02) && fields.find(f => f.n === 'scale.y')) {
					this.scale.y = 1;
				}
			}
		}
	}

	__afterDeserialization() {
		if (this._timelineData) { // remove animated props from object props
			for (let f of this._timelineData.f) {
				(this as KeyedMap<any>)[f.n] = f.t[0].v;
			}
		}
		if (game.__EDITOR_mode) {
			if ((this.constructor !== MovieClip) && (!this._timelineData)) {
				this.__initTimeline();
				Lib.__invalidateSerializationCache(this);
			}
			this.resetTimeline();
		}
	}

	__onSelect() {
		super.__onSelect();
		this.__checkVisibilityForEditor();
	}

	__onChildSelected() {
		this.__checkVisibilityForEditor();
	}

	___previewFrame = 0;

	@editable({ min: 0 })
	set __previewFrame(v) {
		this.___previewFrame = v;
		if (game.__EDITOR_mode) {
			this.resetTimeline();
		}
	}

	get __previewFrame() {
		return this.___previewFrame;
	}

	__applyValueToMovieClip(field: TimelineFieldData, time: number) {
		(this as KeyedObject)[field.n] = MovieClip.__getValueAtTime(field, time);
	}

	__applyCurrentTimeValuesToFields(time: number) {
		if (this._timelineData) {
			for (let f of this._timelineData.f) {
				this.__applyValueToMovieClip(f, time);
			}
		}
	}

	static __getValueAtTime(field: TimelineFieldData, time: number): number | boolean | string {
		if (!field.___cacheTimeline) {
			let fieldPlayer = Pool.create(FieldPlayer);
			let discretePositions: true[] = [];
			let c: TimelineFrameValuesCache = [] as any;
			field.___cacheTimeline = c;
			field.___discretePositionsCache = discretePositions;
			let wholeTimelineData = field.___timelineData;
			fieldPlayer.init({} as any, field, wholeTimelineData.p, wholeTimelineData.d);
			fieldPlayer.reset(true);
			calculateCacheSegmentForField(fieldPlayer, c);
			for (let keyFrame of field.t) {
				if (keyFrame.m === TimelineKeyFrameType.DISCRETE) {
					discretePositions[keyFrame.t] = true;
				}
			}
			for (let labelName in wholeTimelineData.l) {
				const label = wholeTimelineData.l[labelName];
				if (!c.hasOwnProperty(label.t)) { //time at this label is not calculated yet
					const prevKeyframe = MovieClip.__findPreviousKeyframe(field.t, label.t);
					fieldPlayer.val = prevKeyframe.v;
					fieldPlayer.speed = 0;
					fieldPlayer.goto(label.t, label.n[field.___fieldIndex]);
					calculateCacheSegmentForField(fieldPlayer, c);
				}
			}
			let filteredValues = c.filter(filterUndefined);

			c.min = Math.min.apply(null, filteredValues);
			c.max = Math.max.apply(null, filteredValues);
			Pool.dispose(fieldPlayer);
		}
		if (field.___cacheTimeline.hasOwnProperty(time)) {
			return field.___cacheTimeline[time];
		} else {
			let prevKeyframe = MovieClip.__findPreviousKeyframe(field.t, time);
			time = prevKeyframe.t;
			if (field.___cacheTimeline.hasOwnProperty(time)) {
				return field.___cacheTimeline[time];
			}
			return prevKeyframe.v as number;
		}
	}

	__initTimeline() {
		this._timelineData = {
			d: 0.85,
			p: 0.02,
			l: {},
			f: []
		};
	}

	__EDITOR_onCreate() {
		super.__EDITOR_onCreate();
		this.__initTimeline();
	}

	__getLabels():undefined | string[] {
		if (this.timeline) {
			return Object.keys(this.timeline.l).filter(l => !l.startsWith('__'));
		}
	}

	@editable({name: 'log labels', type: 'btn', onClick: LabelsLogger.toggle })
	@editable({ select: SELECT_LOG_LEVEL })
	__logLevel = 0;

	static __isPropertyDisabled(field: EditablePropertyDesc) { //prevent editing of properties animated inside prefab reference
		for (let o of game.editor.selection) {
			if (o.__nodeExtendData.isPrefabReference) {
				let timeline = getPrefabDefaults(o).timeline as TimelineSerializedData;
				if (timeline && timeline.f.find(f => f.n === field.name)) {
					return 'The property is disabled, because it is animated inside prefab.';
				}
			}
		}
	}
	/// #endif
}


let deserializeCache = new WeakMap();

/// #if EDITOR


const filterUndefined = (v: number) => {
	return v !== undefined;
};

const calculateCacheSegmentForField = (fieldPlayer: FieldPlayer, cacheArray: TimelineFrameValuesCache) => {
	fieldPlayer.__doNotCallActions = true;
	let time;
	let i = 0;
	let fields = fieldPlayer.timeline;
	let limit = fields[fields.length - 1].t;
	while (!cacheArray.hasOwnProperty(fieldPlayer.time)) {
		time = fieldPlayer.time;
		if (time > limit) {
			break;
		}
		fieldPlayer.update(true);
		cacheArray[time] = fieldPlayer.val;
		assert(i++ < 100000, 'Timeline values cache calculation looped and failed.');
	}
	fieldPlayer.__doNotCallActions = false;
};


(MovieClip.prototype.play as SelectableProperty).___EDITOR_isGoodForChooser = true;
(MovieClip.prototype.play as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(MovieClip.prototype.stop as SelectableProperty).___EDITOR_isGoodForChooser = true;
(MovieClip.prototype.stop as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(MovieClip.prototype.stop as SelectableProperty).___EDITOR_actionIcon = ACTION_ICON_STOP;
(MovieClip.prototype.playRecursive as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(MovieClip.prototype.playRecursive as SelectableProperty).___EDITOR_isGoodForChooser = true;
(MovieClip.prototype.stopRecursive as SelectableProperty).___EDITOR_isGoodForChooser = true;
(MovieClip.prototype.stopRecursive as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(MovieClip.prototype.gotoLabel as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(MovieClip.prototype.gotoLabel as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(MovieClip.prototype.gotoLabelIf as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(MovieClip.prototype.gotoLabelIf as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;
(MovieClip.prototype.gotoLabelIf as SelectableProperty).___EDITOR_callbackParameterChooserFunction = async(context: MovieClip) => {
	const label = await gotoLabelHelper(context);
	if (label && label.length) {
		const path = await DataPathEditor.choosePath(' gotoLabelIf condition');
		if (path) {
			label.push(path);
			const isInverted = await game.editor.ui.modal.showListChoose('Invert condition?', [
				{name: R.span({className: 'danger'}, 'invert'), pureName: 'invert', value: 1},
				{name: 'no invert', value: 0}
			]);
			if (isInverted?.value) {
				label.push('1');
			}
			return label;
		}
	}
};

let serializeCache = new WeakMap();

MovieClip.__EDITOR_icon = 'tree/movie';
decorateGotoLabelMethods(MovieClip);

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/movie-clip/field-player.ts">
/// #if EDITOR
import type FieldsTimelineView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-field';
import type TimelineKeyframeView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-keyframe-view';
/// #endif

import type TimelineLabelView from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-label-view';
import type TimelineLoopPoint from 'thing-editor/src/editor/ui/props-editor/props-editors/timeline/timeline-loop-point';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import game from 'thing-editor/src/engine/game.js';

import type MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';

interface TimelineKeyFrame {

	m: TimelineKeyFrameType;

	/** next keyframe */
	n: TimelineKeyFrame;

	/** target value */
	v: number | string | boolean;

	/** set speed */
	s?: number;

	/** time */
	t: number;

	/** time to jump (loop time) */
	j: number;

	/** random delay (max random value to decrease distance to next keyframe */
	r?: number;

	/** action (callback) */
	a?: string;

	/** power of gravity for BOUNCE keyframes */
	g?: number;

	/** bouncing power for BOUNCE keyframes */
	b?: number;

	/// #if EDITOR

	___view: TimelineKeyframeView | null;

	___react_id?: number;

	___keepLoopPoint?: boolean;

	___loopPointView?: TimelineLoopPoint;

	/// #endif
}

type Partial<T> = {
	[P in keyof T]?: T[P];
};

type TimelineSerializedKeyFrame = Partial<TimelineKeyFrame>;

type NumericArray = number[];
interface TimelineFrameValuesCache extends NumericArray {
	min: number;
	max: number;
}

interface TimelineFieldData {
	/** name of property to animate */
	n: string;

	t: TimelineKeyFrame[];

	/// #if EDITOR
	___timelineData: TimelineData;
	___fieldIndex: number;
	___cacheTimeline?: TimelineFrameValuesCache;
	___discretePositionsCache?: true[];
	___view?: FieldsTimelineView | null;
	/// #endif

}


interface TimelineSerializedFieldData {
	/** name of property to animate */
	n: string;

	t: TimelineSerializedKeyFrame[];
}


interface TimelineLabelData {

	/** labels time */
	t: number;

	/** next kayframe for each FiledPlayer */
	n: TimelineKeyFrame[];

	/// #if EDITOR
	___view?: TimelineLabelView | null;
	___name: string;
	___key?: number;
	/// #endif
}

type TimelineSerializedLabelsData = KeyedMap<number>;

interface TimelineSeriallizedData {
	/** labels */
	l: TimelineSerializedLabelsData;

	/** fileds animation */
	f: TimelineSerializedFieldData[];

	/** pow */
	p: number;

	/** damp */
	d: number;
}

interface TimelineData {

	/** labels */
	l: KeyedMap<TimelineLabelData>;

	/** pow */
	p: number;

	/** damp */
	d: number;

	f: TimelineFieldData[];
}


export default class FieldPlayer {

	target!: MovieClip;
	fieldName!: string;
	timeline!: TimelineKeyFrame[];
	pow = 0;
	damper = 0;
	time = 0;
	currentFrame!: TimelineKeyFrame;
	val: any;
	targetVal?: number;
	speed = 0;

	/// #if DEBUG

	__processedTime?: number = undefined;

	__lastFiredKeyframe?: TimelineKeyFrame;

	/** prevent call actions during timeline chart rendering */
	__doNotCallActions?: boolean;

	/// #endif

	init(target: MovieClip, data: TimelineFieldData, pow: number, damper: number) {

		this.target = target;
		this.fieldName = data.n;
		this.timeline = data.t;
		this.pow = pow;
		this.damper = damper;
		this.reset();
	}

	reset(
		/// #if EDITOR
		ignoreRandom = false
		/// #endif
	) {
		this.time = 0;
		/// #if DEBUG
		this.__processedTime = undefined;
		/// #endif
		this.currentFrame = this.timeline[0];
		if (this.currentFrame.hasOwnProperty('r')
			/// #if EDITOR
			&& !ignoreRandom
			/// #endif
		) {
			this.time -= (game.frameSeed ^ this.target._seed) % (this.currentFrame.r as number);
		}
		this.val = this.currentFrame.v;
		this.targetVal = this.val;
		this.speed = 0;

		/// #if EDITOR
		if (game.__EDITOR_mode && this.target.__previewFrame) {
			let kf = this.timeline.find((kf) => {
				return kf.t >= this.target.__previewFrame;
			}) || this.timeline[this.timeline.length - 1];
			if (kf) {
				(this.target as KeyedObject)[this.fieldName] = kf.v;
				return;
			}
		}
		/// #endif
		(this.target as KeyedObject)[this.fieldName] = this.val;
	}

	goto(time: number, nextKeyframe: TimelineKeyFrame) {
		this.time = time;
		this.currentFrame = nextKeyframe;
		if (nextKeyframe.m === TimelineKeyFrameType.LINEAR) {
			let dist = nextKeyframe.t - this.time;
			if (dist > 0) {
				this.speed = (nextKeyframe.v as number - this.val) / dist;
			} else {
				this.speed = 0;
			}
		} else if (nextKeyframe.m === TimelineKeyFrameType.DISCRETE) {
			this.speed = 0;
		}
	}

	update(
		/// #if EDITOR
		ignoreRandom = false
		/// #endif
	) {
		/// #if DEBUG
		this.__processedTime = this.time;
		/// #endif
		let currentFrame = this.currentFrame;
		if (this.time === currentFrame.t) {
			/// #if EDITOR
			this.__lastFiredKeyframe = currentFrame;
			/// #endif
			let action;
			if (currentFrame.hasOwnProperty('a')) {
				action = currentFrame.a;
			}

			if (currentFrame.m === TimelineKeyFrameType.LINEAR || currentFrame.m === TimelineKeyFrameType.DISCRETE) {
				this.val = currentFrame.v;
			}

			this.time = currentFrame.j;
			if (currentFrame.hasOwnProperty('r')
				/// #if EDITOR
				&& !ignoreRandom
				/// #endif
			) {
				this.time -= (game.frameSeed ^ this.target._seed) % (currentFrame.r as number);
			}

			if (currentFrame.m === TimelineKeyFrameType.SMOOTH) {
				this.speed += (currentFrame.v as number - this.val) * this.pow;
				this.val += this.speed;
				this.speed *= this.damper;
			}

			if (currentFrame.hasOwnProperty('s')) {
				this.speed = currentFrame.s as number;
			}

			this.currentFrame = currentFrame.n;
			currentFrame = currentFrame.n;
			if (currentFrame.m === TimelineKeyFrameType.LINEAR) {
				let dist = currentFrame.t - this.time;
				if (dist > 0) {
					this.speed = (currentFrame.v as number - this.val) / dist;
				} else {
					this.speed = 0;
				}
			}

			if (action) {
				/// #if EDITOR
				if (!this.__doNotCallActions) {
					if (this.target.__logLevel > 1) {
						game.editor.ui.status.warn('action call: ' + action + '; timeline time: ' + this.time + '; game time:' + game.time + '; id:' + this.target.___id, 30019, this.target, undefined, true, undefined, StatusClearingCondition.LAUNCH_GAME);
						if (this.target.__logLevel === 3) {
							/// break on callbacks
							console.log('callback: ' + action);
							debugger;
						}
					}
					/// #endif
					callByPath(action, this.target);
					/// #if EDITOR
				}
				/// #endif
			}
		} else {
			/// #if EDITOR
			this.__lastFiredKeyframe = undefined;
			/// #endif

			if (currentFrame.m === TimelineKeyFrameType.SMOOTH) {
				this.speed += (currentFrame.v as number - this.val) * this.pow;
				this.val += this.speed;
				this.speed *= this.damper;
			} else if (currentFrame.m === TimelineKeyFrameType.LINEAR) {
				this.val += this.speed;
			} else if (currentFrame.m === TimelineKeyFrameType.BOUNCE_BOTTOM) {
				this.speed += currentFrame.g as number;
				this.val += this.speed;
				if (this.val >= currentFrame.v) {
					this.val = currentFrame.v;
					this.speed *= currentFrame.b as number;
				}
			} else if (currentFrame.m === TimelineKeyFrameType.BOUNCE_TOP) {
				this.speed -= currentFrame.g as number;
				this.val += this.speed;
				if (this.val <= currentFrame.v) {
					this.val = currentFrame.v;
					this.speed *= currentFrame.b as number;
				}
			}
		}
		this.time++;
		(this.target as KeyedObject)[this.fieldName] = this.val;
	}
}

export { TimelineKeyFrameType };
export type {
	TimelineData,
	TimelineFieldData, TimelineFrameValuesCache, TimelineKeyFrame, TimelineLabelData, TimelineSeriallizedData as TimelineSerializedData, TimelineSerializedKeyFrame, TimelineSerializedLabelsData
};


const enum TimelineKeyFrameType {
	SMOOTH = 0,
	LINEAR = 1,
	DISCRETE = 2,
	BOUNCE_BOTTOM = 3,
	BOUNCE_TOP = 4,
}
</file>

<file path="src/engine/lib/assets/src/basic/multiline-text.c.ts">
import { Text } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import ___Guide from 'thing-editor/src/engine/lib/assets/src/___system/guide.c';

const CENTER = 'center';
const BOTTOM = 'bottom';

export default class MultilineText extends Text {

	@editable({ name: 'maxWidth', type: 'number', override: true, visible: (_o: MultilineText) => { return false; } })

	@editable({ afterEdited: afterMaxWidthEdit, min: 10, disabled: () => { return game.isPortrait; } })
	maxWidthLandscape = 400;
	@editable({ afterEdited: afterMaxWidthEdit, min: 10, disabled: () => { return !game.isPortrait; } })
	maxWidthPortrait = 400;

	static FORCE_WORDS_BREAK = false;

	_maxHeightLandscape = 0;
	_maxHeightPortrait = 0;

	@editable({ min: 0, disabled: () => { return game.isPortrait; }, afterEdited: afterMaxHeightEdit })
	get maxHeightLandscape() {
		return this._maxHeightLandscape;
	}

	set maxHeightLandscape(val) {
		this._maxHeightLandscape = val;
		if (!game.isPortrait && (val !== 0)) {
			this._applyMaxHeight();
		}
	}

	@editable({ min: 0, disabled: () => { return !game.isPortrait; }, afterEdited: afterMaxHeightEdit })
	get maxHeightPortrait() {
		return this._maxHeightPortrait;
	}

	set maxHeightPortrait(val) {
		this._maxHeightPortrait = val;
		if (game.isPortrait && (val !== 0)) {
			this._applyMaxHeight();
		}
	}

	@editable()
	get breakWords() {
		return this.style.breakWords;
	}

	set breakWords(val) {
		this.style.breakWords = val;
	}

	init() {
		super.init();
		this.applyWorldWrapping();
		if (MultilineText.FORCE_WORDS_BREAK) {
			this.breakWords = true;
		}
	}

	applyWorldWrapping() {
		if (this.style) {
			this.style.wordWrapWidth = (game.isPortrait ? this.maxWidthPortrait : this.maxWidthLandscape);
			this.style.wordWrap = true;
			this._applyMaxHeight();
		}
	}

	_onRenderResize() {
		this.applyWorldWrapping();
	}

	_onTextureUpdate() {
		super._onTextureUpdate();
		this._applyMaxHeight();
	}

	_applyMaxHeight() {
		if (this.style) {
			this.maxWidth = this.style.wordWrapWidth;
		}
		let h = game.isPortrait ? this._maxHeightPortrait : this._maxHeightLandscape;
		if ((h > 0) && (this._texture.height > h)) {
			let q = h / this._texture.height;
			if (this.scale.x !== q || this.scale.y !== q) {
				this.scale.x = q;
				this.scale.y = q;
			}
		}
	}

	/// #if EDITOR
	__beforeSerialization() {
		super.__beforeSerialization!();
		if ((game.isPortrait ? this._maxHeightPortrait : this._maxHeightLandscape) > 0) {
			this.scale.x = 1;
			this.scale.y = 1;
		}
	}

	__afterDeserialization() {
		this.applyWorldWrapping();
	}

	__afterSerialization(data: SerializedObject) {
		delete data.p.maxWidth;
		super.__afterSerialization!(data);
		this._applyMaxHeight();
	}
	/// #endif
}

/// #if EDITOR

MultilineText.__EDITOR_icon = 'tree/multiline-text';

function afterMaxHeightEdit() {
	let o = game.editor.selection[0] as MultilineText;
	let yBottom = game.isPortrait ? o._maxHeightPortrait : o._maxHeightLandscape;
	let yTop = 0;
	if (yBottom === 0) {
		for (let t of game.editor.selection) {
			t.scale.x = 1;
			t.scale.y = 1;
		}
		___Guide.hide('maxHeightBottom');
		___Guide.hide('maxHeightTop');
	} else {
		switch ((o as any).verticalAlign) {
		case CENTER:
			yBottom *= 0.5;
			yTop = -yBottom;
			break;
		case BOTTOM:
			yBottom *= -1;
			break;
		}
		let tmpScale = o.scale.x;
		o.scale.x = 1;
		o.scale.y = 1;
		___Guide.show(0, yBottom, 0, 'maxHeightBottom', o);
		___Guide.show(0, yTop, 0, 'maxHeightTop', o);
		o.scale.x = tmpScale;
		o.scale.y = tmpScale;
	}
}

function afterMaxWidthEdit() {
	for (let o of game.editor.selection as any as MultilineText[]) {
		o.applyWorldWrapping();
	}
	let o = game.editor.selection[0] as MultilineText;

	let props = (o.constructor as SourceMappedConstructor).__editableProps;
	for (let p of props) {
		if (p.name === 'maxWidth') {
			o.maxWidth = o.style.wordWrapWidth;
			p.afterEdited!(o.style.wordWrapWidth);
			o.maxWidth = 0;
			break;
		}
	}
}
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/nine-slice-plane.c.ts">
import { NineSlicePlane as PIXI_NineSlicePlane } from 'pixi.js';
import { _editableEmbed } from 'thing-editor/src/editor/props-editor/editable';
import Lib from 'thing-editor/src/engine/lib';

export default class NineSlicePlane extends PIXI_NineSlicePlane {
	constructor() {
		super(Lib.getTexture('WHITE'), 3, 3, 3, 3);
	}

	/// #if EDITOR
	__beforeDeserialization() {
		this.image = 'WHITE';
	}
	/// #endif
}

/// #if EDITOR

NineSlicePlane.__EDITOR_icon = 'tree/slice9';
_editableEmbed(NineSlicePlane, 'width', {
	noNullCheck: true,
	default: 200
});
_editableEmbed(NineSlicePlane, 'height', {
	noNullCheck: true,
	default: 200
});
_editableEmbed(NineSlicePlane, 'leftWidth', {
	noNullCheck: true,
	default: 5
});
_editableEmbed(NineSlicePlane, 'rightWidth', {
	noNullCheck: true,
	default: 5
});
_editableEmbed(NineSlicePlane, 'topHeight', {
	noNullCheck: true,
	default: 5
});
_editableEmbed(NineSlicePlane, 'bottomHeight', {
	noNullCheck: true,
	default: 5
});

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/particle-container.c.ts">
/// #if EDITOR
import game from 'thing-editor/src/engine/game';
/// #endif
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';

export default class ParticleContainer extends Container {

	constructor() {
		super();
		this.interactiveChildren = false;
		this.eventMode = 'none';
	}

	@editable({ name: 'interactive', visible: () => false, override: true })

	forAllChildren(callback: (o: Container) => void) {
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			super.forAllChildren(callback);
		}
		/// #endif
	}
}

/// #if EDITOR
ParticleContainer.__EDITOR_icon = 'tree/particle-container';
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/scene.c.ts">
import { Container } from 'pixi.js';
import type { FileDesc } from 'thing-editor/src/editor/fs';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import { ACCESS__ALL_ASSERTING_PROXY, addAllRefsValidator } from 'thing-editor/src/editor/utils/scene-all-validator';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';

/// #if EDITOR
let framesSkipAlerted = false;
/// #endif

export default class Scene extends Container {

	declare name: string;

	@editable({ type: 'color' })
	backgroundColor = 0;

	@editable()
	isStatic = false;

	@editable({ type: 'prefab', filterAssets: (f: FileDesc) => f.assetName.startsWith('fader/') })
	faderType: string | null = null;

	all!: ThingSceneAllMap;

	_onShowCalled = false;

	/// #if EDITOR
	@editable({min: 0, tip: 'Quickly scrolls the time to the defined frame at the scene beginning. Debug purposes only.'})
	__skipFrames = 0;
	___framesToSkip = 0;

	@editable({disabled: () => true})
	__sceneTime = 0;

	update(): void {
		this.__sceneTime++;
		super.update();
		while (this.___framesToSkip) {
			this.___framesToSkip--;
			if (!this.___framesToSkip && !framesSkipAlerted) {
				framesSkipAlerted = true;
				game.editor.ui.status.warn(this.__skipFrames + ' frames skipped. Set __skipFrames zero to avoid frames skipping.', 99999, this, '__skipFrames', undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
			}
			this.update();
		}
	}
	/// #endif

	onShow() {
		/* virtual */
	}

	onMouseDown(_mouse: typeof game.mouse, _ev: PointerEvent) {
		/* virtual */
	}

	onMouseUp(_mouse: typeof game.mouse, _ev: PointerEvent) {
		/* virtual */
	}

	onMouseMove(_mouse: typeof game.mouse, _ev: PointerEvent) {
		/* virtual */
	}

	onHide() {
		/* virtual */
	}

	init() {
		this._refreshAllObjectRefs();
		super.init();
		game._setCurrentScene(this);
	}

	_refreshAllObjectRefs() { //shortcut to access to scene's children by name without iterate through hierarchy

		this.all = {} as ThingSceneAllMap;

		/// #if EDITOR
		addAllRefsValidator(this);
		/// #endif

		allObjectToRefresh = this.all;

		this.forAllChildren(_refreshChildRef);
		if (game.currentScene === this) {
			game.all = this.all;
		}
	}
	/// #if EDITOR

	__afterDeserialization() {
		this.___framesToSkip = this.__skipFrames;
		this.__sceneTime = 0;
		this.all = ACCESS__ALL_ASSERTING_PROXY as ThingSceneAllMap;

		if (game.currentScene === this) {
			game.all = this.all;
		}
	}

	remove() { //allows editor to hide scene`s remove method and do not hide DisplayObject's remove method
		assert(false, 'Scenes remove() method should not be called. Use game.closeCurrentScene() method instead.', 10074);
	}

	static __canAcceptParent() {
		return false;
	}

	/// #endif
}

let allObjectToRefresh: KeyedMap<Container>;
const _refreshChildRef = (o: Container) => {
	if (o.name) {
		allObjectToRefresh[o.name] = o;
	}
};

/// #if EDITOR
Scene.__EDITOR_icon = 'tree/scene';
(Scene.prototype.remove as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Scene.prototype.onHide as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Scene.prototype.onMouseDown as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Scene.prototype.onMouseMove as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Scene.prototype.onMouseUp as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Scene.prototype.onShow as SelectableProperty).___EDITOR_isHiddenForChooser = true;

class __UnknownClassScene extends Scene {
	static __defaultValues = {};
}

__UnknownClassScene.__EDITOR_icon = 'tree/unknown-class';

export { __UnknownClassScene };
/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/spawner-ring.c.ts">
import { Container, Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';

const zeroPoint = new Point();

const PI2 = Math.PI * 2.0;

export default class SpawnerRing extends Container {

	@editable({ type: 'prefab', important: true })
	prefabToSpawn: string | null = null;

	@editable()
	speed = 10;

	@editable()
	speedRandom = 10;

	@editable()
	count = 10;

	@editable()
	countRandom = 10;

	@editable()
	radius = 10;


	@editable({ type: 'data-path', isValueValid: (o: any) => { return (o instanceof Container); } })
	container: string | null = null;

	@editable({ type: 'ref' })
	_container: Container | null = null;

	/// #if EDITOR
	___containerID = 0;
	/// #endif

	spawn() {
		/// #if EDITOR
		if (!this.prefabToSpawn) {
			game.editor.ui.status.error('Prefab to spawn is not selected.', 30015, this, 'prefabToSpawn');
			return;
		} else if (!Lib.hasPrefab(this.prefabToSpawn)) {
			game.editor.ui.status.error('Prefab with name "' + this.prefabToSpawn + '" is not exists.', 30016, this, 'prefabToSpawn');
			return;
		}
		/// #endif
		if (!this._container) {
			if (this.container) {
				this._container = getValueByPath(this.container, this);
				/// #if EDITOR
				if (!this._container) {
					game.editor.ui.status.error('Spawner targeted to not existing container: ' + this.container, 30017, this, 'container');
					this._container = game.currentContainer;
				}
				/// #endif
			} else {
				this._container = game.currentContainer;
			}
			/// #if EDITOR
			this.___containerID = this._container.___id;
			/// #endif
		}

		/// #if EDITOR
		if (this.___containerID !== this._container.___id) {
			game.editor.ui.status.error('SpawnerRing\'s target container has been removed. Please disable spawner before removing target container or use not removable target container.', 32055, this, 'container');
			return;
		}
		if (this._container?.worldTransform.a === 0 || this._container?.worldTransform.d === 0) {
			game.editor.ui.status.error('SpawnerRing\'s target container has zero scale. Impossible to calculate target point.', 99999, this, 'container');
			return;
		}
		/// #endif

		this._container.toLocal(zeroPoint, this, spawnPoint);
		let step = PI2 / (this.count + (this.countRandom * Math.random()));
		for (let i = 0; i < PI2; i += step) {
			let sin = Math.sin(i);
			let cos = Math.cos(i);

			let o = Lib.loadPrefab(this.prefabToSpawn);
			this._container.addChild(o);
			o.x = spawnPoint.x + this.radius * cos;
			o.y = spawnPoint.y + this.radius * sin;
			let sp = this.speed + Math.random() * this.speedRandom;
			(o as DSprite).xSpeed = sp * cos;
			(o as DSprite).ySpeed = sp * sin;
		}
	}

	onRemove(): void {
		this._container = null;
		super.onRemove();
	}
}

const spawnPoint = new Point();

/// #if EDITOR

(SpawnerRing.prototype.spawn as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

SpawnerRing.__EDITOR_icon = 'tree/spawner-ring';

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/spawner.c.ts">
import { Container, Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import type DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';

const zeroPoint = new Point();

export default class Spawner extends Container {

	@editable({ type: 'prefab', important: true })
	prefabToSpawn: string | null = null;

	@editable()
	enabled = true;

	@editable({ min: 0 })
	interval = 0;

	@editable({ min: 0 })
	intervalRandom = 0;

	@editable()
	speed = 10;

	@editable()
	speedRandom = 10;

	@editable()
	applyRotation = false;

	@editable({ type: 'data-path', isValueValid: (o: any) => { return (o instanceof Container); } })
	container: string | null = null;

	@editable({ type: 'ref' })
	_container: Container | null = null;

	curInterval = 0;

	init() {
		super.init();
		this.curInterval = Math.round(Math.random() * this.intervalRandom);
	}

	enable() {
		this.enabled = true;
	}

	disable() {
		this.enabled = false;
	}

	setSpeed(speed: number) {
		this.speed = speed;
	}

	update() {
		if (this.enabled && this.worldVisible) {
			if (this.curInterval > 0) {
				this.curInterval--;
			} else {
				this.spawn();
				this.curInterval = this.getNextInterval();
			}
		}
		super.update();
	}

	getNextInterval() {
		if (this.intervalRandom > 0) {
			return this.interval + Math.round(Math.random() * this.intervalRandom);
		}
		return this.interval;
	}

	/// #if EDITOR
	___containerID = 0;
	/// #endif

	setTargetContainer(targetContainer: Container | string) {
		if (targetContainer) {
			this._container = (targetContainer instanceof Container) ? targetContainer : getValueByPath(targetContainer, this);
			/// #if EDITOR
			if (!this._container) {
				game.editor.ui.status.error('Spawner targeted to not existing container: ' + this.container, 32007, this, 'container');
				this._container = game.currentContainer;
			}
			/// #endif
		} else {
			this._container = game.currentContainer;
		}
		/// #if EDITOR
		this.___containerID = this._container.___id;
		/// #endif
	}

	spawn() {
		/// #if EDITOR
		if (!this.prefabToSpawn) {
			game.editor.ui.status.error('Prefab to spawn is not selected.', 32005, this, 'prefabToSpawn');
			return;
		} else if (!Lib.hasPrefab(this.prefabToSpawn)) {
			game.editor.ui.status.error('Prefab with name "' + this.prefabToSpawn + '" is not exists.', 32006, this, 'prefabToSpawn');
			return;
		}
		/// #endif
		if (!this._container) {
			this.setTargetContainer(this.container as string);
		}
		/// #if EDITOR
		if (this.___containerID !== this._container!.___id) {
			game.editor.ui.status.error('Spawner\'s target container has been removed. Please disable spawner before removing target container or use not removable target container.', 32056, this, 'container');
			this.disable();
			return;
		}
		if (this._container?.worldTransform.a === 0 || this._container?.worldTransform.d === 0) {
			game.editor.ui.status.error('Spawner\'s target container has zero scale. Impossible to calculate target point.', 99999, this, 'container');
			this.disable();
			return;
		}
		/// #endif

		let o = Lib.loadPrefab(this.prefabToSpawn);
		if (this.applyRotation) {
			o.rotation = this.getGlobalRotation();
		}


		this._container!.addChild(o);
		o.parent.toLocal(zeroPoint, this, o);

		if (this.speed !== 0 || this.speedRandom !== 0) {
			let sp = this.speed + Math.random() * this.speedRandom;
			spawnPoint.x = sp;
			o.parent.toLocal(spawnPoint, this, spawnPointRet, true);
			(o as DSprite).xSpeed = spawnPointRet.x - o.x;
			(o as DSprite).ySpeed = spawnPointRet.y - o.y;
		}
	}

	onRemove(): void {
		this._container = null;
		super.onRemove();
	}
}

const spawnPoint = new Point();
const spawnPointRet = new Point();

/// #if EDITOR

(Spawner.prototype.enable as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spawner.prototype.disable as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spawner.prototype.spawn as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spawner.prototype.setSpeed as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

Spawner.__EDITOR_icon = 'tree/spawner';

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/sprite.c.ts">
import { BLEND_MODES, Container, Mesh, Sprite } from 'pixi.js';
import fs, { AssetType } from 'thing-editor/src/editor/fs';
import { _editableEmbed } from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

export default Sprite;

const imageJSPropertyDescriptor = {
	get: function (this: Sprite) {
		return this._imageID;
	},
	set: function (this: Sprite, v: string) {
		assert(typeof v === 'string', 'texture\'s name expected.', 10022);
		if (this._imageID !== v) {
			this._imageID = v;
			this.texture = Lib.getTexture(v);
			assert(this.texture && this.texture.baseTexture, 'baseTexture is empty.');
			/// #if EDITOR
			if (this.texture.valid && (Lib.hasTexture(this._imageID))) {
				if (this.anchor && ((((this.texture.height & 1) !== 0) && this.anchor.x === 0.5) || (((this.texture.width & 1) !== 0) && this.anchor.y === 0.5))) {
					game.editor.ui.status.warn('Texture "' + v + '" has non even sized bounds ('
						+ this.texture.width + 'x' + this.texture.height + '). It is can cause unwanted blurring for objects with centralized pivot point.', 32028,
					() => {
						fs.showFile(fs.getFileByAssetName(v, AssetType.IMAGE).fileName);
					}, undefined, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
				}
			}
			/// #endif
		}
	}
};

Object.defineProperty(Sprite.prototype, 'image', imageJSPropertyDescriptor);
Object.defineProperty(Mesh.prototype, 'image', imageJSPropertyDescriptor);

export { imageJSPropertyDescriptor as imagePropertyDescriptor };

const tintRDesc = {
	get: function (this: Sprite) {
		return this.tint as number >> 16;
	},
	set: function (this: Sprite, v: number) {
		assert(!isNaN(v), 'invalid value for \'tintR\'. Valid number value expected.', 10001);
		this.tint = ((this.tint as number) & 0xFFFF) | (v << 16);
	}, configurable: true
};

Object.defineProperty(Sprite.prototype, 'tintR', tintRDesc);
Object.defineProperty(Mesh.prototype, 'tintR', tintRDesc);

const tintPickerDesc = {
	get: function (this: Sprite) {
		return this.tint;
	},
	set: function (this: Sprite, v: number) {
		this.tint = v;
	}, configurable: true
};

Object.defineProperty(Sprite.prototype, 'tintPicker', tintPickerDesc);
Object.defineProperty(Mesh.prototype, 'tintPicker', tintPickerDesc);

const tintGDesc = {
	get: function (this: Sprite) {
		return ((this.tint as number) & 0xFF00) >> 8;
	},
	set: function (this: Sprite, v: number) {
		assert(!isNaN(v), 'invalid value for \'tintG\'. Valid number value expected.', 10001);
		this.tint = ((this.tint as number) & 0xFF00FF) | (v << 8);
	}, configurable: true
};

Object.defineProperty(Sprite.prototype, 'tintG', tintGDesc);
Object.defineProperty(Mesh.prototype, 'tintG', tintGDesc);

const tintBDesc = {
	get: function (this: Sprite) {
		return (this.tint as number) & 0xFF;
	},
	set: function (this: Sprite, v: number) {
		assert(!isNaN(v), 'invalid value for \'tintB\'. Valid number value expected.', 10001);
		this.tint = ((this.tint as number) & 0xFFFF00) | v;
	}, configurable: true
};

Object.defineProperty(Sprite.prototype, 'tintB', tintBDesc);
Object.defineProperty(Mesh.prototype, 'tintB', tintBDesc);


/// #if EDITOR

Sprite.prototype.update = function update() {
	Container.prototype.update.call(this);
	if (this.texture?.baseTexture) {
		this.texture.baseTexture.touched = EDITOR_FLAGS.__touchTime;
	}
};

Sprite.prototype.__beforeDestroy = function () {
	assert(this._width === 0, 'width property was assigned but not cleared to zero on object disposing.', 10065);
	assert(this._height === 0, 'height property was assigned but not cleared to zero on object disposing.', 10066);
};

(Sprite.prototype.destroy as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Mesh.prototype.destroy as SelectableProperty).___EDITOR_isHiddenForChooser = true;

Sprite.prototype.__EDITOR_onCreate = function (isWrapping) {
	if (!isWrapping && game.editor.projectDesc.icon.startsWith('assets/')) {
		this.image = game.editor.projectDesc.icon.replace('assets/', '');
	}
};
Mesh.prototype.__EDITOR_onCreate = Sprite.prototype.__EDITOR_onCreate;

const blendModesSelect = Object.keys(BLEND_MODES).filter((k) => {
	return isNaN(parseInt(k));
}).map((k) => {
	return { name: k, value: (BLEND_MODES as KeyedObject)[k] };
}).sort((a, b) => {
	return a.value - b.value;
});

Sprite.__EDITOR_icon = 'tree/sprite';

_editableEmbed(Mesh as any, 'Sprite', { type: 'splitter', title: 'Sprite' });

_editableEmbed([Sprite, Mesh as any], 'image', { type: 'image', default: 'EMPTY', canBeEmpty: false, animate: true });
_editableEmbed([Sprite, Mesh as any], 'tint', {
	basis: 16,
	default: 0xFFFFFF,
	max: 0xFFFFFF,
	min: 0
});
_editableEmbed([Sprite, Mesh as any], 'tintPicker', {
	default: 0xffffff,
	notSerializable: true,
	type: 'color',
	afterEdited: () => {
		game.editor.editProperty('tintR', (game.editor.selection[0] as Sprite).tintR);
		game.editor.editProperty('tintG', (game.editor.selection[0] as Sprite).tintG);
		game.editor.editProperty('tintB', (game.editor.selection[0] as Sprite).tintB);
	}
});
_editableEmbed([Sprite, Mesh as any], 'tintR', {
	default: 255,
	max: 255,
	min: 0,
	notSerializable: true,
	animate: true
});
_editableEmbed([Sprite, Mesh as any], 'tintG', {
	default: 255,
	max: 255,
	min: 0,
	notSerializable: true,
	animate: true
});
_editableEmbed([Sprite, Mesh as any], 'tintB', {
	default: 255,
	max: 255,
	min: 0,
	notSerializable: true,
	animate: true
});
_editableEmbed([Sprite, Mesh as any], 'blendMode', {
	select: blendModesSelect
});

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/static-trigger.c.ts">
/// #if EDITOR
import editable from 'thing-editor/src/editor/props-editor/editable';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import game from 'thing-editor/src/engine/game';
/// #endif

import Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';

export default class StaticTrigger extends Container {

	@editable({ type: 'data-path', important: true })
	dataPath = 'isMobile.any';

	@editable()
	invert = false;

	/// #if EDITOR

	__EDITOR_onCreate() {
		window.setTimeout(() => {
			editorUtils.centralizeObjectToContent(this);
		}, 0);
	}

	__afterDeserialization() {
		this.__validateStaticTrigger();
	}
	__beforeSerialization() {
		this.__validateStaticTrigger();
	}

	__validateStaticTrigger() {
		if (this.parent && (this.parent === game.stage || this.parent.parent === game.stage)) {
			game.editor.ui.status.error('StaticTrigger can not be root element or child of root element, because it does remove parent.', 32049, this);
		}
		if (this.dataPath && (this.dataPath.startsWith('this.') || this.dataPath.startsWith('all.'))) {
			game.editor.ui.status.error('StaticTrigger`s dataPath can refer to global variables only. Like isMobile.any', 32050, this, 'dataPath');
		}
	}

	static __canAcceptParent(o: Container) {
		if (o.parent === game.stage) {
			return false;
		}
		return true;
	}

	static __canAcceptChild(_Class: SourceMappedConstructor) {
		return false;
	}
	/// #endif
}
/// #if EDITOR

StaticTrigger.__EDITOR_icon = 'tree/static-trigger';
StaticTrigger.__EDITOR_tip = '<b>StaticTrigger</b> - is component which permanently removes parent if condition pointed in <b>dataPath</b> is not <b>true</b>.';

/// #endif
</file>

<file path="src/engine/lib/assets/src/basic/text.c.ts">
import type { TextStyleAlign, TextStyleFontWeight } from 'pixi.js';
import { Text } from 'pixi.js';

import { _editableEmbed } from 'thing-editor/src/editor/props-editor/editable';
import LanguageView from 'thing-editor/src/editor/ui/language-view';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import ___Guide from 'thing-editor/src/engine/lib/assets/src/___system/guide.c';

import L from 'thing-editor/src/engine/utils/l';

export default Text;

const CENTER = 'center';
const LEFT = 'left';
const RIGHT = 'right';
const TOP = 'top';
const BOTTOM = 'bottom';
const JUSTIFY = 'justify';

const isLetterSpacingUnsupported = !('letterSpacing' in CanvasRenderingContext2D.prototype
	|| 'textLetterSpacing' in CanvasRenderingContext2D.prototype);

const alignValues = {
	'center': 0.5,
	'left': 0.0,
	'right': 1.0,
	'top': 0.0,
	'bottom': 1.0,
	'justify': 1.0
};

type TextTransform = number;

const TEXT_TRANSFORM: KeyedMap<TextTransform> = {
	'none': 0,
	'uppercase': 1,
	'capitalize': 2,
	'lowercase': 3
};


const applyTextTransform = (value: string, textTransform: TextTransform) => {
	if (textTransform === TEXT_TRANSFORM.none) return value;
	if (textTransform === TEXT_TRANSFORM.uppercase) return value.toUpperCase();
	if (textTransform === TEXT_TRANSFORM.lowercase) return value.toLowerCase();
	if (textTransform === TEXT_TRANSFORM.capitalize) return value.replace(/(?:^|\s)\S/g, (char) => char.toUpperCase());
	assert(false, `Invalid "textTransform" value for text (${textTransform})`);
};

/// #if EDITOR
assert(!Text.__touchedFonts, 'refactoring is required');
Text.__touchedFonts = new Map();
/// #endif

Object.defineProperties(Text.prototype, {
	translatableText: {
		get: function (this: Text) {
			return (this as any)._translatableText;
		},
		set: function (this: Text, val: string) {
			if (val) {
				/// #if EDITOR
				if (!L.has(val)) {
					game.editor.ui.status.warn('translatableText refers to not existing key: "' + val + '"', 32032, this, 'translatableText');
				}
				/// #endif
				this.text = L(val);
			}
			(this as any)._translatableText = val;
		}
	},
	image: { //remove sprite texture property
		get: function (this: Text) {
			return undefined;
		},
		set: function (this: Text) { /* empty */ }
	},
	'style.align': {
		get: function (this: Text) {
			return this.style.align;
		},
		set: function (this: Text, val) {
			if (this.style.align != val) {
				this.style.align = val;
				_refreshAnchor(this);
				checkAlignBlur(this);
			}
		}, configurable: true
	},
	'verticalAlign': {
		get: function (this: Text) {
			return (this as any)._verticalAlign;
		},
		set: function (this: Text, val) {
			if ((this as any)._verticalAlign != val) {
				(this as any)._verticalAlign = val;
				_refreshAnchor(this);
				checkAlignBlur(this);
			}
		}, configurable: true
	},
	'style.fill': {
		get: function (this: Text) {
			return (this as any)._styleFill;
		},
		set: function (this: Text, val: string) {
			if (val && val.indexOf(',') >= 0) {
				this.style.fill = val.split(',');
			} else {
				this.style.fill = val;
			}
			(this as any)._styleFill = val;
		}, configurable: true
	},

	/// #if EDITOR
	'___fill': {
		get: function (this: Text) {
			return ((this as any)['style.fill'] as string).split(',').map(v => parseInt(v.replace('#', ''), 16));
		},
		set: function (this: Text, val: number[]) {
			if (Array.isArray(val)) {
				(this as any)['style.fill'] = val.map(v => '#' + v.toString(16).padStart(6, '0')).join(',');
			} else {
				(this as any)['style.fill'] = '#' + (val as number).toString(16).padStart(6, '0');
			}
		}, configurable: true
	},
	/// #endif
	'style.fillGradientStops': {
		get: function (this: Text) {
			return this.style.fillGradientStops || [];
		},
		set: function (this: Text, val) {
			/// #if EDITOR
			if (typeof val === 'string') {
				val = val.split(',').map((i: string) => i ? parseFloat(i) : 1);
			}
			let min = 0;
			val.forEach((v: number, i: number) => {
				if (v < min) {
					v = min;
					val[i] = min;
				}
				min = v;
			});
			/// #endif
			this.style.fillGradientStops = val;
		}, configurable: true
	},
	'style.fontFamily': {
		get: function (this: Text) {
			return (this as any)._fontFamily;
		},
		set: function (this: Text, val) {
			this.style.fontFamily = val || game.projectDesc.defaultFont;
			(this as any)._fontFamily = val;
		}, configurable: true
	},
	'style.fontWeight': {
		get: function (this: Text) {
			return this.style.fontWeight;
		},
		set: function (this: Text, val) {
			this.style.fontWeight = val;
		}, configurable: true
	},
	'style.fontSize': {
		get: function (this: Text) {
			return this.style.fontSize;
		},
		set: function (this: Text, val) {
			this.style.fontSize = val;
		}, configurable: true
	},
	'style.leading': {
		get: function (this: Text) {
			return this.style.leading;
		},
		set: function (this: Text, val) {
			this.style.leading = val;
		}, configurable: true
	},
	'style.padding': {
		get: function (this: Text) {
			return this.style.padding;
		},
		set: function (this: Text, val) {
			this.style.padding = val;
		}, configurable: true
	},
	'style.letterSpacing': {
		get: function (this: Text) {
			return this.style.letterSpacing;
		},
		set: function (this: Text, val) {
			/// #if EDITOR
			this.style.letterSpacing = val;
			return;
			/// #endif

			if (val === 0 && isLetterSpacingUnsupported) { /*eslint-disable-line no-unreachable */
				this.style.letterSpacing = 0.001;
			} else {
				this.style.letterSpacing = val;
			}
		}, configurable: true
	},
	'style.stroke': {
		get: function (this: Text) {
			return typeof this.style.stroke === 'string' ? parseInt((this.style.stroke as string).replace('#', ''), 16) : this.style.stroke;
		},
		set: function (this: Text, val) {
			this.style.stroke = val;
		}, configurable: true
	},
	'style.strokeThickness': {
		get: function (this: Text) {
			return this.style.strokeThickness;
		},
		set: function (this: Text, val) {
			this.style.strokeThickness = val;
			this.style.lineJoin = 'round';
		}, configurable: true
	},
	'style.dropShadow': {
		get: function (this: Text) {
			return this.style.dropShadow;
		},
		set: function (this: Text, val) {
			this.style.dropShadow = val;
		}, configurable: true
	},
	'style.drShColor': {
		get: function (this: Text) {
			return typeof this.style.dropShadowColor === 'string' ? parseInt((this.style.dropShadowColor as string).replace('#', ''), 16) : this.style.dropShadowColor;
		},
		set: function (this: Text, val) {
			this.style.dropShadowColor = val;
		}, configurable: true
	},
	'style.drShAlpha': {
		get: function (this: Text) {
			return this.style.dropShadowAlpha;
		},
		set: function (this: Text, val) {
			this.style.dropShadowAlpha = val;
		}, configurable: true
	},
	'style.drShAngle': {
		get: function (this: Text) {
			return this.style.dropShadowAngle;
		},
		set: function (this: Text, val) {
			this.style.dropShadowAngle = val;
		}, configurable: true
	},
	'style.drShBlur': {
		get: function (this: Text) {
			return this.style.dropShadowBlur;
		},
		set: function (this: Text, val) {
			this.style.dropShadowBlur = val;
		}, configurable: true
	},
	'style.drShDistance': {
		get: function (this: Text) {
			return this.style.dropShadowDistance;
		},
		set: function (this: Text, val) {
			this.style.dropShadowDistance = val;
		}, configurable: true
	},
	'textTransform': {
		get: function (this: Text) {
			return (this as any)._textTransform;
		},
		set: function (this: Text, v) {
			if (v !== (this as any)._textTransform) {
				(this as any)._textTransform = v;
				if (v && (this as any)._text) {
					(this as any)._text = applyTextTransform((this as any)._text, this.textTransform);
					this.dirty = true;
				}
			}
		},
		configurable: true
	},
	'maxWidth': {
		get: function (this: Text) {
			return (this as any)._maxWidth;
		},
		set: function (this: Text, val) {
			if ((this as any)._maxWidth !== val) {
				(this as any)._maxWidth = val;
				(this as any).recalculateTextSize();
			}
		}, configurable: true
	}
});

let d = Object.getOwnPropertyDescriptor(Text.prototype, 'text')!;
assert(d, 'Text component needs refactoring', 90001);
const originalTextSetter = d.set!;
d.set = function (this: Text, v) {
	if (this.textTransform && v) {
		/// #if EDITOR
		if (typeof v === 'number') {
			game.editor.ui.status.error('textTransform is set for label which shows numeric value. Please set it to "none" to avoid senseless processing.', 10075, this, 'textTransform');
			originalTextSetter.call(this, v);
			return;
		}
		/// #endif
		originalTextSetter.call(this, applyTextTransform(v, this.textTransform));
	} else {
		originalTextSetter.call(this, v);
	}
};
Object.defineProperty(Text.prototype, 'text', d);

let _original_onTextureUpdate = (Text.prototype as any)._onTextureUpdate;
(Text.prototype as any)._onTextureUpdate = function _onTextureUpdate() { // centred text with odd width is blurred bug fix
	checkAlignBlur(this);
	_original_onTextureUpdate.call(this);
	this.recalculateTextSize(); // recalculate max width

	/// #if EDITOR
	if (this.style?.fontFamily) {
		Text.__touchedFonts.set(this.style.fontFamily, EDITOR_FLAGS.__touchTime);
	}
	/// #endif

};

Text.prototype.init = function () {
	/// #if EDITOR
	EDITOR_FLAGS._root_initCalled.delete(this);
	/// #endif
	if (this.translatableText) {
		this.text = L(this.translatableText);
	}
	(this as any).recalculateTextSize();
};

/// #if EDITOR
Text.prototype.__beforeDestroy = function () {
	(this as any).textTransform = 0;
};
/// #endif

Text.prototype.onRemove = function () {
	/// #if EDITOR
	EDITOR_FLAGS._root_onRemovedCalled.delete(this);
	/// #endif
	(this as any)._maxWidth = 0;
	(this as any).textTransform = 0;
};

Text.prototype.setAlign = function (align: TextStyleAlign) {
	(this as any)['style.align'] = align;
};

function checkAlignBlur(text: Text) {
	let w = text.texture.width;
	if (w > 0) {
		if (text.style.align === CENTER) {
			text.anchor.x = Math.round(0.5 * w) / w;
		}
		let h = text.texture.height;
		if ((text.style as any)._verticalAlign === CENTER) {
			text.anchor.y = Math.round(0.5 * h) / h;
		}
	}
}

(Text.prototype as any).onLanguageChanged = function onLanguageChanged() {
	if ((this as any)._translatableText) {
		let t = (this as any)._translatableText;
		(this as any)._translatableText = null;
		this.translatableText = t;
	}
};

function _refreshAnchor(text: Text) {
	text.anchor.set(alignValues[text.style.align], alignValues[(text as any)._verticalAlign as 'top' | 'bottom' | 'center']);
}

(Text.prototype as any).recalculateTextSize = function recalculateTextSize() {
	if ((this as any)._maxWidth !== 0) {
		if (this._texture.width > (this as any)._maxWidth) {
			const q = (this as any)._maxWidth / this._texture.width;
			if (this.scale.x !== q || this.scale.y !== q) {
				this.scale.x = q;
				this.scale.y = q;
				if (this.parent) {
					this.updateTransform();
				}
			}
		} else {
			if (this.scale.x !== 1 || this.scale.y !== 1) {
				this.scale.x = 1;
				this.scale.y = 1;
				if (this.parent) {
					this.updateTransform();
				}
			}
		}
	}
};

/// #if EDITOR

Text.prototype.__EDITOR_onCreate = function __EDITOR_onCreate() {
	this.text = 'New Text 1';
};

Text.prototype.__beforeSerialization = function __beforeSerialization() {
	if ((this as any)._translatableText) {
		this.text = '';
	}
	if (this.maxWidth > 0) {
		this.scale.x = 1;
		this.scale.y = 1;
	}
};
Text.prototype.__afterSerialization = function __afterSerialization() {
	if ((this as any)._translatableText) {
		this.text = L((this as any)._translatableText);
	}
	if (this.maxWidth > 0) {
		let tmp = this.maxWidth;
		this.maxWidth = 0;
		this.maxWidth = tmp;
	}
};

Text.__EDITOR_icon = 'tree/text';

_editableEmbed(Text, 'image', {
	type: 'string',
	override: true,
	visible: () => {
		return false;
	}
});

_editableEmbed(Text, 'text-props-splitter', {
	type: 'splitter',
	title: 'Text:'
});

_editableEmbed(Text, 'text', {
	default: null,
	type: 'string',
	title: 'Text:',
	important: true,
	multiline: true,
	disabled: (node: Text) => {
		return node.translatableText && 'Disabled because \'translatableText\' property is set.';
	}
});

_editableEmbed(Text, 'translatableText', { type: 'l10n' });

_editableEmbed(Text, 'Edit text 🖉', {
	type: 'btn',
	helpUrl: 'components.Text#edit-text',
	title: 'Edit translatable text.',
	visible: (o:Text) => !!o.translatableText,
	onClick: (o: Text) => {
		LanguageView.editKey(o.translatableText);
	}
});
_editableEmbed(Text, 'Create translatable text...', {
	type: 'btn',
	helpUrl: 'components.Text#edit-text',
	title: 'Create new translatable key.',
	visible: (o:Text) => !o.translatableText,
	onClick: (o: Text) => {
		LanguageView.editKey(o.translatableText);
	}
});

_editableEmbed(Text, 'text-style', {
	type: 'splitter',
	title: 'Style:'
});

_editableEmbed(Text, 'Copy style', {
	type: 'btn',
	title: 'Copy text style.',
	onClick: (o: Text) => {
		const styleProperties = (o.constructor as SourceMappedConstructor).__editableProps
			.filter((property) => {
				return property.name.startsWith('style.');
			})
			.map((property) => ({ property: property.name, value: (o as KeyedObject)[property.name] }));
		game.editor.settings.setItem('__EDITOR-clipboard-data-text-style', styleProperties);
		game.editor.ui.modal.notify('Copied current text style');
	}
});

_editableEmbed(Text, 'Paste style', {
	type: 'btn',
	title: 'Paste text style.',
	onClick: (o: Text) => {
		game.editor.ui.modal.notify('Text style pasted');
		(game.editor.settings.getItem('__EDITOR-clipboard-data-text-style', []) as { property: string; value: any }[])
			.forEach(({ property, value }) => game.editor.onObjectsPropertyChanged(o, property, value, false));
	},
	visible: () => !!game.editor.settings.getItem('__EDITOR-clipboard-data-text-style', false),
});

_editableEmbed(Text, 'style.fontSize', {
	min: 1,
	max: 300,
	default: 24,
	important: true
});

_editableEmbed(Text, 'style.align', {
	select: [
		{ name: CENTER, value: CENTER },
		{ name: LEFT, value: LEFT },
		{ name: RIGHT, value: RIGHT },
		{ name: JUSTIFY, value: JUSTIFY }
	],
	default: CENTER
});

_editableEmbed(Text, 'verticalAlign', {
	select: [
		{ name: TOP, value: TOP },
		{ name: CENTER, value: CENTER },
		{ name: BOTTOM, value: BOTTOM }
	],
	type: 'string',
	default: CENTER
});

_editableEmbed(Text, 'style.fill', {
	type: 'string',
	disabled: () => 'Please use "___fill" color picker instead.',
	default: '#ffffff'
});

_editableEmbed(Text, '___fill', {
	type: 'color',
	arrayProperty: true,
	notSerializable: true,
	canBeEmpty: false,
	default: [0xffffff]
});

_editableEmbed(Text, 'style.fillGradientStops', {
	type: 'number',
	arrayProperty: true,
	min: 0,
	max: 1,
	step: 0.001,
	visible: (node: Text) => {
		return (node as any)._styleFill && (node as any)._styleFill.indexOf(',') >= 0;
	}
});

_editableEmbed(Text, 'style.strokeThickness', {
	type: 'number',
	min: 0
});

_editableEmbed(Text, 'style.stroke', {
	type: 'color',
	noNullCheck: true,
	default: 0,
	visible: (node: Text) => {
		return node.style?.strokeThickness > 0;
	}
});

_editableEmbed(Text, 'style.dropShadow', {
	type: 'boolean',
	default: false
});

_editableEmbed(Text, 'style.drShColor', {
	type: 'color',
	noNullCheck: true,
	default: 0,
	visible: (node: Text) => node.style?.dropShadow
});

_editableEmbed(Text, 'style.drShAlpha', {
	type: 'number',
	default: 1,
	step: 0.01,
	min: 0,
	visible: (node: Text) => node.style?.dropShadow
});

_editableEmbed(Text, 'style.drShAngle', {
	type: 'number',
	default: 0.524,
	step: 0.001,
	visible: (node: Text) => node.style?.dropShadow
});

_editableEmbed(Text, 'style.drShBlur', {
	type: 'number',
	default: 0,
	step: 0.01,
	min: 0,
	visible: (node: Text) => node.style?.dropShadow
});

_editableEmbed(Text, 'style.drShDistance', {
	type: 'number',
	default: 5,
	min: 0,
	visible: (node: Text) => node.style?.dropShadow
});

_editableEmbed(Text, 'style.fontFamily', {
	type: 'string',
	beforeEdited(val) {
		const text = game.editor.selection[0] as Text;
		const currentWeight = text.style.fontWeight;
		const weights = getFontWeights(val);
		if (!weights.find(w => w.name === currentWeight)) {
			text.style.fontWeight = weights[Math.floor(weights.length / 2)].value;
		}
	}
});

function getFontWeights(family: string) {
	let availableWeights: KeyedObject = {};
	for (let f of Array.from(document.fonts.values())) {
		if (f.family === family) {
			let w = parseInt(f.weight);
			if (w < 301) {
				availableWeights.lighter = true;
			} else if (w > 801) {
				availableWeights.bolder = true;
			} else if (w > 501) {
				availableWeights.bold = true;
			} else {
				availableWeights.normal = true;
			}
		}
	}
	let a = Object.keys(availableWeights);
	if (a.length > 0) {
		return a.map((k) => {
			return { name: k, value: k as TextStyleFontWeight };
		});
	}
	return [
		{ name: 'normal', value: 'normal' },
		{ name: 'bold', value: 'bold' },
		{ name: 'bolder', value: 'bolder' },
		{ name: 'lighter', value: 'lighter' }
	] as { name: string; value: TextStyleFontWeight }[];
}

_editableEmbed(Text, 'style.fontWeight', {
	type: 'string',
	select: () => {
		const family = ((game.editor.selection[0] as Text).style.fontFamily as string).split(',')[0].replace(/['"]/gm, '').trim();
		return getFontWeights(family);
	},
	default: 'normal'
});

_editableEmbed(Text, 'style.leading', {
	type: 'number'
});

_editableEmbed(Text, 'style.padding', {
	type: 'number'
});

_editableEmbed(Text, 'style.letterSpacing', {
	type: 'number'
});

_editableEmbed(Text, 'textTransform', {
	type: 'number',
	select: Object.entries(TEXT_TRANSFORM).map(([name, value]) => ({ name, value })),
	default: TEXT_TRANSFORM.none
});

_editableEmbed(Text, 'maxWidth', {
	type: 'number',
	min: 0,
	afterEdited: (_val: number, overrideO?: Text) => {

		let textObject = overrideO || game.editor.selection[0] as Text;
		let right = textObject.maxWidth;
		let y = 0;
		if (right === 0) {
			for (let t of game.editor.selection) {
				t.scale.x = 1;
				t.scale.y = 1;
			}
			___Guide.hide('maxWidthRight');
			___Guide.hide('maxWidthLeft');
		} else {
			switch (textObject.style.align) {
			case CENTER:
				right *= 0.5;
				y = -right;
				break;
			case RIGHT:
				right *= -1;
				break;
			}
			let tmpScale = textObject.scale.x;
			textObject.scale.x = 1;
			textObject.scale.y = 1;
			___Guide.show(right, 0, Math.PI / 2, 'maxWidthRight', textObject);
			___Guide.show(y, 0, Math.PI / 2, 'maxWidthLeft', textObject);
			textObject.scale.x = tmpScale;
			textObject.scale.y = tmpScale;
		}
	}
});
/// #endif
</file>

<file path="src/engine/lib/assets/src/common/ui/orientation-parent-resizer.c.ts">
import OrientationTrigger from 'thing-editor/src/engine/lib/assets/src/mobile/orientation-trigger.c';
import type Shape from '../../extended/shape.c';

export default class OrientationParentResizer extends OrientationTrigger {
	applyOrientation(): void {
		super.applyOrientation();
		if (this.parent) {
			if ((typeof (this.parent as any).W === 'number')) {
				(this.parent as any).W = this.x;
				(this.parent as any).H = this.y;
			} else {
				(this.parent as Shape).width = this.x;
				(this.parent as Shape).height = this.y;
			}
		}
	}
}

/// #if EDITOR
OrientationParentResizer.__EDITOR_tip = 'works as OrientationTrigger, but additionally pass it`s {x,y} to parent`s {width,height}.';

/// #endif
</file>

<file path="src/engine/lib/assets/src/common/ui/parent-resizer.c.ts">
import Resizer from 'thing-editor/src/engine/lib/assets/src/extended/resizer.c';
import type Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';

export default class ParentResizer extends Resizer {

	recalculateSize() {
		super.recalculateSize();
		if (this.parent) {
			(this.parent! as Shape).width = this.x;
			(this.parent as Shape).height = this.y;
		}
	}
}

/// #if EDITOR
ParentResizer.__EDITOR_tip = 'works as Resizer, but additionally pass it`s {x,y} to parent`s {width,height}.';

/// #endif
</file>

<file path="src/engine/lib/assets/src/custom/particle-short.c.ts">
import editable from 'thing-editor/src/editor/props-editor/editable';
import DSprite from 'thing-editor/src/engine/lib/assets/src/basic/d-sprite.c';
import { stepTo } from 'thing-editor/src/engine/utils/utils';

export default class ParticleShort extends DSprite {

	size = 1;

	@editable({ min: 3 })
	duration = 10;

	chanceToRemove = 0;

	@editable({ min: 0.01, max: 1 })
	xSpeedFactor = 0.93;

	@editable({ min: 0.01, max: 1 })
	ySpeedFactor = 0.93;

	alphaSpeed = 0;

	init() {
		super.init();
		this.size = this.scale.x * (Math.random() + 0.2);
		this.scale.y = this.scale.x = 0.1;
		this.alphaSpeed = 1 / this.duration;
		this.chanceToRemove = 1 - 1 / this.duration;
	}

	update() {
		this.scale.y = this.scale.x = stepTo(this.scale.x, this.size, 0.2);
		this.xSpeed += (Math.random() - 0.5);
		this.xSpeed *= this.xSpeedFactor;
		this.ySpeed += (Math.random() - 0.65);
		this.ySpeed *= this.ySpeedFactor;

		if (this.alpha < 1) {
			this.alpha -= this.alphaSpeed;
			if (this.alpha <= 0) {
				this.remove();
			}
		} else if (Math.random() > this.chanceToRemove) {
			this.alpha -= this.alphaSpeed;
		}
		super.update();
	}
}
</file>

<file path="src/engine/lib/assets/src/extended/html-overlay.c.ts">
import type { Renderer } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import ScrollLayer from 'thing-editor/src/engine/lib/assets/src/extended/scroll-layer.c';
import { stepTo } from 'thing-editor/src/engine/utils/utils';

let _canvasBoundsCache: DOMRect | null = null;
let canvasScale = 1;
function recalcCanvasBounds() {
	if (!_canvasBoundsCache) {
		_canvasBoundsCache = game.pixiApp.view.getBoundingClientRect!() as DOMRect;
		canvasScale = _canvasBoundsCache.width / game.W;
	}
}

export default class HTMLOverlay extends ScrollLayer {


	_htmlContent = '';
	_isHtmlContentInvalidated = false;
	_htmlDiv: null | HTMLDivElement = null;
	currentHtmlScale = 0;
	currentHtmlOpacity = 0;
	_scripts: HTMLScriptElement[] = [];
	_overlayInterval = 0;


	@editable({ multiline: true })
	get innerHTML() {
		return this._htmlContent;
	}

	set innerHTML(v) {
		if (this._htmlContent !== v) {
			this._isHtmlContentInvalidated = !!this._htmlDiv;
			this._htmlContent = v;
		}
	}

	@editable({ arrayProperty: true, type: 'string', multiline: true })
	jsScripts: string[] = [];

	@editable()
	handleScroll = true;

	@editable()
	zIndexHTML = 10000;

	@editable()
	className = '';

	@editable({ min: 0.0001, max: 1, step: 0.0001 })
	fadeSpeed = 0.2;

	@editable({ name: 'bouncingBounds', override: true, type: 'boolean', default: false, visible: () => false })

	latestTime = 0;

	constructor() {
		super();
		this._overlayIntervalUpdate = this._overlayIntervalUpdate.bind(this);
	}

	init() {
		this.bouncingBounds = false;
		super.init();
		this.currentHtmlScale = 0;
		this.currentHtmlOpacity = 0;
		this.latestTime = 0;
		this.interactive = true;
		assert(!this._htmlDiv, 'previous this._htmlDiv instance was not removed properly');
		this._scripts = [];
	}

	onRemove() {
		super.onRemove();
		this._releaseHtmlDiv();
	}

	update() {
		_canvasBoundsCache = null;
		recalcCanvasBounds();
		if (this.handleScroll && this._htmlDiv) {
			if (this._htmlDiv.scrollHeight > this._htmlDiv.clientHeight) {
				this.fullArea.h = Math.max(this.visibleArea.h, Math.floor(this._htmlDiv.scrollHeight / canvasScale - 1));
			} else {
				this.fullArea.h = this.visibleArea.h;
			}
		}

		super.update();
		this.latestTime = game.time;

		if (this.handleScroll && this._htmlDiv) {
			this._htmlDiv.scrollTop = -this.y * canvasScale;
		}
		this._updateHtmlOpacity();
	}

	_updateHtmlOpacity() {
		let isVisible = this.worldVisible && this._htmlContent && this.getRootContainer().parent && this.isCanBePressed && Math.abs(this.worldTransform.a) > 0.1 && !this._isHtmlContentInvalidated;
		let htmlTargetOpacity = isVisible ? this.worldAlpha : 0;
		this.currentHtmlOpacity = stepTo(this.currentHtmlOpacity, htmlTargetOpacity, this.fadeSpeed);
	}

	_overlayIntervalUpdate() {
		if ((game.time - this.latestTime) > 1) {
			this._updateHtmlOpacity();
		}
		if (!this.worldVisible || !this.getRootContainer().parent) {
			this._releaseHtmlDiv();
		}
	}

	_releaseHtmlDiv() {
		if (this._htmlDiv) {
			this.emit('html-will-remove'); /// 99999
			this._htmlDiv.remove();
			this._htmlDiv = null;
			if (this._overlayInterval) {
				clearInterval(this._overlayInterval);
				this._overlayInterval = 0;
			}
			this._isHtmlContentInvalidated = false;
			this.currentHtmlScale = 0;
			this.currentHtmlOpacity = 0;
		}

		for (let i = 0; i < this._scripts?.length; i++) {
			this._scripts[i].remove();
		}

		this._scripts = [];
	}

	render(renderer: Renderer) {
		this._renderHtmlContainer();
		super.render(renderer);
	}

	_renderHtmlContainer() {

		/// #if EDITOR
		if (game.__EDITOR_mode) {
			this.currentHtmlOpacity = this.worldVisible ? this.alpha : 0;
		}
		/// #endif

		if (this.currentHtmlOpacity > 0.001) {
			if (!this._htmlDiv) {
				this._htmlDiv = document.createElement('div');
				this._htmlDiv.style.position =
				/// #if EDITOR
				(game.__EDITOR_mode) ? 'absolute' :
				/// #endif
					'fixed';
				this._htmlDiv.innerHTML = this._htmlContent;
				this._htmlDiv.style.overflowY = 'hidden';
				this._htmlDiv.style.overflowX = 'visible';
				this._htmlDiv.style.zIndex = this.zIndexHTML.toString();
				this._htmlDiv.style.transformOrigin = '0 0';
				this._applyClassName();
				if (this.handleScroll) {
					this._htmlDiv.style.pointerEvents = 'none';
				}

				if (this.jsScripts) {
					for (let i = 0; i < this.jsScripts.length; i++) {
						let script = this.jsScripts[i];
						let scriptElement = document.createElement('script');
						scriptElement.textContent = script;

						this._scripts.push(scriptElement);
					}
				}

				game.pixiApp.view.parentNode!.appendChild(this._htmlDiv);

				for (let i = 0; i < this._scripts.length; i++) {
					document.body.appendChild(this._scripts[i]);
				}
				this._isHtmlContentInvalidated = false;
				this._overlayInterval = window.setInterval(this._overlayIntervalUpdate, 1000 / 60);
				this.emit('html-attached'); /// 99999
			}
			this._htmlDiv.style.opacity = this.currentHtmlOpacity.toString();
			_canvasBoundsCache = null;

			recalcCanvasBounds();

			if (Math.abs(this.currentHtmlScale - this.worldTransform.a) > 0.001) {
				this.currentHtmlScale = this.worldTransform.a;
				this._htmlDiv.style.transform = 'scale(' + (this.currentHtmlScale).toFixed(3) + ')';
			}

			this._htmlDiv.style.left = (
				/// #if EDITOR
				(!game.__EDITOR_mode) ? _canvasBoundsCache!.left :
				/// #endif
					(game.pixiApp.view as HTMLCanvasElement).offsetLeft)

			+ (Math.round(this.parent.worldTransform.tx) * canvasScale) + 'px';


			this._htmlDiv.style.top = (
			/// #if EDITOR
				(!game.__EDITOR_mode) ? _canvasBoundsCache!.top :
				/// #endif
					(game.pixiApp.view as HTMLCanvasElement).offsetTop)

			+ (Math.round(this.parent.worldTransform.ty) * canvasScale) + 'px';


			this._htmlDiv.style.width = (this.visibleArea.w * canvasScale) + 'px';

			this._htmlDiv.style.height = (this.visibleArea.h * canvasScale) + 'px';


		} else {
			this._releaseHtmlDiv();
		}
	}

	_onRenderResize() {
		this._applyClassName();
	}

	_applyClassName() {
		if (this._htmlDiv) {
			this._htmlDiv.className = this.className ? (
				this.className +
				(game.isPortrait ? ' portrait-' : ' landscape-') + this.className +
				(game.isMobile.any ? ' mobile-' : ' desktop-') + this.className
			) : '';
		}
	}

	set width(val:number) { // ParentResizer helpers
		this.visibleArea.w = val;
		this.fullArea.w = val;
	}

	set height(val:number) {
		this.visibleArea.h = val;
	}
}
</file>

<file path="src/engine/lib/assets/src/extended/is-mobile-trigger.c.ts">
import game from 'thing-editor/src/engine/game';
import OrientationTrigger from 'thing-editor/src/engine/lib/assets/src/mobile/orientation-trigger.c';

export default class IsMobileTrigger extends OrientationTrigger {

	_onRenderResize(): void {
		// disable
	}

	getTriggerConditionState() {
		return game.isMobile.any;
	}

	/// #if EDITOR

	__checkWarnings() {
		// disable
	}

	__onIsMobileChange() {
		this.applyOrientation();
	}

	/// #endif
}

/// #if EDITOR
IsMobileTrigger.__EDITOR_icon = 'tree/is-mobile';

/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/label.c.ts">
import { Text } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import game from 'thing-editor/src/engine/game';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import L from 'thing-editor/src/engine/utils/l';
import { stepTo } from 'thing-editor/src/engine/utils/utils';
import formatMoney from '../utils/format-money';

export default class Label extends Text {

	@editable({ type: 'data-path', important: true })
	dataPath = null as string | null;

	@editable({ min: 0 })
	refreshInterval = 10;

	@editable({ type: 'string', multiline: true, tip: 'template example: <b>Your have %d coins</b>', disabled: (node: Label) => { return node.translatableText; } })
	template: string | null = null;

	/** replace pattern for translatableText */
	@editable({ disabled: o => !o.translatableText })
	paramName = '%d';

	@editable()
	isNumeric = false;

	@editable({ disabled: (node: Label) => { return !node.isNumeric; } })
	plusMinus = false;

	@editable({ min: 0.001, max: 1, step: 0.001, visible: (node: Label) => { return node.isNumeric; }, tip: '1 - shows value immediately. less that 1 - shows with counting.' })
	counterSpeed = 1;

	@editable({ min: 0, max: 20, visible: (node: Label) => { return node.isNumeric; } })
	decimalsCount = 0;

	@editable({ type: 'callback' })
	onChanged: string | null = null;

	@editable({ type: 'callback' })
	onCounter: string | null = null;

	@editable({ type: 'callback' })
	onCounterFinish: string | null = null;

	currentInterval = 0;
	showedVal: any;
	processedVal: any;
	lastUpdateTime = 0;

	localizationParams = {} as KeyedObject;

	init() {
		super.init();
		this.currentInterval = 0;
		this.text = '';
		this.showedVal = undefined;
		this.processedVal = undefined;
		this.lastUpdateTime = game.time;
		this.localizationParams = {};

		/// #if EDITOR
		if (this.translatableText) {
			if (this.paramName && (L(this.translatableText).indexOf(this.paramName) < 0)) {
				game.editor.ui.status.warn('Localized text contain no parameter ' + this.paramName, 99999, this, 'paramName', undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
			}
		}
		/// #endif
	}

	onLanguageChanged() {
		if ((this as any)._translatableText) {
			this.showedVal = undefined;
			this.refreshNow();

			if (
				/// #if EDITOR
				game.__EDITOR_mode ||
				/// #endif

				//@ts-ignore
				game.__paused) super.onLanguageChanged();

		}
	}

	customizeVal(val: any) {
		return val;
	}

	updateValue() {
		if ((game.time - this.lastUpdateTime) > 1) {
			this.refreshNow();
		}
		this.lastUpdateTime = game.time;

		if (this.currentInterval <= 0 && this.dataPath) {

			let val = getValueByPath(this.dataPath, this);
			val = this.customizeVal(val);
			if (val || val === 0) {
				if (val !== this.processedVal) {
					if (this.onChanged) {
						callByPath(this.onChanged, this);
					}
					this.processedVal = val;
				}

				if (val !== this.showedVal) {
					this.visible = true;
					this.applyValue(val);
				}
			} else {
				this.processedVal = undefined;
				this.showedVal = undefined;
				this.visible = false;
			}

			this.currentInterval = this.refreshInterval;
		} else {
			this.currentInterval--;
		}
	}

	update() {
		this.updateValue();
		super.update();
	}

	applyValue(val: any) {
		if (this.isNumeric) {
			if ((this.counterSpeed < 1) && (this.showedVal !== undefined)) {
				let step = Math.max(1 / Math.pow(10, this.decimalsCount), Math.abs((val - (this.showedVal || 0)) * this.counterSpeed));
				this.showedVal = stepTo(this.showedVal || 0, val, step);
				if (this.showedVal === val) {
					if (this.onCounterFinish) {
						callByPath(this.onCounterFinish, this);
					}
				} else {
					if (this.onCounter) {
						callByPath(this.onCounter, this);
					}
				}
			} else {
				this.showedVal = val;
			}
			if (this.plusMinus && val > 0) {
				val = '+' + Label.formatMoney(this.showedVal, this.decimalsCount);
			} else {
				val = Label.formatMoney(this.showedVal, this.decimalsCount);
			}

		} else {
			this.showedVal = val;
		}

		if (this.template) {
			this.text = this.template.replace(this.paramName, val);
		} else if ((this as any)._translatableText) {
			if (this.paramName) {
				this.localizationParams[this.paramName] = val;
				this.text = L((this as any)._translatableText, this.localizationParams);
			} else {
				this.text = L((this as any)._translatableText, val);
			}
		} else {
			this.text = val;
		}
	}

	isEqual(value:any) {
		return value == this.processedVal;
	}

	isBigger(value:number) {
		return value < (this.processedVal as number);
	}

	freezeCounter() {
		this.currentInterval = Number.MAX_SAFE_INTEGER;
	}

	unfreezeCounter() {
		this.currentInterval = 0;
	}

	refreshNow() {
		this.currentInterval = 0;
		this.lastUpdateTime = game.time;
		this.updateValue();
	}

	/// #if EDITOR
	__beforeSerialization() {
		super.__beforeSerialization!();
		if ((this as any)._translatableText) {
			this.template = null;
		}
	}

	/// #endif
	static formatMoney = formatMoney;

	/// #if EDITOR
	static __EDITOR_icon = 'tree/label';
	static __EDITOR_tip = '<b>Label</b> - is component which represent value of specified javaScript variable on screen. Useful for in-game counters.';
	/// #endif
}
</file>

<file path="src/engine/lib/assets/src/extended/layered-container.c.ts">
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import LayeredContainerPortal from 'thing-editor/src/engine/lib/assets/src/extended/layered-contaiter-portal.c';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';

export default class LayeredContainer extends Container {

	@editable({ type: 'data-path' })
	set targetContainer(v: string) {
		this._targetContainer = v;
		this._updateTargetContainer();
	}

	get targetContainer() {
		return this._targetContainer;
	}

	_targetContainer: string = null!;

	@editable()
	enabled = true;

	@editable({ type: 'ref' })
	rendererPortalContainer!: LayeredContainerPortal;

	needInit = true;

	init() {
		super.init();
		this.rendererPortalContainer = Lib._loadClassInstanceById('LayeredContainerPortal') as LayeredContainerPortal;
		this.rendererPortalContainer.containerOwner = this;
		this.needInit = true;
	}

	enable() {
		this.enabled = true;
		this._updateTargetContainer();
	}

	disable() {
		this.enabled = false;
		this._updateTargetContainer();
	}

	isRenderingLayered() {
		return this.enabled
		/// #if EDITOR
		 && this.rendererPortalContainer &&
		this._targetContainer;
		/// #endif
	}

	_updateTargetContainer() {
		if (this.rendererPortalContainer) {
			if (this._targetContainer && this.enabled) {
				let c = getValueByPath(this._targetContainer, this);
				assert(c, 'Invalid targetContainer data-path value: ' + this._targetContainer);
				if (this.rendererPortalContainer.parent !== c) {
					c.addChild(this.rendererPortalContainer);
				}
			}
		}
	}

	render(renderer: any) {
		if (this.needInit) {
			this._updateTargetContainer();
			this.needInit = false;
		}
		if (!this.isRenderingLayered()) {
			super.render(renderer);
		}
	}

	update(): void {
		super.update();
		if (this.rendererPortalContainer) {
			allPortalsContainers.add(this.rendererPortalContainer.parent);
		}
	}

	renderForPortal(renderer: any) {
		if (this.needInit) {
			this._updateTargetContainer();
			this._recursivePostUpdateTransform();
			this.updateTransform();
			this.needInit = false;
		}
		this.visible = this.parent.worldVisible;
		super.render(renderer);
	}

	onRemove() {
		if (this.rendererPortalContainer) {
			this.rendererPortalContainer.removeWithoutHolder();
		}
		super.onRemove();
	}
}
/// #if EDITOR
LayeredContainer.__requiredComponents = [LayeredContainerPortal];

/// #endif

const allPortalsContainers = new Set() as Set<Container>;

game.on('update', () => {
	allPortalsContainers.clear();
});

game.on('updated', () => {
	if (game.isUpdateBeforeRender) {
		allPortalsContainers.forEach(sortPortals);
	}
});

const sortPortals = (container:Container) => {
	if (container) {
		(container.children as LayeredContainerPortal[]).sort(sort);
	}
};

const sort = (a:LayeredContainerPortal, b:LayeredContainerPortal) => {
	return (a.containerOwner ? a.containerOwner.worldTransform.ty : 10000) - (b.containerOwner ? b.containerOwner.worldTransform.ty : 10000);
};
</file>

<file path="src/engine/lib/assets/src/extended/layered-contaiter-portal.c.ts">
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import type LayeredContainer from 'thing-editor/src/engine/lib/assets/src/extended/layered-container.c';

export default class LayeredContainerPortal extends Container {

	@editable({ type: 'ref' })
	containerOwner!: LayeredContainer;

	render(renderer: any) {
		if (this.containerOwner.isRenderingLayered()) {
			this.containerOwner.renderForPortal(renderer);
		}
	}

	onRemove() {
		super.onRemove();
		this.containerOwner.rendererPortalContainer = null as any;
		this.containerOwner = null as any;
	}

	/// #if EDITOR
	static __canAcceptParent() {
		return false;
	}
	/// #endif
}
</file>

<file path="src/engine/lib/assets/src/extended/mask.c.ts">
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import game from 'thing-editor/src/engine/game';

export default class Mask extends Container {

	_maskComponentIsActive = false;

	init() {
		super.init();
		this._maskComponentIsActive = true;
		if (this._enabled) {
			this.enableMask();
		}
	}

	@editable(editorUtils.makePreviewModeButton('Preview masked', 'components.Mask#preview-masked'))

	_enabled = true;
	@editable()

	set enabled(v) {
		this._enabled = v;
		if (this._maskComponentIsActive) {
			if (v) {
				this.enableMask();
			} else {
				this.disableMask();
			}
		}
	}

	get enabled() {
		return this._enabled;
	}

	__maskVisibilityTmp = false;

	enableMask() {
		this.mask = this.findChildByName('mask') as any;

		/// #if EDITOR
		if (!this.mask) {
			game.editor.ui.status.warn('Mask component did not found child named "mask".', 32022, this, undefined, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
		}
		/// #endif
		if (this.mask) {
			this.__maskVisibilityTmp = (this.mask as Container).visible;
		}
		if (this.mask) {
			(this.mask as Container).visible = true;
		}
	}

	disableMask() {
		if (this.mask) {
			(this.mask as Container).visible = this.__maskVisibilityTmp;
		}
		this.mask = null;
	}

	onRemove() {
		super.onRemove();
		this._maskComponentIsActive = false;
		this.disableMask();
	}

	/// #if EDITOR

	constructor() {
		super();
		this.__exitPreviewMode = this.__exitPreviewMode.bind(this);
	}

	__goToPreviewMode() {
		this.enableMask();
	}

	__exitPreviewMode() {
		this.disableMask();
	}
	/// #endif
}

/// #if EDITOR
Mask.__EDITOR_icon = 'tree/mask';

(Mask.prototype.enableMask as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Mask.prototype.disableMask as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/progress-bar.c.ts">
import type { DisplayObject, Sprite } from 'pixi.js';
import { Container, NineSlicePlane, Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import game from 'thing-editor/src/engine/game';
import Shape from 'thing-editor/src/engine/lib/assets/src/extended/shape.c';

import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import getValueByPath, { setValueByPath } from 'thing-editor/src/engine/utils/get-value-by-path';
import { stepTo } from 'thing-editor/src/engine/utils/utils';

const tmpPoint = new Point();


function setObjectHeight(node: DisplayObject, height: number) {
	if (node instanceof Shape || node instanceof NineSlicePlane) { //prevent wrong size in next life of "bar" sprite instance
		node.height = height;
	} else if ((node as Sprite).texture) {
		node.scale.y = height / (node as Sprite).texture.height;
		if (game.classes.Fill && (node instanceof game.classes.Fill)) {
			(node as any).yRepeat = node.scale.y;
		}
	}
}

const TIP = `Contains string path to javascript variable to get value from.
As example path can be: <b>game.stage.height</b> or <b>this.parent.name</b>.
Supports <b>game</b>, <b>this</b> or Component's class name as root object.
Use '#' to access to child scene nodes by name: <b>game.currentScene.#myChildElementsName.x</b>.`;

export default class ProgressBar extends Container {

	@editable({ name: 'height', type: 'number', min: 0, default: 200 })

	@editable({ type: 'data-path', important: true, tip: TIP })
	dataPath = null;

	@editable({ min: 0 })
	capMargin = 5;

	@editable({ min: 0 })
	refreshInterval = 10;

	@editable()
	reverse = false;

	@editable({ type: 'callback' })
	onFinish = null;

	@editable({ type: 'callback' })
	onChanged = null;

	@editable({ type: 'callback' })
	afterSlide = null;

	@editable({ step: 0.00001 })
	min = 0;

	@editable({ step: 0.00001 })
	max = 100;

	@editable({ step: 0.00001, min: 0 })
	step = 1;

	@editable()
	smooth = false;

	@editable({ min: 0.000000001, step: 0.001, visible: o => o.smooth })
	smoothStep = 0.01;

	@editable({ min: 0, tip: 'progress bar launches animations "progress-item-1", "progress-item-2", ... during the progress' })
	itemsCount = 6;

	calledItem = 0;

	@editable({ type: 'ref' })
	bar?: Container;

	@editable({ type: 'ref' })
	cap?: Container;

	scrolling = false;

	currentInterval = 0;

	@editable({disabled: () => true, visible: () => !game.__EDITOR_mode, type: 'ref'})
	showedVal: any = undefined;

	isProgressFinished = true;

	private currentQ = 0;
	private targetQ = 0;

	init() {
		super.init();
		this.scrolling = false;
		this.currentInterval = 0;
		this.showedVal = undefined;
		this._initChildren();

		this.calledItem = 0;

		this.cursor = this.interactive ? 'pointer' : '';
		this.on('pointerdown', this.onDown);
		this._applyBgHeight();
		this.isProgressFinished = false;
	}

	_initChildren() {
		this.bar = this.findChildByName('bar');
		this.cap = this.findChildByName('cap');
	}

	_progress_bar_height = 200;

	get height() {
		return this._progress_bar_height;
	}

	set height(v) {
		if (this._progress_bar_height !== v) {
			this._progress_bar_height = v;
			this.applyValue(this.showedVal || 0);
			this._applyBgHeight();
		}
	}

	_applyBgHeight() {
		let h = this.getChildByName('bg');
		if (h) {
			setObjectHeight(h, this._progress_bar_height!);
		}
		const hitArea = this.findChildByName('hit-area');
		if (hitArea) {
			setObjectHeight(hitArea, this._progress_bar_height! + hitArea.y * -2);
		}
	}

	onRemove() {
		super.onRemove();
		this._progress_bar_height = 0;
		this.currentQ = 0;
		this.showedVal = undefined;
		this.bar = undefined;
		this.cap = undefined;
		this.removeListener('pointerdown', this.onDown);
		this.isProgressFinished = true;
	}

	onDown() {
		if (this.isCanBePressed) {
			this.scrolling = true;
		}
	}

	isMin() {
		return this.showedVal === this.min;
	}

	isMax() {
		return this.showedVal === this.max;
	}

	update() {
		if (this.scrolling) {
			if (game.mouse.click) {
				let p = this.toLocal(game.mouse, game.stage, tmpPoint, true);
				let q = p.y / this._progress_bar_height!;
				if (q < 0) {
					q = 0;
				} else if (q > 1) {
					q = 1;
				}
				let val = this.min + q * (this.max - this.min);
				if (this.step > 0) {
					val = Math.round(val / this.step) * this.step;
				}
				this.applyValue(val);
				if (this.dataPath) {
					setValueByPath(this.dataPath, val, this);
				}
			} else {
				this.scrolling = false;
				if (this.afterSlide) {
					callByPath(this.afterSlide, this);
				}
			}
		} else if (this.currentInterval <= 0 && this.dataPath) {
			let val = getValueByPath(this.dataPath, this);
			if (val || val === 0) {
				if (val > this.max) {
					val = this.max;
				}
				if (val < this.min) {
					val = this.min;
				}
				if (val !== this.showedVal) {
					this.applyValue(val);
				}
			} else {
				this.showedVal = undefined;
			}
			this.currentInterval = this.refreshInterval;
		} else {
			this.currentInterval--;
		}
		if (this.smooth) {
			this.currentQ = stepTo(this.currentQ, this.targetQ, this.smoothStep);
			this.applyQ();
		}
		super.update();
	}

	applyValue(val: number) {
		if (val !== this.showedVal) {
			if (this.onChanged
				/// #if EDITOR
				&& !game.__EDITOR_mode
				/// #endif
			) {
				callByPath(this.onChanged, this);
			}
		}
		let q = (val - this.min) / (this.max - this.min);
		this.targetQ = q;
		if (typeof this.showedVal === 'undefined') {
			this.currentQ = q;
		}
		this.showedVal = val;

		if (!this.smooth) {
			this.currentQ = q;
			this.applyQ();
		}
	}

	applyQ() {
		if (this.onFinish && !this.isProgressFinished && this.currentQ === 1) {
			this.isProgressFinished = true;
			callByPath(this.onFinish, this);
		}
		const reachedItem = Math.floor(this.currentQ * this.itemsCount);
		while (reachedItem > this.calledItem) {
			this.calledItem++;
			this.gotoLabelRecursive('progress-item-' + this.calledItem);
		}

		/// #if EDITOR
		if (game.__EDITOR_mode) {
			this._initChildren();
		}
		/// #endif

		const q = this.reverse ? (1 - this.currentQ) : this.currentQ;
		if (this.bar) {
			setObjectHeight(this.bar, this._progress_bar_height * q);
		}
		if (this.cap) {
			this.cap.y = this.capMargin + (this._progress_bar_height - this.capMargin * 2) * q;
		}
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			this.bar = undefined;
			this.cap = undefined;
		}
		/// #endif
	}

	refreshNow() {
		this.currentInterval = 0;
	}

	/// #if EDITOR
	__beforeDeserialization() {
		this._progress_bar_height = 0;
	}

	__afterDeserialization() {
		this._applyBgHeight();
	}
	/// #endif
}
</file>

<file path="src/engine/lib/assets/src/extended/resizer.c.ts">
import type { Renderer } from 'pixi.js';
import { Container, Point } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import roundUpPoint from 'thing-editor/src/editor/utils/round-up-point';
import game from 'thing-editor/src/engine/game';

const p0 = new Point(0, 0);
const p1 = new Point(1, 1);
const p = new Point();
const p2 = new Point();

/// #if EDITOR
const afterEdited = () => {
	for (const o of game.editor.selection as any as Resizer[]) {
	 o.recalculateSize();
	}
};
/// #endif

export default class Resizer extends Container {

	init() {
		super.init();
		this.recalculateSize();
	}

	_onRenderResize() {
		this.recalculateSize();
	}

	recalculateSize() {
		if (this.fixed && this.parent) {
			if (this.relativeX || this.relativeY) {
				p.x = Math.round(this._xPos * game.W);
				p.y = Math.round(this._yPos * game.H);
				this.parent.toLocal(p, game.stage, p, false);
				/// #if EDITOR
				if (!isNaN(p.x)) {
					roundUpPoint(p);
					/// #endif
					if (this.relativeX) {
						this.x = p.x;
					}
					if (this.relativeY) {
						this.y = p.y;
					}
					/// #if EDITOR
				}
				/// #endif
			}

			if (this.resizeX || this.resizeY) {
				this.parent.toLocal(p0, game.stage, p, false);
				this.parent.toLocal(p1, game.stage, p2, false);
				if (this.resizeX) {
					this.scale.x = game.W / game.projectDesc.width * ((p2.x - p.x) || 0.000001);
				}
				if (this.resizeY) {
					this.scale.y = game.H / game.projectDesc.height * ((p2.y - p.y) || 0.000001);
				}
			}
		} else {
			if (this.resizeX) {
				this.scale.x = game.W / game.projectDesc.width;
			}
			if (this.resizeY) {
				this.scale.y = game.H / game.projectDesc.height;
			}
			if (this.relativeX) {
				this.x = Math.round(game.W * this._xPos);
			}
			if (this.relativeY) {
				this.y = Math.round(game.H * this._yPos);
			}
		}
	}

	update() {
		if (this.fixed) {
			this.recalculateSize();
		}
		super.update();
	}

	/// #if EDITOR

	render(renderer: Renderer): void {
		if (this.fixed && game.__EDITOR_mode) {
			this.recalculateSize();
		}
		super.render(renderer);
	}

	_resizeX = false;

	@editable()
	set resizeX(v) {
		this._resizeX = v;
		if (game.__EDITOR_mode) {
			if (!v) {
				this.scale.x = 1;
			}
		}
	}

	get resizeX() {
		return this._resizeX;
	}

	_resizeY = false;

	@editable()
	set resizeY(v) {
		this._resizeY = v;
		if (game.__EDITOR_mode) {
			if (!v) {
				this.scale.y = 1;
			}
		}
	}

	get resizeY() {
		return this._resizeY;
	}
	/// #endif

	@editable()
	relativeX = false;

	_xPos = 0;

	@editable({ min: -1, max: 1, step: 0.01, visible: (o) => { return o.relativeX; } })
	set xPos(v) {
		this._xPos = v;
		if (this.relativeX) {
			this.recalculateSize();
		}
	}

	get xPos() {
		return this._xPos;
	}

	@editable()
	relativeY = false;

	_yPos = 0;

	@editable({ min: -1, max: 1, step: 0.01, visible: (o) => { return o.relativeY; } })
	set yPos(v) {
		this._yPos = v;
		if (this.relativeY) {
			this.recalculateSize();
		}
	}

	get yPos() {
		return this._yPos;
	}

	/// #if EDITOR

	__afterDeserialization() {
		if (game.__EDITOR_mode) {
			this.recalculateSize();
		}
	}

	__afterSerialization(data: SerializedObject) {
		if (this.resizeX) {
			delete data.p['scale.x'];
		}
		if (this.resizeY) {
			delete data.p['scale.y'];
		}
		if (this.relativeX) {
			delete data.p.x;
		}
		if (this.relativeY) {
			delete data.p.y;
		}
	}
	/// #endif

	@editable({afterEdited, visible: (o) => { return o.resizeX || o.resizeY || o.relativeY || o.relativeX; } })
	fixed = false;

}


/// #if EDITOR


Resizer.__EDITOR_icon = 'tree/resizer';

Resizer.__EDITOR_tip = '<b>Resizer</b> - component has sense only for project with <b>dynamicStageSize</b>';

/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/scroll-layer.c.ts">
import type { FederatedPointerEvent } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import game from 'thing-editor/src/engine/game';
import Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';
import { mouseHandlerGlobal } from 'thing-editor/src/engine/utils/game-interaction';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';
import { stepTo } from 'thing-editor/src/engine/utils/utils';
import Button from '../basic/button.c';

let draggingLayer: ScrollLayer | null;
let mouseX_prev = 0;
let mouseY_prev = 0;

const WHEEL_EVENT_OPTIONS =
	/// #if EDITOR
	true;
/*
/// #endif
{ passive: false, capture: true };
//*/
/// #if EDITOR
const DISABLE_XY_TIP = 'ScrollLayer uses it`s x,y to handle scrolling. If you want move ScrollLayer to non zero position, wrap it in to container and move container instead.';
/// #endif

export default class ScrollLayer extends Container {

	constructor() {
		super();
		this.onDown = this.onDown.bind(this);
		this.onWheel = this.onWheel.bind(this);
	}

	callAfterScroll!: null | (() => void);

	autoScrolling = false;

	__virtualScrollX = 0;
	__virtualScrollY = 0;

	scrollToX = 0;
	scrollToY = 0;

	xSpeed = 0;
	ySpeed = 0;

	@editable({ name: 'interactive', default: true, override: true })
	@editable({ name: 'x', override: true, disabled: () => DISABLE_XY_TIP })
	@editable({ name: 'y', override: true, disabled: () => DISABLE_XY_TIP })

	@editable({ type: 'rect', rect_maxX: 0, rect_maxY: 0, rect_minX: 0, rect_minY: 0, afterEdited: validateAreas })
	visibleArea!: EditableRect;

	@editable({ type: 'rect', guideColor: 0xFF4400, rect_maxX: 0, rect_maxY: 0, rect_minX: 0, rect_minY: 0, afterEdited: validateAreas })
	fullArea!: EditableRect;

	@editable({ type: 'data-path', isValueValid: o => (o instanceof Container) })
	mouseHandler = null;

	@editable({ type: 'ref' })
	_mouseHandlerContainer!: Container;

	@editable({ max: 0.99, min: 0, step: 0.01, })
	desktopInertia = 0.8;

	@editable({ max: 0.99, min: 0, step: 0.01, })
	mobileInertia = 0.92;

	@editable()
	bouncingBounds = true;

	init() {
		super.init();
		if (this.mouseHandler) {
			this._mouseHandlerContainer = getValueByPath(this.mouseHandler, this);
			this._mouseHandlerContainer.on('pointerdown', this.onDown);
			/// #if EDITOR
			if (!this._mouseHandlerContainer.interactive) {
				let isInteractiveChildFound = false;
				this._mouseHandlerContainer.forAllChildren((o) => {
					if (!isInteractiveChildFound) {
						isInteractiveChildFound = o.interactive;
					}
				});
				if (!isInteractiveChildFound) {
					game.editor.ui.status.warn('ScrollLayer\'s mouseHandler refers to container which has no interactive children.', 32047, this, 'mouseHandler', undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
				}
			}
			/// #endif
		} else {
			this._mouseHandlerContainer = null as any;
			(game.pixiApp.view as HTMLCanvasElement).addEventListener('pointerdown', this.onDown);
		}

		document.addEventListener('wheel', this.onWheel, WHEEL_EVENT_OPTIONS);
		this.autoScrolling = false;
		this.xSpeed = 0;
		this.ySpeed = 0;
		this._virtualScrollX = this.x;
		this._virtualScrollY = this.y;
	}

	onWheel(ev: WheelEvent) {
		if (this.autoScrolling) {
			return;
		}

		let d = 0;
		if (this._mouseHandlerContainer) {
			if (this._mouseHandlerContainer.isCanBePressed) {
				let p = game.mouse;
				if (this._mouseHandlerContainer.getBounds().contains(p.x, p.y)) {
					d = ev.deltaY;
					ev.stopPropagation();
					if (ev.cancelable) {
						ev.preventDefault();
					}
				}
			}
		} else {
			if (this.isCanBePressed) {
				d = ev.deltaY;
				ev.stopPropagation();
				if (ev.cancelable) {
					ev.preventDefault();
				}
			}
		}
		if (d) {
			if (ev.deltaMode === 1) {
				d *= 60;
			}
			d = Math.min(60, Math.max(-60, d));
			if (this.isYScrollAvailable) {
				this.ySpeed = -d;
			} else if (this.isXScrollAvailable) {
				this.xSpeed = d;
			}
		}
	}

	onDown(ev: PointerEvent | FederatedPointerEvent) {
		if (this.worldVisible && this.getRootContainer().parent) {
			if (Button.downedButton && Button.downedButton.isCanBePressed) {
				let p = Button.downedButton.parent;
				while (p) {
					if (p === this) {
						break;
					}
					p = p.parent;
					if (!p) {
						return;
					}
				}
			}
			mouseHandlerGlobal(ev);
			draggingLayer = this;
			mouseX_prev = game.mouse.x;
			mouseY_prev = game.mouse.y;
		}
	}

	static updateGlobal() {
		if (draggingLayer) {
			if (!draggingLayer.getRootContainer().parent) {
				draggingLayer.stopDragThisLayer();
				return;
			}
			draggingLayer.updateGlobal();
		}
	}

	updateGlobal() {
		if (game.mouse.click) {
			if (this.fullArea.w > this.visibleArea.w) {
				this.xSpeed = (game.mouse.x - mouseX_prev) / this.worldTransform.a;
				this._virtualScrollX += this.xSpeed;
			}
			if (this.fullArea.h > this.visibleArea.h) {
				this.ySpeed = (game.mouse.y - mouseY_prev) / this.worldTransform.d;
				this._virtualScrollY += this.ySpeed;
			}
			mouseX_prev = game.mouse.x;
			mouseY_prev = game.mouse.y;
			this.applyLimit();
		}
	}

	onRemove() {
		this.stopDragThisLayer();
		document.removeEventListener('wheel', this.onWheel, WHEEL_EVENT_OPTIONS);

		if (this._mouseHandlerContainer) {
			this._mouseHandlerContainer.removeListener('pointerdown', this.onDown);
			this._mouseHandlerContainer = null as any;
		} else {
			(game.pixiApp.view as HTMLCanvasElement).removeEventListener('pointerdown', this.onDown);
		}
		super.onRemove();
	}

	update() {
		if (this.visible) {

			if (draggingLayer !== this) {

				this._virtualScrollX += this.xSpeed;
				this._virtualScrollY += this.ySpeed;
				if (!this.autoScrolling) {
					if (game.isMobile.any) {
						this.xSpeed *= this.mobileInertia;
						this.ySpeed *= this.mobileInertia;
					} else {
						this.xSpeed *= this.desktopInertia;
						this.ySpeed *= this.desktopInertia;
					}
					this.xSpeed = stepTo(this.xSpeed, 0, 0.1);
					this.ySpeed = stepTo(this.ySpeed, 0, 0.1);
				} else {
					this.xSpeed *= 0.98;
					this.ySpeed *= 0.98;
				}
			}

			if (this.autoScrolling) {
				this._checkScrollToBounds();
				this.xSpeed += (this.scrollToX - this._virtualScrollX) * 0.06;
				this.ySpeed += (this.scrollToY - this._virtualScrollY) * 0.06;
				this.xSpeed *= 0.7;
				this.ySpeed *= 0.7;
				if ((Math.abs(this.scrollToX - this._virtualScrollX) <= 1) && (Math.abs(this.xSpeed) < 0.5) && (Math.abs(this.scrollToY - this._virtualScrollY) <= 1) && (Math.abs(this.ySpeed) < 0.5)) {
					this.xSpeed = 0;
					this.ySpeed = 0;
					if (this.callAfterScroll) {
						this.callAfterScroll();
					}
					this._virtualScrollX = this.scrollToX;
					this._virtualScrollY = this.scrollToY;
					this.callAfterScroll = null;
					this.autoScrolling = false;
				}
			}

			this.applyLimit();

		} else {
			this.xSpeed = 0;
			this.ySpeed = 0;
		}

		if (!this.visible || !game.mouse.click) {
			this.stopDragThisLayer();
		}
		super.update();
	}

	private applyLimit() {

		let v = this.visibleArea;
		let f = this.fullArea;

		let limitShift = 0;

		if (((v.x + v.w) - this._virtualScrollX) > (f.x + f.w)) {
			limitShift = (((v.x + v.w) - this._virtualScrollX) - (f.x + f.w));
		}
		if ((v.x - this._virtualScrollX - limitShift) < f.x) {
			limitShift = -(f.x - (v.x - this._virtualScrollX));
		}

		if (limitShift !== 0) {
			if (this.bouncingBounds) {
				this.xSpeed *= 0.95;
				this._virtualScrollX = stepTo(this._virtualScrollX, this._virtualScrollX + limitShift, Math.abs(limitShift / 4));
			} else {
				this.xSpeed = 0;
				this._virtualScrollX += limitShift;
			}
		}

		limitShift = 0;
		if (((v.y + v.h) - this._virtualScrollY) > (f.y + f.h)) {
			limitShift = (((v.y + v.h) - this._virtualScrollY) - (f.y + f.h));
		}
		if ((v.y - this._virtualScrollY - limitShift) < f.y) {
			limitShift = -(f.y - (v.y - this._virtualScrollY));
		}

		if (limitShift !== 0) {
			if (this.bouncingBounds) {
				this.ySpeed *= 0.95;
				this._virtualScrollY = stepTo(this._virtualScrollY, this._virtualScrollY + limitShift, Math.abs(limitShift / 4));
			} else {
				this.ySpeed = 0;
				this._virtualScrollY += limitShift;
			}
		}
	}

	scrollRight(pow = 16) {
		this.stopDragThisLayer();
		this.xSpeed = -pow;
	}

	scrollDown(pow = 16) {
		this.stopDragThisLayer();
		this.ySpeed = -pow;
	}

	get canScrollUp() {
		return this.y < 0;
	}

	get canScrollDown() {
		return (-this.y + this.visibleArea.h) < this.fullArea.h;
	}

	get relativeScrollY() {
		return -(this.autoScrolling ? this.scrollToY : this._virtualScrollY) / Math.max(1, this.fullArea.h - this.visibleArea.h);
	}

	set relativeScrollY(val) {
		this._virtualScrollY = -val * (this.fullArea.h - this.visibleArea.h);
	}

	get relativeScrollX() {
		return -(this.autoScrolling ? this.scrollToX : this._virtualScrollX) / Math.max(1, this.fullArea.w - this.visibleArea.w);
	}

	set relativeScrollX(val) {
		this._virtualScrollX = -val * (this.fullArea.w - this.visibleArea.w);
	}

	get isXScrollAvailable() {
		return this.visibleArea.w < this.fullArea.w;
	}

	get isYScrollAvailable() {
		return this.visibleArea.h < this.fullArea.h;
	}

	set _virtualScrollX(v) {
		this.__virtualScrollX = v;
		this.x = Math.round(v);
	}

	get _virtualScrollX() {
		return this.__virtualScrollX;
	}

	set _virtualScrollY(v) {
		this.__virtualScrollY = v;
		this.y = Math.round(v);
	}

	get _virtualScrollY() {
		return this.__virtualScrollY;
	}

	_checkScrollToBounds() {
		let v = this.visibleArea;
		let f = this.fullArea;

		if (this.scrollToX > -f.x) {
			this.scrollToX = -f.x;
		} else if (this.scrollToX < -(f.x + f.w - v.w)) {
			this.scrollToX = -(f.x + f.w - v.w);
		}

		if (this.scrollToY > -f.y) {
			this.scrollToY = -f.y;
		} else if (this.scrollToY < -(f.y + f.h - v.h)) {
			this.scrollToY = -(f.y + f.h - v.h);
		}
	}

	stopDragThisLayer() {
		if (draggingLayer === this) {
			draggingLayer = null;
		}
	}

	scrollTo(o: Container, callback?: () => void, instantly = false) {
		if (!o || (this.fullArea.w <= this.visibleArea.w && this.fullArea.h <= this.visibleArea.h)) {
			this.autoScrolling = false;
			this.xSpeed = 0;
			this.ySpeed = 0;
			return;
		}

		if (typeof o === 'string') {
			o = this.getChildByName(o)!;
		}

		this.stopDragThisLayer();
		this.autoScrolling = true;
		this.scrollToX = this.visibleArea.w / 2 - o.x;
		this.scrollToY = this.visibleArea.h / 2 - o.y;

		this._checkScrollToBounds();

		if (instantly || !this.worldVisible) {
			this._virtualScrollX = this.scrollToX;
			this._virtualScrollY = this.scrollToY;
		}
		this.callAfterScroll = callback!;
	}
}

game.on('global-update', ScrollLayer.updateGlobal);

/// #if EDITOR
ScrollLayer.__EDITOR_icon = 'tree/scroll';

function validateAreas() {
	for (const o of game.editor.selection as any as ScrollLayer[]) {
		let w = Math.max(o.visibleArea.w, o.fullArea.w);
		let h = Math.max(o.visibleArea.h, o.fullArea.h);
		if (o.fullArea.w !== w || o.fullArea.h !== h) {
			o.fullArea.w = w;
			o.fullArea.h = h;
			game.editor.refreshPropsEditor();
		}
	}
}
/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/shape.c.ts">
import type { Point } from 'pixi.js';
import { Circle, Ellipse, Graphics, Polygon, Rectangle, RoundedRectangle } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable.js';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';

export const enum SHAPE_TYPE {
	RECT = 0,
	ROUND_RECT = 1,
	CIRCLE = 2,
	ELLIPSE = 3,
	POLY = 4,
}

const isShapeHasWidthHeight = (o: Shape) => {
	return o.shape === SHAPE_TYPE.RECT ||
		o.shape === SHAPE_TYPE.ROUND_RECT ||
		o.shape === SHAPE_TYPE.ELLIPSE;
};

const isShapeHasRedius = (o: Shape) => {
	return o.shape === SHAPE_TYPE.ROUND_RECT ||
		o.shape === SHAPE_TYPE.CIRCLE;
};

const DEFAULT_POINTS = [[-30, -30], [30, -10], [-10, 30]];

const shapeTypeSelect = [
	{ name: 'Rect', value: SHAPE_TYPE.RECT },
	{ name: 'Round Rect', value: SHAPE_TYPE.ROUND_RECT },
	{ name: 'Circle', value: SHAPE_TYPE.CIRCLE },
	{ name: 'Ellipse', value: SHAPE_TYPE.ELLIPSE },
	{ name: 'Polygon', value: SHAPE_TYPE.POLY }
];

export default class Shape extends Graphics {

	/// #if EDITOR
	constructor() {
		super();
		this._width = 100;
		this._height = 100;
		this.__pointsUpdate = this.__pointsUpdate.bind(this);
	}
	/// #endif

	protected _shape: SHAPE_TYPE = SHAPE_TYPE.RECT;

	protected __deserialized = false;
	protected _shapeRadius = 10;

	protected _lineColor = 0xFFFFFF;
	protected _fillColor = 0;
	protected _fillAlpha = 1;
	protected _llineAlpha = 1;
	protected _lineWidth = 0;
	protected _lineAlignment = 1;

	protected __pointsUpdateIntervalInitialized = 0;

	@editable({ type: 'ref', visible: (o) => { return o.shape === SHAPE_TYPE.POLY && !o.__nodeExtendData.isPrefabReference; } })
	protected set _shapePoints(v: Point[] | null) {
		this.__shapePoints = v;
		/// #if EDITOR
		if (v) {
			for (let o of v) {
				Object.freeze(o);
			}
		}
		/// #endif
	}

	protected get _shapePoints(): Point[] | null {
		return this.__shapePoints;
	}

	protected __shapePoints: Point[] | null = null;

	init() {
		super.init();
		this._drawThing();
		if (this.isItHitArea && this.parent) {
			this.applyHitAreaToParent();
		}
		this.__deserialized = true;
	}

	protected _drawThing() {
		this.clear();
		if (!this.isItHitArea
			/// #if EDITOR
			|| game.__EDITOR_mode
			/// #endif

		) {
			this.lineStyle(this.shapeLineWidth, this.shapeLineColor, this.shapeLineAlpha, this.shapeLineAlignment);
			this.beginFill(this.shapeFillColor, this.shapeFillAlpha);
			this.drawThing();
			this.endFill();
		}
	}

	drawThing() {
		let points;
		switch (this.shape) {
		case SHAPE_TYPE.ROUND_RECT:
			this.drawRoundedRect(0, 0, this.width, this.height, this.shapeRadius);
			break;
		case SHAPE_TYPE.RECT:
			this.drawRect(0, 0, this.width, this.height);
			break;
		case SHAPE_TYPE.CIRCLE:
			this.drawCircle(0, 0, this.shapeRadius);
			break;
		case SHAPE_TYPE.ELLIPSE:
			this.drawEllipse(0, 0, this.width, this.height);
			break;
		case SHAPE_TYPE.POLY:
			/// #if EDITOR
			if (!this._shapePoints) {
				this._shapePoints = [];
			}
			while (this._shapePoints.length < DEFAULT_POINTS.length) {
				let p = {
					x: DEFAULT_POINTS[this._shapePoints.length][0],
					y: DEFAULT_POINTS[this._shapePoints.length][1]
				};
				this._shapePoints.push(p as Point);
				Object.freeze(p);
			}
			/// #endif
			if (this._shapePoints.length > 2) {
				points = [];
				for (let c of this._shapePoints) {
					points.push(c.x, c.y);
				}
				this.drawPolygon(points);
			}
			break;
		}
	}

	getHitareaShape() {
		switch (this.shape) {
		case SHAPE_TYPE.ROUND_RECT:
			return new RoundedRectangle(this.x, this.y, this.width, this.height, this.shapeRadius);
			break;
		case SHAPE_TYPE.RECT:
			return new Rectangle(this.x, this.y, this.width, this.height);
			break;
		case SHAPE_TYPE.CIRCLE:
			return new Circle(this.x, this.y, this.shapeRadius);
			break;
		case SHAPE_TYPE.ELLIPSE:
			return new Ellipse(this.x, this.y, this.width, this.height);
			break;

		case SHAPE_TYPE.POLY:
			if ((this._shapePoints as Point[]).length > 2) {
				let points = [];
				for (let c of this._shapePoints as Point[]) {
					points.push(c.x + this.x, c.y + this.y);
				}
				return new Polygon(points);
			}
			break;
		}
		return null;
	}

	applyHitAreaToParent() {
		this.parent.hitArea = this.getHitareaShape();
		this.visible = false;
	}

	onRemove() {
		super.onRemove();
		this.clear();
		if (this.isItHitArea && this.parent) {
			this.parent.hitArea = null;
		}
		this.__deserialized = false;
	}

	@editable({ select: shapeTypeSelect, important: true, visible: (o) => !o.__nodeExtendData.isPrefabReference })
	set shape(s: SHAPE_TYPE) {
		this._shape = s;
		if (this.__deserialized) {
			/// #if EDITOR
			if (s === SHAPE_TYPE.POLY) {
				if (!this._shapePoints) {
					this._shapePoints = [];
				}
			} else {
				this._shapePoints = null;
				this.__stopPointsRefreshInterval();

			}
			/// #endif

			this._drawThing();

			/// #if EDITOR
			if (s === SHAPE_TYPE.POLY) {
				this.__startPointRefreshIfSelected();
			}
			/// #endif
		}
	}

	get shape() {
		return this._shape;
	}

	@editable({ visible: isShapeHasWidthHeight, important: true })
	set width(s) {
		this._width = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get width() {
		return this._width;
	}

	@editable({ visible: isShapeHasWidthHeight, important: true })
	set height(s) {
		this._height = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get height() {
		return this._height;
	}

	@editable({ visible: isShapeHasRedius, important: true })
	set shapeRadius(s) {
		this._shapeRadius = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeRadius() {
		return this._shapeRadius;
	}

	@editable({ min: 0, max: 1, step: 0.01, default: 1 })
	set shapeFillAlpha(s) {
		this._fillAlpha = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeFillAlpha() {
		return this._fillAlpha;
	}

	@editable({ type: 'color', visible: (o) => { return o.shapeFillAlpha > 0; } })
	set shapeFillColor(s) {
		this._fillColor = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeFillColor() {
		return this._fillColor;
	}

	@editable({ min: 0 })
	set shapeLineWidth(s) {
		this._lineWidth = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeLineWidth() {
		return this._lineWidth;
	}

	@editable({ type: 'color', visible: (o) => { return o.shapeLineWidth > 0; } })
	set shapeLineColor(s) {
		this._lineColor = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeLineColor() {
		return this._lineColor;
	}

	@editable({ min: 0, max: 1, step: 0.01, visible: (o) => { return o.shapeLineWidth > 0; } })
	set shapeLineAlpha(s) {
		this._llineAlpha = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeLineAlpha() {
		return this._llineAlpha;
	}

	@editable({ min: 0, max: 1, step: 0.01, visible: (o) => { return o.shapeLineWidth > 0; } })
	set shapeLineAlignment(s) {
		this._lineAlignment = s;
		if (this.__deserialized) {
			this._drawThing();
		}
	}

	get shapeLineAlignment() {
		return this._lineAlignment;
	}

	@editable()
	isItHitArea = false;

	/// #if EDITOR

	__EDITOR_onCreate() {
		this.__deserialized = true;
		this.shape = this._shape;
	}

	__afterDeserialization() {
		this.__deserialized = true;
		this._drawThing();
	}

	__beforeDeserialization() {
		this.__deserialized = false;
	}

	__removePolyPoints() {
		for (let i = this.children.length - 1; i >= 0; i--) {
			let c = this.children[i];
			if (c.name === '___point') {
				c.remove();
			}
		}
	}

	__afterSerialization(data: SerializedObject) {
		if (this._shapePoints && !this.__nodeExtendData.isPrefabReference && this.shape === SHAPE_TYPE.POLY) {
			data.p._shapePoints = this._shapePoints;
		}
	}

	__onSelect() {
		super.__onSelect();
		this.__startPointRefreshIfSelected();
	}

	__onChildSelected() {
		this.__startPointRefreshIfSelected();
	}

	__showPoints() {
		if (this.shape === SHAPE_TYPE.POLY) {
			if (game.__EDITOR_mode) {
				this.__removePolyPoints();
				for (let p of this._shapePoints as Point[]) {
					this.__newPointView(p);
				}
			}
		}
	}

	__beforeDestroy() {
		this.__stopPointsRefreshInterval();
	}

	__stopPointsRefreshInterval() {
		if (this.__pointsUpdateIntervalInitialized) {
			this.__removePolyPoints();
			game.editor.refreshTreeViewAndPropertyEditor();
			clearInterval(this.__pointsUpdateIntervalInitialized);
			this.__pointsUpdateIntervalInitialized = 0;
		}
	}

	__pointsUpdate() {
		let isAnyPointSelected;

		this._shapePoints = [];
		for (let o of this.children) {
			if (o.name === '___point') {
				if (o.__nodeExtendData.isSelected) {
					isAnyPointSelected = true;
				}
				this._shapePoints.push({
					x: o.x,
					y: o.y
				} as Point);
			}
		}

		this._shapePoints.some(i => Object.freeze(i));

		this._drawThing();


		if (this.shape !== SHAPE_TYPE.POLY || !isAnyPointSelected && !this.__nodeExtendData.isSelected) {
			this.__stopPointsRefreshInterval();
		}
	}

	__newPointView(src: Point) {
		let p: Shape = Lib._deserializeObject({ c: 'Shape', p: {} }) as Shape;
		p.name = '___point';
		p.shape = SHAPE_TYPE.RECT;
		p.width = 4;
		p.height = 4;
		p.pivot.x = 2;
		p.pivot.y = 2;
		p.alpha = 0.5;
		p.shapeFillColor = 0xffaa00;
		p.x = src.x;
		p.y = src.y;
		this.addChild(p);
		let extData = p.__nodeExtendData;
		extData.hidePropsEditor = { title: 'Polygon\'s vertex is selected', visibleFields: { x: true, y: true } };
		extData.noSerialize = true;
		return p;
	}

	__startPointRefreshIfSelected() {
		if (game.__EDITOR_mode && !this.__nodeExtendData.isPrefabReference && (this.shape === SHAPE_TYPE.POLY) && (!this.__pointsUpdateIntervalInitialized)) {
			let isAnySelected = this.__nodeExtendData.isSelected;
			if (!isAnySelected) {
				for (let o of this.children) {
					if ((o.name === '___point') && o.__nodeExtendData.isSelected) {
						isAnySelected = true;
						break;
					}
				}
			}

			if (isAnySelected) {
				this.__showPoints();
				this.__pointsUpdateIntervalInitialized = window.setInterval(this.__pointsUpdate, 40);
			}

		}
	}
	/// #endif
}

/// #if EDITOR
Shape.__EDITOR_icon = 'tree/shape';
/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/spine.c.ts">
import type { ISkeletonData, Spine as TSpine } from 'pixi-spine';

import type { Point, Renderer, Sprite } from 'pixi.js';
import { Assets, Container } from 'pixi.js';
import type { IGoToLabelConsumer } from 'thing-editor/src/editor/editor-env';
import { type FileDesc } from 'thing-editor/src/editor/fs';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags';
import { decorateGotoLabelMethods } from 'thing-editor/src/editor/utils/goto-label-consumer';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib, { unHashedFileToHashed } from 'thing-editor/src/engine/lib';
import type MovieClip from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import { ACTION_ICON_STOP } from 'thing-editor/src/engine/lib/assets/src/basic/movie-clip.c';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';

const poolMap = new Map() as Map<string, SpineContent[]>;

const _initSpineParser = () => {
	const atlasLoader = Assets.loader.parsers.find((p) => {
		return p.test && p.test('a.atlas');
	});
	const originalAtlasParser = atlasLoader!.parse!;
	atlasLoader!.parse = (asset: string, options, ...args) => {
		asset = asset.split('\n\n').map((texture) => {
			let imageName = texture.substring(0, texture.indexOf('\n'));
			assert(!imageName.includes('\r'), 'Spine file contain \\r\\n line break styles. Can not parse spine: ' + asset);
			const a = options!.src!.split('/');
			a.pop();
			a.push(imageName);
			const hashedFileName = unHashedFileToHashed.get(a.join('/'))!;
			return texture.replace(imageName, hashedFileName.split('/').pop()!);

		}).join('\n\n');
		return originalAtlasParser(asset, options, ...args);
	};
};

function pool(name:string): SpineContent[] {
	if (!poolMap.has(name)) {
		poolMap.set(name, []);
	}
	return poolMap.get(name)!;
}

function getSpineInstance(name:string):SpineContent {
	let p = pool(name);
	if (p.length === 0) {
		let res = Lib.resources[name];
		/// #if EDITOR
		if (!res) {
			return null as any;
		}
		res.___lastTouch = EDITOR_FLAGS.__touchTime;
		/// #endif
		let ret = new (window as any).PIXI.spine.Spine(res.spineData) as SpineContent;
		ret.autoUpdate = false;
		assert(!(ret as any)._poolName, 'Spine structure changed. Pooling needs refactoring (_poolName field renaming).');
		(ret as any)._poolName = name;
		/// #if EDITOR
		ret.__nodeExtendData = {};

		/// #endif
		return ret;
	}
	return p.pop()!;
}

function disposeSpineInstance(o: SpineContent) {
	o.visible = true;
	o.tint = 0xffffff;
	o.state.clearTrack(0);
	o.skeleton.setToSetupPose();
	pool((o as any)._poolName).push(o);
}

type SpineContent = Container & TSpine;


/// #if EDITOR

export const spineAnimationsSelectList = () => {
	let o = game.editor.selection[0] as Spine;
	let ret = o.spineContent!.state.data.skeletonData.animations.map((a) => {
		return { name: a.name, value: a.name };
	});
	return ret;
};

const animationNamePropDesc : EditablePropertyDescRaw = {
	type: 'string',
	visible: (o) => {
		return !!(o as Spine).spineContent;
	},
	disabled: () => {
		return game.editor.selection.length !== 1;
	},
	select: spineAnimationsSelectList
};

const skinNamePropDesc:EditablePropertyDescRaw = {
	type: 'string',
	visible: (o) => {
		return (o as Spine).spineContent?.skeleton.data.skins.length as any;
	},
	disabled: () => {
		return game.editor.selection.length !== 1;
	},
	select: () => {
		let o = game.editor.selection[0] as Spine;
		let ret = o.spineContent!.skeleton.data.skins.map(({ name }) => ({
			name,
			value: name
		}));
		return ret;
	}
};

const filterAssets = (file:FileDesc) => {
	return Lib.resources[file.assetName]?.hasOwnProperty('spineData');
};

/// #endif

const sequencesByNamesCache = new Map() as Map<SpineSequence[], Map<string, SpineSequence>>;

const EMPTY_MAP = new Map();

export default class Spine extends Container implements IGoToLabelConsumer {

	@editable({type: 'btn', name: 'export as PNG...', visible: (o) => !!(o as Spine).spineContent, onClick: () => editorUtils.onExportAsPngClick((game.editor.selection[0] as Spine).spineContent!)})
	_speed = 1;
	spineContent: SpineContent | null = null;
	updateTime = 0;
	_animationIsDirty = false;

	_setImmediately = false;

	_sequencesByNames!: Map<string, SpineSequence>;

	staticView!: Container;

	_goToLabelNextFrame: string | false = false;

	init() {
		super.init();
		this.staticView = this.getChildByName('static-view')!;

		this._goToLabelNextFrame = false;

		this.timeToInitPose = 0;
		this.playingSequence = undefined;

		if (!this._sequencesByNames) {
			this._initSequencesByName();
		}
	}

	private _initSequencesByName() {
		if (this.sequences) {
			if (!sequencesByNamesCache.has(this.sequences)) {
				const names = new Map() as Map<string, SpineSequence>;
				for (const s of this.sequences) {
					names.set(s.n, s);
					for (let i = 0; i < s.s.length; i++) {
						const item = s.s[i];
						item.___next = s.s[i + 1] || s.s[s.l!];
						item.___duration = this.getItemDurationFrames(item)!;
						if (item.actions) {
							for (let i = 0; i < item.actions.length; i++) {
								const action = item.actions[i];
								action.___next = item.actions[i + 1];
							}
						}
					}
				}
				sequencesByNamesCache.set(this.sequences, names);
			}
			this._sequencesByNames = sequencesByNamesCache.get(this.sequences)!;
		} else {
			this._sequencesByNames = EMPTY_MAP;
		}
	}

	getItemDurationFrames(item:SpineSequenceItem) {
		return Math.floor((this._getAnimationDuration(item.n) || 20) / (item.speed || 1));
	}

	_initSpine() {
		assert(!this.spineContent, 'spine content was not disposed released properly.');
		if (this.spineData) {

			/// #if EDITOR
			/*
			/// #endif
			if(!Lib.resources[this.spineData]) {
				this._spineData = null;
				return;
			}
			//*/

			this.updateTime = 0;

			this.spineContent = getSpineInstance(this.spineData);

			/// #if EDITOR
			if (!this.spineContent) {
				return;
			}
			/// #endif
			this.spineContent.state.timeScale = this._speed;
			this._refreshAnimation(true);
			// invalidate transform to apply to spineContent
			(this.spineContent.transform as any)._localID++;
		}
	}

	_refreshAnimation(setImmediately = false) {
		this._animationIsDirty = true;
		this._setImmediately = setImmediately;

		/// #if EDITOR
		if (game.__EDITOR_mode && !this.__isDeserialization) {
			if (this.spineContent) {

				this._applySkin();

				this._applyAnimation();

				this._animationIsDirty = false;
				this.spineContent.update(this.__previewFrame);
			}
		}
		/// #endif
	}
	/// #if EDITOR

	__EDITOR_onCreate() {
		this.spineData = Object.keys(Lib.resources).find((res: any) => Lib.resources[res].spineData)!;
	}

	__beforeDestroy() {
		this._releaseSpine();
	}

	__isDeserialization = false;

	__beforeDeserialization() {
		this.__isDeserialization = true;
	}

	__afterDeserialization() {
		this.tint = this.tint; // eslint-disable-line no-self-assign
		this.__isDeserialization = false;
		this._refreshAnimation();
	}

	/// #endif

	setCurrentAnimation(v:string) {
		this.currentAnimation = v;
	}

	_spineData: string | null = null;

	@editable({ type: 'resource', important: true, filterAssets})
	set spineData(v:string) {
		if (this.spineData !== v) {
			this._releaseSpine();
			this._spineData = v;
			this._initSpine();
		}
	}

	get spineData():string {
		return this._spineData!;
	}

	_currentAnimation: string | null = null;
	@editable(animationNamePropDesc)
	set currentAnimation(v) {
		/// #if DEBUG
		if (v) {
			this.__checkAnimationName(v);
		}
		/// #endif

		if (this._currentAnimation === v) return;

		const isNeedSetInitialAnimation = !this._currentAnimation && this.spineContent;
		this._currentAnimation = v;

		if (isNeedSetInitialAnimation) {
			this._applyAnimation();

			let frame = 0;
			/// #if EDITOR
			if (game.__EDITOR_mode) {
				frame = this.__previewFrame;
			}
			/// #endif

			this.spineContent!.update(frame);
		} else {
			this._refreshAnimation();
		}
	}

	get currentAnimation() {
		return this._currentAnimation;
	}

	setCurrentSkin(v:string) {
		this.currentSkin = v;
	}

	_currentSkin = 'default';

	@editable(skinNamePropDesc)
	set currentSkin(v:string) {
		/// #if DEBUG
		if (v) {
			 this.__checkSkinName(v);
		}
		/// #endif
		if (this._currentSkin !== v) {
			this._currentSkin = v;
			this._refreshAnimation();
		}
	}

	get currentSkin() {
		return this._currentSkin;
	}
	@editable(editorUtils.makePreviewModeButton('Preview ▶', 'components.Trigger#preview-switched'))
	@editable()
	isPlaying = true;

	_loop = true;
	@editable()
	get loop() {
		return this._loop;
	}

	set loop(v) {
		if (this._loop !== v) {
			this._loop = v;
			this._refreshAnimation();
		}
	}

	/// #if EDITOR
	containsPoint(p:Point) {
		let ret = false;
		if (this.spineContent?.visible) {
			this.spineContent.parent = this;
			this.spineContent.forAllChildren((c) => {
				if ((c as Sprite).containsPoint) {
					if (!ret) {
						ret = (c as Sprite).containsPoint(p);
					}
				}
			});
			this.spineContent.parent = null!;
		}
		return ret;
	}

	__sequences!: SpineSequence[];

	@editable({type: 'spine-sequence', name: 'sequences'})
	set sequences(val :SpineSequence[]) {
		this.__sequences = JSON.parse(JSON.stringify(val));
	}

	get sequences(): SpineSequence[] | undefined {
		return this.__isSerialization ? JSON.parse(JSON.stringify(this.__sequences)) : this.__sequences;
	}

	__isSerialization = false;

	__beforeSerialization(): void {
		this.__isSerialization = true;
	}

	__afterSerialization(data: SerializedObject): void {
		this.__isSerialization = false;
		if (this.__nodeExtendData.isPrefabReference) {
			delete data.p.sequences;
		}
	}
	/// #endif

	setLoop(v:boolean) {
		this.loop = v;
	}

	@editable({min: -1, step: 0.01})
	get speed() {
		return this._speed;
	}

	set speed(v) {
		this._speed = v;
		if (this.spineContent) {
			this.spineContent.state.timeScale = v;
		}
	}

	_tint = 0xffffff;

	get tint() {
		return this.useParentTint && this.parent && !isNaN((this.parent as MovieClip).tint as number) ? (this.parent as MovieClip).tint as number : this._tint;
	}

	set tint(v:number) {
		this._tint = v;
		if (this.spineContent) {
			this.spineContent.tint = this.tint;
			this._refreshAnimation();
		}
	}

	_releaseSpine() {
		if (this.spineContent) {
			this.removeChild(this.spineContent);
			if (!this.spinesPooling) {
				this.spineContent.destroy();
			} else {
				disposeSpineInstance(this.spineContent);
			}
			this.spineContent = null;
			this._spineData = null!;
		}
	}

	onRemove() {
		this._releaseSpine();
		super.onRemove();
		this._sequencesByNames = undefined!;
		this._spineData = null;
		this._currentAnimation = null;
		this._currentSkin = null!;
		this.playingSequence = undefined;
		this.playingSequenceItem = undefined;
	}

	play(animationName:string, mixDuration = this.mixDuration) {
		if (!this.spineContent) return;

		if (animationName) {
			this.currentAnimation = animationName;
			const trackEntry = this._applyAnimation();
			trackEntry.mixDuration = mixDuration;
		}
		this.isPlaying = true;
		this.playingSequenceItem = undefined;
		this.timeToInitPose = 0;
	}

	playFromFrame(frame:number, animationName = this._currentAnimation, mixDuration = this.mixDuration) {
		if (!this.spineContent) return;

		if (animationName) {
			this.currentAnimation = animationName;
			this._animationIsDirty = false;
			const trackEntry = this._applyAnimation();
			trackEntry.mixDuration = mixDuration;
			trackEntry.trackTime = frame;
		}
		this.isPlaying = true;
		this.playingSequenceItem = undefined;
		this.timeToInitPose = 0;
	}

	playIfDifferent(animationName:string, mixDuration:number, playIfStopped = true) {
		/// #if DEBUG
		this.__checkAnimationName(animationName);
		/// #endif

		const isSameAnimationPlayed = this.isPlaying && animationName === this.currentAnimation;
		const isStoppedAndCantPlay = !this.isPlaying && !playIfStopped;

		if (isSameAnimationPlayed || isStoppedAndCantPlay) return;

		this.play(animationName, mixDuration);
		this.playingSequenceItem = undefined;
		this.timeToInitPose = 0;
	}

	playIfNot(animationName:string, mixDuration:number, playIfStopped = true, animationNamesRegexp:string) {
		/// #if DEBUG
		this.__checkAnimationName(animationName);
		/// #endif

		if (RegExp(animationNamesRegexp).test(this.currentAnimation!)) return;

		if (!this.isPlaying && !playIfStopped) return;

		this.play(animationName, mixDuration);
		this.playingSequenceItem = undefined;
		this.timeToInitPose = 0;
	}

	timeToInitPose = 0;

	toInitPose(timeFrames: number) {
		if (this._currentAnimation) {
			if (this.timeToInitPose || !this.isPlaying) {
				return;
			}
			this.play(this._currentAnimation!, timeFrames / 60 * 0.0000000001);
			this.speed = 0.0000000001;
			this.timeToInitPose = timeFrames;
		}
	}

	stop(isNeedRefresh = false) {
		if (!this.isPlaying) return;

		this.isPlaying = false;
		if (isNeedRefresh) {
			this._refreshAnimation(true);
		}
		this.timeToInitPose = 0;
		this.playingSequenceItem = undefined;
	}

	stopByName(animationName:string, isNeedRefresh = false) {
		/// #if DEBUG
		this.__checkAnimationName(animationName);
		/// #endif
		if (!this.isPlaying) return;
		if (animationName !== this.currentAnimation) return;
		this.stop(isNeedRefresh);
	}

	_stopIfAllPlayed() {
		/*if (!this.isPlaying || !this.spineContent?.state?.tracks) return;
		const hasPlayingAnimations = this.spineContent.state.tracks.some(
			(track) => track && (track.loop || !track.isComplete())
		);

		if (!hasPlayingAnimations) {
			this.stop();
		}*/ // TODO:
	}

	update() {
		if (this.spineContent) {

			if (this._goToLabelNextFrame) {
				this.playingSequence = this._sequencesByNames.get(this._goToLabelNextFrame)!;
				this._playSequenceItem(this.playingSequence!.s[0]);
				this._goToLabelNextFrame = false;
			}

			let isNeedUpdate = false;

			//this._stopIfAllPlayed(); TODO ?

			if (this.tint !== this.spineContent.tint) {
				this.spineContent.tint = this.tint;
				if (!this.isPlaying) {
					isNeedUpdate = true;
				}
			}

			if (this._animationIsDirty && this._currentAnimation) {
				this._applySkin();

				const trackEntry = this._applyAnimation();
				trackEntry.mixDuration = this._setImmediately ? 0 : this.mixDuration;
				this.updateTime = 0;
				this._animationIsDirty = false;
				this._setImmediately = false;
				if (!this.isPlaying) {
					isNeedUpdate = true;
				}
			}
			if (this.isPlaying) {
				if (this.playingSequenceItem) {
					if (this.sequenceDelayAdd) {
						this.sequenceDelayAdd--;
					} else {
						this.actionsTime++;
						while ((this.nextAction?.t as number) <= this.actionsTime) {
							callByPath(this.nextAction!.a, this);
							if (!this.parent) {
								return;
							}
							this.nextAction = this.nextAction!.___next;
						}
						if (this.sequenceDelay) {
							this.sequenceDelay--;
						} else {
							this.timeToNextItem--;
							if (this.timeToNextItem === 0) {
								if (!this.playingSequenceItem!.___next) {
									this.stop();
									this.actionsTime = 0;
									this.playingSequenceItem = undefined;
								} else {
									this._playSequenceItem(this.playingSequenceItem!.___next);
								}
							}
							this.updateTime += 0.01666666666667;
						}
					}
				} else {
					this.updateTime += 0.01666666666667;
				}
				if (this.timeToInitPose > 0) {
					this.timeToInitPose--;
					if (!this.timeToInitPose) {
						this.isPlaying = false;
						this.stop(false);
					}
				}
			} else if (isNeedUpdate) {
				this.spineContent.update(0);
			}

			if (this.staticView) {
				if (this.isPlaying) {
					this.spineContent.visible = true;
					this.staticView.visible = false;
				} else {
					this.spineContent.visible = false;
					this.staticView.visible = true;
				}
			}
		}

		if (game.isUpdateBeforeRender && this.updateTime > 0) {
			this.spineContent!.update(this.updateTime);
			this.updateTime = 0;
		}
		super.update();
	}


	updateTransform(): void {
		super.updateTransform();
		if (this.spineContent) {
			this.spineContent.parent = this;
			this.spineContent.updateTransform();
			this.spineContent.parent = null!;
		}
	}

	render(renderer: Renderer): void {
		if (this.spineContent?.visible && this.visible) {
			/// #if EDITOR
			this.spineContent.filters = this.filters;
			Spine.__touchedSpines.set(this.spineData, EDITOR_FLAGS.__touchTime);
			/// #endif
			this.spineContent.render(renderer);
		}
		super.render(renderer);
	}

	static __spineLoadingPromise: Promise<true>;

	static _loadSpineRuntime() {
		if (!this.__spineLoadingPromise) {
			game.loadingAdd('pixi-spine/dist/pixi-spine.js');
			this.__spineLoadingPromise = new Promise((resolve) => {
				const s = window.document.createElement('script');
				// pixi-spine loading via script attachment because ES module pixi-spine causes double pixi.js bundling.
				//@ts-ignore
				s.src = game.SPINE_SRC_PATH;
				s.onload = () => {
					game.loadingRemove('pixi-spine/dist/pixi-spine.js');
					/// #if EDITOR
					if (false) {
					/// #endif
						_initSpineParser();
					/// #if EDITOR
					}
					/// #endif

					// fix Mesh+Sequence crash https://github.com/pixijs/spine/pull/560/files
					//@ts-ignore
					const originCreateMesh = window.PIXI.spine.SpineBase.prototype.createMesh as any;
					//@ts-ignore
					window.PIXI.spine.SpineBase.prototype.createMesh = function(slot: ISlot, attachment: IMeshAttachment) {
						if (!attachment.region && attachment.sequence) {
							attachment.sequence.apply(slot, attachment as any);
						}
						return originCreateMesh.call(this, slot, attachment);
					};

					resolve(true);
				};
				s.onerror = () => {
				//@ts-ignore
					game.showLoadingError(s.src);
				};
				document.body.appendChild(s);
			});
			Lib.__parsersLoadingPromises.push(this.__spineLoadingPromise);
		}
		return this.__spineLoadingPromise;
	}

	_applySkin() {
		if (this.currentSkin) {
			/// #if EDITOR
			if (!this.spineContent!.skeleton.data.skins.find((s) => s.name === this.currentSkin)) {
				this._currentSkin = this.spineContent!.skeleton.data.skins[0].name;
				Lib.__invalidateSerializationCache(this);
			}
			/// #endif
			this.spineContent!.skeleton.setSkinByName(this.currentSkin);
		}
	}

	timeToNextItem = -1;
	actionsTime = 0;
	nextAction?: SpineSequenceItemAction;
	playingSequence?: SpineSequence;
	playingSequenceItem?: SpineSequenceItem;
	sequenceDelay = 0;
	sequenceDelayAdd = 0;


	gotoLabel(labelName: string) {
		assert(this.hasLabel(labelName), 'Label \'' + labelName + '\' not found in Spine.', 99999);
		this._goToLabelNextFrame = labelName;
	}

	_playSequenceItem(item?:SpineSequenceItem) {
		if (!item) {
			this.toInitPose(Math.round(this.mixDuration * 60));
		} else {
			this.play(item.n, (item.mixDuration || 0) / 60);
			this.loop = false;
			this.sequenceDelay = item.delay || 0;
			if (item.delayRandom) {
				this.sequenceDelayAdd = Math.floor(Math.random() * item.delayRandom);
			} else {
				this.sequenceDelayAdd = 0;
			}
			this.speed = (item.hasOwnProperty('speed') ? item.speed : 1) as number;
			this.timeToNextItem = item.___duration!;
			if (item.actions) {
				this.nextAction = item.actions[0];
			}
		}
		this.actionsTime = 0;
		this.playingSequenceItem = item;
	}

	hasLabel(labelName: string) {
		if (!this._sequencesByNames) {
			this._initSequencesByName();
		}
		return this._sequencesByNames.has(labelName);
	}

	gotoLabelRecursive(labelName: string): void {
		if (this.hasLabel(labelName)) {
			this.gotoLabel(labelName);
		}
		super.gotoLabelRecursive(labelName);
	}

	_applyAnimation() {
		/// #if EDITOR
		let currentAnimation = this._currentAnimation!;
		if (!currentAnimation || !this.spineContent!.state.data.skeletonData.findAnimation(currentAnimation)) {
			currentAnimation = this.spineContent!.state.data.skeletonData.animations[0].name;
		}
		return this.spineContent!.state.setAnimation(0, currentAnimation, this._loop);
		/// #endif
		return this.spineContent!.state.setAnimation(0, this._currentAnimation!, this._loop); //eslint-disable-line no-unreachable
	}

	static allocatePool(name:string, count:number) {
		if (count > 0) {
			let a = [];
			let i;
			while (count-- > 0) {
				i = getSpineInstance(name);
				i.update(1);
				a.push(i);
			}
			while (a.length > 0) {
				disposeSpineInstance(a.pop()!);
			}
		}
	}

	static clearPool(name = null) {
		if (name) {
			let a = pool(name);
			while (a.length > 0) {
				a.pop()!.destroy();
			}
		} else {
			for (let a of poolMap.values()) {
				while (a.length > 0) {
					a.pop()!.destroy();
				}
			}
			poolMap.clear();
		}
	}

	/// #if DEBUG
	__checkAnimationName(animationName:string) {
		if (game.__EDITOR_mode) {
			return;
		}
		if (!this.spineContent!.skeleton.data.animations.find((a) => a.name == animationName)) {
			assert(false, 'Spine \'' + this.spineData + '\' does not have animation \'' + animationName + '\'', 99999);
		}
	}

	__checkSkinName(skinName:string) {
		if (game.__EDITOR_mode) {
			return;
		}
		if (!this.spineContent!.skeleton.data.skins.find((s) => s.name == skinName)) {
			assert(false, 'Spine \'' + this.spineData + '\' does not have skin \'' + skinName + '\'', 99999);
		}
	}
	/// #endif

	@editable({min: 0, step: 0.01})
	mixDuration = 0.1;

	@editable()
	spinesPooling = true;

	@editable({name: 'tint', basis: 16, type: 'number', default: 0xffffff, max: 0xffffff, min: 0, disabled: (node) => node.useParentTint})

	@editable()
	useParentTint = false;

	_getAnimationDuration(animationName?:string) {
		let anim = this.spineContent?.state.data.skeletonData.animations.find((a) => {
			return a.name === animationName;
		});
		if (anim) {
			return Math.ceil(anim.duration * 60);
		}
	}
	/// #if EDITOR

	static __touchedSpines = new Map() as Map<string, number>;

	@editable({max: 255, min: 0, notSerializable: true, disabled: (node) => node.useParentTint})
	get tintR () {
		return this.tint >> 16;
	}

	set tintR (v) {
		this.tint = (this.tint & 0xffff) | (v << 16);
	}

	@editable({max: 255, min: 0, notSerializable: true, disabled: (node) => node.useParentTint})
	get tintG () {
		return (this.tint & 0xff00) >> 8;
	}

	set tintG (v) {
		this.tint = (this.tint & 0xff00ff) | (v << 8);
	}

	@editable({max: 255, min: 0, notSerializable: true, disabled: (node) => node.useParentTint})
	get tintB () {
		return this.tint & 0xff;
	}

	set tintB (v) {
		this.tint = (this.tint & 0xffff00) | v;
	}

	@editable({type: 'ref'})
	set __duration(_v) {}

	get __duration() {
		return this._getAnimationDuration(this.currentAnimation!);
	}

	___previewFrame = 0;

	set __previewFrame(v) {
		this.___previewFrame = v;
		if (game.__EDITOR_mode && this.spineContent) {
			this._applyAnimation();
			this.spineContent.update(this.__previewFrame);
		}
	}

	__getLabels():undefined | string[] {
		if (this.sequences) {
			return this.sequences.map(s => s.n);
		}
	}

	@editable({min: 0, step: 0.001})
	get __previewFrame() {
		return this.___previewFrame || 0;
	}
	__goToPreviewMode() {
		if (this.spineContent) {
			this._applyAnimation();
			this.spineContent.autoUpdate = true;
		}
	}

	__exitPreviewMode() {
		if (this.spineContent) {
			this.spineContent.autoUpdate = false;
			this._applyAnimation();
			this.spineContent.update(this.__previewFrame);
		}
	}

	static __validateSpineHasAnimation(data:any, animationName:string, fieldName:string): SerializedDataValidationError | undefined {
		if (
			!(Lib.resources[data.spineData].spineData as ISkeletonData).animations.find((a) => a.name == animationName)
		) {
			return {
				message: 'Spine \'' + data.spineData + '\' does not have animation \'' + animationName + '\'',
				findObjectCallback: (o:Container) => {
					if ((o as Spine).spineData === data.spineData) {
						return (o as Spine).currentAnimation === animationName ||
						(o as Spine).sequences?.some(s => s.s.some(i => i.n === animationName));
					}
					return false;
				},
				fieldName,
				errorCode: 99999
			};
		}

	}

	static __validateObjectData(data:SerializedObjectProps):SerializedDataValidationError | undefined {
		if (data.spineData) {
			if (!Lib.resources[data.spineData]) {
				return {
					message: 'Spine resource is not found: \'' + data.spineData + '\'',
					findObjectCallback: (o:Container) => {
						return (o as Spine).spineData === data.spineData;
					},
					fieldName: 'spineData',
					errorCode: 99999
				};
			} else {
				if (data.currentAnimation) {
					let ret = this.__validateSpineHasAnimation(data, data.currentAnimation, 'currentAnimation');
					if (!ret) {
						if (data.sequences) {
							const sequences = data.sequences as SpineSequence[];
							sequences.forEach((sequence, sequenceId) => {
								sequence.s.forEach((item, itemId) => {
									if (!ret) {
										ret = this.__validateSpineHasAnimation(data, item.n, 'sequences,' + sequenceId + ',' + itemId);

										if (!ret && item.actions) {
											item.actions.forEach((action, actionId) => {
												if (!action.a && !ret) {
													ret = {
														message: 'Spine sequence action has empty callback path. Please delete the action or set the callback path.',
														findObjectCallback: (o:Container) => {
															if ((o as Spine).spineData === data.spineData) {
																return (o as Spine).sequences?.some(s => s.s.some(i => i.actions?.some(a => !a.a)));
															}
															return false;
														},
														fieldName: 'sequences,' + sequenceId + ',' + itemId + ',' + actionId,
														errorCode: 99999
													};
												}
											});
										}
									}
								});
							});
						}
					}
					return ret;
				}
				if (
					data.currentSkin &&
					!Lib.resources[data.spineData].spineData.skins.find((a: any) => a.name == data.currentSkin)
				) {
					return {
						message: 'Spine \'' + data.spineData + '\' does not have skin \'' + data.currentSkin + '\'',
						findObjectCallback: (o) => {
							return (o as Spine).spineData === data.spineData && (o as Spine).currentSkin == data.currentSkin;
						},
						fieldName: 'currentSkin',
						errorCode: 99999
					};
				}
			}
		}
	}

	/// #endif
}

Spine._loadSpineRuntime();

/// #if EDITOR
editorEvents.on('playToggle', Spine.clearPool);

Spine.__EDITOR_icon = 'tree/spine';
(Spine.prototype.toInitPose as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spine.prototype.play as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spine.prototype.stop as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spine.prototype.setCurrentAnimation as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spine.prototype.setCurrentAnimation as SelectableProperty).___EDITOR_callbackParameterChooserFunction = (context: Spine) => {
	const spineContent = context.spineContent;
	const list = spineContent!.skeleton.data.animations.map((a) => ({
		name: a.name
	}));
	return game.editor.ui.modal.showListChoose('Choose spine skin', list).then((choose) => (choose ? choose.name : null));
};
(Spine.prototype.toInitPose as SelectableProperty).___EDITOR_actionIcon = ACTION_ICON_STOP;

(Spine.prototype.setCurrentSkin as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Spine.prototype.setCurrentSkin as SelectableProperty).___EDITOR_callbackParameterChooserFunction = (context: Spine) => {
	const spineContent = context.spineContent;
	if (!context.spineContent || !context.spineContent.skeleton.data.skins) {
		return Promise.resolve('enterSkinNameHere');
	}

	const list = spineContent!.skeleton.data.skins.map((skin) => ({
		name: skin.name
	}));
	return game.editor.ui.modal.showListChoose('Choose spine skin', list).then((choose) => (choose ? choose.name : null));
};

export interface SpineSequenceItemAction {
	/** call-back action */
	a: CallBackPath;
	/** time */
	t: number;

	___next?: SpineSequenceItemAction;
}

export interface SpineSequenceItem {
	/** name */
	n: string;
	mixDuration?: number;
	delay?: number;
	delayRandom?: number;
	speed?: number;
	actions?: SpineSequenceItemAction[]; // TODO: add actions (callbacks) editor

	/** runtime next item reference */
	___next?: SpineSequenceItem;
	/** runtime duration */
	___duration?: number;
}

export interface SpineSequence {
	/** name */
	n: string;
	/** sequences */
	s: SpineSequenceItem[];
	/** loop sequence index */
	l?: number;
	___activeItemName?: string;
	___activeActionId?: number;
}

decorateGotoLabelMethods(Spine);
/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/trigger.c.ts">
import { Container } from 'pixi.js';
import editable from 'thing-editor/src/editor/props-editor/editable';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import getValueByPath from 'thing-editor/src/engine/utils/get-value-by-path';

/// #if EDITOR

const KEEP_VISIBLE__EDITABLE_PROPERTY_DESC = {
	afterEdited: () => {
		let o = game.editor.selection[0] as Trigger;
		if (!o.__keepVisibleInEditor) {
			o.visible = false;
		}
	}
};

const VISIBLE_PROPERTY_DESC = {
	name: 'visible',
	type: 'boolean',
	override: true,
	afterEdited: (val:boolean) => {
		let o = game.editor.selection[0] as Trigger;
		if (!val) {
			o.__keepVisibleInEditor = false;
		}
	}
} as EditablePropertyDescRaw;
/// #endif


export default class Trigger extends Container {

	initialAlpha = 1;
	initialScale = 1;
	initialX = 0;
	initialY = 0;

	triggering = false;
	_processedState: any = undefined;
	lastUpdateTime = 0;

	/// #if EDITOR
	@editable(VISIBLE_PROPERTY_DESC)
	__visibleInEditor?: boolean;

	/// #endif
	@editable({ type: 'btn', title: 'Centralize to content', name: 'Centralize', onClick: editorUtils.centralizeObjectToContent })

	_state = false;
	@editable({ disabled: o => o.dataPath as unknown as boolean })
	set state(val) {
		if (val) {
			this.show();
		} else {
			this.hide();
		}
	}

	get state() {
		return this._state;
	}

	@editable({ type: 'data-path', important: true })
	dataPath = null;

	@editable()
	invert = false;

	@editable({ step: 0.001, min: 0.001, max: 1, tip: 'Speed of switching animation. Set it to <b>1.0</b> for instant switching.' })
	@editable({ name: 'Animation preset', type: 'pow-damp-preset', notSerializable: true, separator: true })
	pow = 0.02;


	@editable({ step: 0.001, min: 0.001, max: 0.999, tip: 'Resistance for switching animation.' })
	damp = 0.85;

	@editable({ step: 0.01, min: -1, max: 0, separator: true })
	alphaShift = -1;

	@editable({ step: 0.01, min: -1 })
	scaleShift = 0;

	@editable()
	xShift = 0;

	@editable()
	yShift = 0;

	@editable()
	isApplyInteractivity = true;

	@editable({ type: 'callback', separator: true })
	@editable(editorUtils.makePreviewModeButton('Preview switched', 'components.Trigger#preview-switched'))
	onEnable: string | null = null;

	@editable({ type: 'callback' })
	onDisable: string | null = null;

	/// #if EDITOR
	@editable(KEEP_VISIBLE__EDITABLE_PROPERTY_DESC)
	__keepVisibleInEditor = false;
	/// #endif

	/** current soft switching state */
	q = 0;
	qSpeed = 0;

	/// #if EDITOR
	constructor() {
		super();
		this.__exitPreviewMode = this.__exitPreviewMode.bind(this);
	}
	/// #endif

	init() {
		super.init();
		this.initialAlpha = this.alpha;
		this.initialScale = this.scale.x;
		this.initialX = this.x;
		this.initialY = this.y;
		this.qSpeed = 0;
		this.triggering = false;
		this._processedState = undefined;
		if (!this.dataPath) {
			this.invert = this.state;
		}
		this.applyInstantly();
		this.lastUpdateTime = game.time;
	}

	getState() {
		return !!this.invert === (!getValueByPath(this.dataPath!, this));
	}

	applyInstantly() {
		assert(!game.__EDITOR_mode, 'applyInstantly could not be called in editor mode', 10024);
		if (this.dataPath) {
			this._state = this.getState();
		} else {
			this._state = !!this.invert;
		}
		if (this._state) {
			this.q = 0;
		} else {
			this.q = 1;
		}
		this.qSpeed = 0;
		this.updatePhase();
		this.interactiveChildren = this._state || (!this.isApplyInteractivity);
	}

	show() {
		this._state = true;
		this.interactiveChildren = true;
		this.triggering = true;
		if (!this.dataPath) {
			this.invert = true;
		}
	}


	hide() {
		this._state = false;
		if (this.isApplyInteractivity) {
			this.interactiveChildren = false;
		}
		this.triggering = true;
		if (!this.dataPath) {
			this.invert = false;
		}
		this.forAllChildren(processOnDisable);
	}

	toggle() {
		if (this._state) {
			this.hide();
		} else {
			this.show();
		}
	}

	updatePhase() {
		let qTo = this._state ? 0 : 1;
		if ((this.pow === 1) || ((Math.abs(qTo - this.q) < 0.002) && (Math.abs(this.qSpeed) < 0.002))) {
			this.triggering = false;
			this.q = qTo;
		} else {
			this.qSpeed += (qTo - this.q) * this.pow;
			this.qSpeed *= this.damp;
			this.q += this.qSpeed;
		}

		this.alpha = this.initialAlpha + this.q * this.alphaShift;

		if (this.scaleShift !== 0) {
			let s = this.initialScale + this.q * this.scaleShift;
			this.scale.x = s;
			this.scale.y = s;
		}
		this.visible = (this.alpha > 0.015) && (Math.abs(this.scale.x) > 0.0015);
		if (!this.visible && !this._state && ((this.initialAlpha + this.alphaShift) <= 0.015)) {
			this.triggering = false;
			this.q = qTo;
		}

		if (this.xShift !== 0) {
			this.x = this.initialX + this.q * this.xShift;
		}
		if (this.yShift !== 0) {
			this.y = this.initialY + this.q * this.yShift;
		}
	}

	update() {
		if (this.dataPath) {
			let s = this.getState();
			if (this._state !== s) {
				this.toggle();
			}
		}
		if (this.triggering) {
			this.updatePhase();
			if (!this._state && ((game.time - this.lastUpdateTime) > 1)) {
				this.applyInstantly();
			}
		}
		if (this.visible) {
			super.update();
		}
		if (this._processedState !== this._state) {
			this._processedState = this._state;
			if (this._processedState) {
				if (this.onEnable) {
					callByPath(this.onEnable, this);
				}
			} else {
				if (this.onDisable) {
					callByPath(this.onDisable, this);
				}
			}
		}
		this.lastUpdateTime = game.time;
	}
	/// #if EDITOR

	__EDITOR_onCreate() {
		window.setTimeout(() => {
			editorUtils.centralizeObjectToContent(this);
		}, 0);
	}

	//@ts-ignore
	set 'scale.x'(v) {
		//@ts-ignore
		super['scale.x'] = v;
		//@ts-ignore
		super['scale.y'] = v;
	}

	get 'scale.x'() {
		//@ts-ignore
		return super['scale.x'];
	}

	//@ts-ignore
	set 'scale.y'(v) {
		//@ts-ignore
		super['scale.x'] = v;
		//@ts-ignore
		super['scale.y'] = v;
	}

	get 'scale.y'() {
		//@ts-ignore
		return super['scale.x'];
	}

	__checkInteractionWarning() {
		if (this.isApplyInteractivity && (this.alphaShift === 0) && ((this.scaleShift + this.scale.x) !== 0)) {
			game.editor.ui.status.warn('Trigger disables interaction without alpha or scale effect. If you want to keep object clickable uncheck \'isApplyInteractivity\' property of trigger', 32030, this);
		}
	}

	__visibleInEditorSave? = false;

	__beforeSerialization() {
		if (this.__visibleInEditor) {
			this.__visibleInEditorSave = this.__visibleInEditor;
		}
		delete this.__visibleInEditor;
		this.__checkInteractionWarning();
	}

	__afterSerialization(serializedData: SerializedObject) {
		if (this.dataPath) {
			delete serializedData.p.state;
		}
		if (this.__visibleInEditorSave) {
			this.__visibleInEditor = this.__visibleInEditorSave;
			delete this.__visibleInEditorSave;
		}
	}

	__afterDeserialization() {
		this.__checkInteractionWarning();
	}

	__goToPreviewMode() {
		this.initialAlpha = this.alpha;
		this.initialScale = this.scale.x;
		this.initialX = this.x;
		this.initialY = this.y;

		this.alpha += this.alphaShift;
		this['scale.x'] += this.scaleShift;
		this.x += this.xShift;
		this.y += this.yShift;

	}

	__exitPreviewMode() {
		this.alpha = this.initialAlpha;
		this['scale.x'] = this.initialScale;
		this.x = this.initialX;
		this.y = this.initialY;
	}

	__onSelect() {
		super.__onSelect();
		this.__onChildSelected();
	}

	__onChildSelected() {
		if (!this._visible && game.__EDITOR_mode) {
			this.__visibleInEditor = true;
			if (visibleEnabledTriggers.indexOf(this) < 0) {
				visibleEnabledTriggers.push(this);
			}
		}
	}

	_visible = true;

	//@ts-ignore
	get visible(): boolean {
		return this._visible || (!game.editor.disableFieldsCache && (this.__visibleInEditor || ((this.__keepVisibleInEditor || game.editor.makeVisibleAll) && game.__EDITOR_mode)));
	}

	set visible(v: boolean) {
		delete this.__visibleInEditor;
		this._visible = v;
	}

	/// #endif
}

const processOnDisable = (o: Container) => {
	if (o._onDisableByTrigger) {
		o._onDisableByTrigger();
	}
};

/// #if EDITOR


(Trigger.prototype.show as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Trigger.prototype.hide as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(Trigger.prototype.toggle as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

Trigger.__EDITOR_icon = 'tree/trigger';

Trigger.__EDITOR_tip = `<b>Trigger</b> - is component which smoothly or instantly <b>switches</b> it's <b>visibility</b> or/and <b>position</b> accordingly of value of specified javaScript variable.
If trigger become invisible because of alpha=0 or scale.x=0 or scale.y=0 it <b>stops</b> to <b>update</b> its children.`;


let visibleEnabledTriggers: Trigger[] = [];
window.setInterval(() => {
	for (let i = visibleEnabledTriggers.length - 1; i >= 0; i--) {
		let t = visibleEnabledTriggers[i];
		if (!t.__isAnyChildSelected()) {
			delete t.__visibleInEditor;
			visibleEnabledTriggers.splice(i, 1);
		}
	}
}, 1000);

/// #endif
</file>

<file path="src/engine/lib/assets/src/extended/unpausable-container.c.ts">
import game from 'thing-editor/src/engine/game';
import Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';

export default class UnPausableContainer extends Container {

	started = 0;

	init() {
		this.started = window.setInterval(() => {
			if (game.__paused) {
				if (this.worldVisible && this.worldAlpha) {
					super.update();
				}
			}
		}, 1000 / 60);
		super.init();
	}

	update(): void {
		super.update();
	}

	onRemove() {
		clearInterval(this.started);
		super.onRemove();
	}
}
</file>

<file path="src/engine/lib/assets/src/mobile/orientation-trigger.c.ts">
import editable from 'thing-editor/src/editor/props-editor/editable';
import { StatusClearingCondition } from 'thing-editor/src/editor/ui/status-clearing-condition';
import { editorUtils } from 'thing-editor/src/editor/utils/editor-utils';
import { roundUpNumber } from 'thing-editor/src/editor/utils/round-up-point';
import game from 'thing-editor/src/engine/game';
import Container from 'thing-editor/src/engine/lib/assets/src/basic/container.c';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';

const propDisabler = (_o: OrientationTrigger) => { return true; };

/// #if EDITOR
let IGNORE_DIRECT_PROPS = false;
/// #endif

export default class OrientationTrigger extends Container {

	__currentOrientationIsPortrait = false;

	/// #if EDITOR

	_alpha = 1;

	__onPortrait: string | null = null;
	__onLandscape: string | null = null;

	@editable({ type: 'callback' })
	set onPortrait(val: string | null) {
		this.__onPortrait = val;
		if (!IGNORE_DIRECT_PROPS) {
			this.__callIfValueByPathSetter(this.__onPortrait);
			if (!this.getTriggerConditionState()) {
				const extendData = this.__nodeExtendData;
				window.setTimeout(() => {
					if (extendData === this.__nodeExtendData) {
						this.__callIfValueByPathSetter(this.__onLandscape);
					}
				}, 600);
			}
		}
	}
	get onPortrait(): string | null {
		return this.__onPortrait;
	}

	@editable({ type: 'callback' })
	set onLandscape(val: string | null) {
		this.__onLandscape = val;
		if (!IGNORE_DIRECT_PROPS) {
			this.__callIfValueByPathSetter(this.__onLandscape);
			if (this.getTriggerConditionState()) {
				const extendData = this.__nodeExtendData;
				window.setTimeout(() => {
					if (extendData === this.__nodeExtendData) {
						this.__callIfValueByPathSetter(this.__onPortrait);
					}
				}, 600);
			}
		}
	}
	get onLandscape(): string | null {
		return this.__onLandscape;
	}

	@editable()
	__callInEditorMode = false;

	@editable({ type: 'btn', title: 'Centralize to content', name: 'Centralize', onClick: editorUtils.centralizeObjectToContent })

	/*
	/// #endif
	onPortrait:string | null = null;
	onLandscape:string | null = null;
	//*/

	@editable({ disabled: propDisabler })
	landscapeX = 0;
	@editable({ disabled: propDisabler })
	landscapeY = 0;
	@editable({ disabled: propDisabler })
	landscapeScaleX = 0;
	@editable({ disabled: propDisabler })
	landscapeScaleY = 0;
	@editable({ disabled: propDisabler })
	landscapeAlpha = 0;
	@editable({ disabled: propDisabler })
	landscapeR = 0;

	@editable({ disabled: propDisabler })
	portraitX = 0;
	@editable({ disabled: propDisabler })
	portraitY = 0;
	@editable({ disabled: propDisabler })
	portraitScaleX = 0;
	@editable({ disabled: propDisabler })
	portraitScaleY = 0;
	@editable({ disabled: propDisabler })
	portraitAlpha = 0;
	@editable({ disabled: propDisabler })
	portraitR = 0;


	init() {
		super.init();
		this.applyOrientation();
	}

	getTriggerConditionState() {
		return game.isPortrait;
	}

	applyOrientation() {
		this.__currentOrientationIsPortrait = this.getTriggerConditionState();
		if (this.__currentOrientationIsPortrait) {
			this.x = this.portraitX;
			this.y = this.portraitY;
			this['scale.x'] = this.portraitScaleX;
			this['scale.y'] = this.portraitScaleY;
			this.alpha = this.portraitAlpha;
			this.rotation = this.portraitR;
			this._callHandler(this.onPortrait
				/// #if EDITOR
				, 'onPortrait'
				/// #endif
			);
		} else {
			this.x = this.landscapeX;
			this.y = this.landscapeY;
			this['scale.x'] = this.landscapeScaleX;
			this['scale.y'] = this.landscapeScaleY;
			this.alpha = this.landscapeAlpha;
			this.rotation = this.landscapeR;
			this._callHandler(this.onLandscape
				/// #if EDITOR
				, 'onLandscape'
				/// #endif
			);
		}
	}

	_callHandler(handler: string | null
		/// #if EDITOR
		, handlerName: string
		/// #endif
	) {

		this.visible = (this.alpha > 0.015) && (Math.abs(this.scale.x) > 0.0015) && (Math.abs(this.scale.y) > 0.0015);

		/// #if EDITOR
		if (handler) {
			let h = handler.split(',')[0];
			if (h === 'this.update') {
				game.editor.ui.status.warn('OrientationTrigger`s "' + handlerName + '" handler has value "this.update", but only "this.parent.update" is possible, and if OrientationTrigger is last children only.', 10071, this, handlerName, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
				return;
			}
			else if (h === 'this.parent.update' && this.parent.children.indexOf(this) < (this.parent.children.length - 1)) {
				game.editor.ui.status.warn('OrientationTrigger`s "' + handlerName + '" handler has value "this.parent.update", but it is not last children of parent. Please move this OrientationTrigger to the end of the list.', 10072, this, handlerName, undefined, undefined, StatusClearingCondition.LAUNCH_GAME);
				return;
			}
		}
		/// #endif
		if (handler
			/// #if EDITOR
			&& (!game.__EDITOR_mode || handler.startsWith('setValueByPath`') || this.__callInEditorMode)
			/// #endif
		) {
			callByPath(handler, this);
		}
	}

	update() {
		if (this.visible) {
			super.update();
		}
	}

	_onRenderResize() {
		if (this.__currentOrientationIsPortrait !== game.isPortrait // eslint-disable-line no-constant-condition
			/// #if EDITOR
			|| true
			/// #endif

		) {
			this.applyOrientation();
		}
	}

	/// #if EDITOR

	__callIfValueByPathSetter(path: string | null) {
		if (path && path.startsWith('setValueByPath`')) {
			try {
				callByPath(path, this);
			} catch (er) {
				console.error(er);
			}
		}
	}

	__EDITOR_onCreate() {
		this.__checkWarnings();
		window.setTimeout(() => {
			if (this.getTriggerConditionState()) {
				this.landscapeX = this.portraitX;
				this.landscapeY = this.portraitY;
				this.landscapeScaleX = this.portraitScaleX;
				this.landscapeScaleY = this.portraitScaleY;
				this.landscapeAlpha = this.portraitAlpha;
				this.landscapeR = this.portraitR;
			} else {
				this.portraitX = this.landscapeX;
				this.portraitY = this.landscapeY;
				this.portraitScaleX = this.landscapeScaleX;
				this.portraitScaleY = this.landscapeScaleY;
				this.portraitAlpha = this.landscapeAlpha;
				this.portraitR = this.landscapeR;
			}
			editorUtils.centralizeObjectToContent(this);
		}, 0);
	}

	//@ts-ignore
	set alpha(v) {
		this._alpha = v;
		if (IGNORE_DIRECT_PROPS) return;
		if (this.getTriggerConditionState()) {
			this.portraitAlpha = v;
		} else {
			this.landscapeAlpha = v;
		}
	}

	get alpha() {
		if (IGNORE_DIRECT_PROPS) return this._alpha;
		if (this.getTriggerConditionState()) {
			return this._alpha = isNaN(this.portraitAlpha) ? 1 : this.portraitAlpha;
		} else {
			return this._alpha = isNaN(this.landscapeAlpha) ? 1 : this.landscapeAlpha;
		}
	}

	set x(v) {
		super.x = v;
		if (IGNORE_DIRECT_PROPS) return;
		if (this.getTriggerConditionState()) {
			this.portraitX = v;
		} else {
			this.landscapeX = v;
		}
	}

	get x() {
		if (IGNORE_DIRECT_PROPS) return super.x;
		if (this.getTriggerConditionState()) {
			return super.x = isNaN(this.portraitX) ? 0 : this.portraitX;
		} else {
			return super.x = isNaN(this.landscapeX) ? 0 : this.landscapeX;
		}
	}

	set rotation(v) {
		super.rotation = v;
		if (IGNORE_DIRECT_PROPS) return;
		if (this.getTriggerConditionState()) {
			this.portraitR = v;
		} else {
			this.landscapeR = v;
		}
	}

	get rotation() {
		if (IGNORE_DIRECT_PROPS) return super.rotation;
		if (this.getTriggerConditionState()) {
			return super.rotation = isNaN(this.portraitR) ? 0 : this.portraitR;
		} else {
			return super.rotation = isNaN(this.landscapeR) ? 0 : this.landscapeR;
		}
	}

	set y(v) {
		super.y = v;
		if (IGNORE_DIRECT_PROPS) return;
		if (this.getTriggerConditionState()) {
			this.portraitY = v;
		} else {
			this.landscapeY = v;
		}
	}

	get y() {
		if (IGNORE_DIRECT_PROPS) return super.y;
		if (this.getTriggerConditionState()) {
			return super.y = isNaN(this.portraitY) ? 0 : this.portraitY;
		} else {
			return super.y = isNaN(this.landscapeY) ? 0 : this.landscapeY;
		}
	}
	//@ts-ignore
	set 'scale.x'(v) {
		//@ts-ignore
		super['scale.x'] = v;
		if (IGNORE_DIRECT_PROPS) return;
		if (this.getTriggerConditionState()) {
			this.portraitScaleX = v;
		} else {
			this.landscapeScaleX = v;
		}
	}

	get 'scale.x'() {
		//@ts-ignore
		if (IGNORE_DIRECT_PROPS) return super['scale.x'];
		if (this.getTriggerConditionState()) {
			return super.scale.x = isNaN(this.portraitScaleX) ? 0 : this.portraitScaleX;
		} else {
			return super.scale.x = isNaN(this.landscapeScaleX) ? 0 : this.landscapeScaleX;
		}
	}
	//@ts-ignore
	set 'scale.y'(v) {
		//@ts-ignore
		super['scale.y'] = v;
		if (IGNORE_DIRECT_PROPS) return;
		if (this.getTriggerConditionState()) {
			this.portraitScaleY = v;
		} else {
			this.landscapeScaleY = v;
		}
	}

	get 'scale.y'() {
		//@ts-ignore
		if (IGNORE_DIRECT_PROPS) return super['scale.y'];
		if (this.getTriggerConditionState()) {
			return super.scale.y = isNaN(this.portraitScaleY) ? 0 : this.portraitScaleY;
		} else {
			return super.scale.y = isNaN(this.landscapeScaleY) ? 0 : this.landscapeScaleY;
		}
	}

	__beforeSerialization() {
		IGNORE_DIRECT_PROPS = true;
		if (!this.__nodeExtendData.isTypeChanging) {
			this.x = 0;
			this.y = 0;
			this.rotation = 0;
			this.alpha = 1;
			this.scale.x = 1;
			this.scale.y = 1;
			this.portraitX = roundUpNumber(this.portraitX);
			this.portraitY = roundUpNumber(this.portraitY);
			this.landscapeX = roundUpNumber(this.landscapeX);
			this.landscapeY = roundUpNumber(this.landscapeY);
		}
	}

	__afterSerialization() {
		IGNORE_DIRECT_PROPS = false;
		this.applyOrientation();
	}

	__beforeDeserialization() {
		IGNORE_DIRECT_PROPS = true;
	}

	__checkWarnings() {
		if (game.projectDesc.screenOrientation !== 'auto') {
			game.editor.ui.status.warn('Orientation trigger is not useful if projects screenOrientation is not set to \'auto\'', 32023, this);
		}
	}

	__afterDeserialization() {
		IGNORE_DIRECT_PROPS = false;
		if (game.__EDITOR_mode) {
			this.applyOrientation();
		}
	}

	__shiftObject(dx: number, dy: number) {
		super.x += dx;
		super.y += dy;
		this.landscapeX += dx;
		this.portraitX += dx;
		this.landscapeY += dy;
		this.portraitY += dy;
	}

	static __beforeChangeToThisType(_o: Container) {
		const o = _o as OrientationTrigger;
		if (isNaN(o.landscapeX) || isNaN(o.landscapeY) ||
			isNaN(o.landscapeScaleX) || isNaN(o.landscapeScaleY) ||
			isNaN(o.landscapeAlpha) || isNaN(o.landscapeR)) {
			o.landscapeX = o.portraitX = o.x;
			o.landscapeY = o.portraitY = o.y;
			o.landscapeScaleX = o.portraitScaleX = o['scale.x'];
			o.landscapeScaleY = o.portraitScaleY = o['scale.y'];
			o.landscapeAlpha = o.portraitAlpha = o.alpha;
			o.landscapeR = o.portraitR = o.rotation;
		}
	}

	/// #endif

}

/// #if EDITOR
OrientationTrigger.__EDITOR_icon = 'tree/orientation-trigger';

/// #endif
</file>

<file path="src/engine/lib/assets/src/utils/format-money.ts">
import assert from 'thing-editor/src/engine/debug/assert';

function formatMoney(num: number, c = 0) {
	assert(typeof num === 'number', 'Numeric value expected, but got \'' + typeof num + '\'', 10012);

	let neg = num < 0;
	let ret;
	if (neg) {
		num = -num;
	}

	if (c > 0) {
		let str = num.toFixed(c).split('.');
		if (str[0].length > 3) {
			str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');
		}
		ret = str.join('.');
	} else {
		ret = num.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');
	}
	if (neg) {
		return '-' + ret;
	}
	return ret;
}

export default formatMoney;
</file>

<file path="src/engine/lib/assets/src/utils/wait-for-condition.ts">
const waitForCondition = (condition: () => any) => {
	if (condition()) {
		return Promise.resolve();
	}
	return new Promise((resolve) => {
		let i = window.setInterval(() => {
			if (condition()) {
				resolve(undefined);
				clearInterval(i);
			}
		}, 100);
	});
};

export default waitForCondition;
</file>

<file path="src/engine/lib/assets/ui/sure-question.p.json">
{
	"c": "Resizer",
	"p": {
		"name": "ui/sure-question",
		"__prefabPivot": "left-top",
		"relativeX": true,
		"xPos": 0.5,
		"relativeY": true,
		"yPos": 0.5
	},
	":": [
		{
			"c": "MovieClip",
			"p": {
				"name": "backdrop",
				"timeline": {
					"l": {},
					"p": 0.02,
					"d": 0.85,
					"f": [
						{
							"n": "alpha",
							"t": [
								{
									"v": 0,
									"t": 0,
									"m": 1
								},
								{
									"v": 1,
									"t": 7,
									"m": 1
								}
							]
						}
					]
				},
				"__previewFrame": 4
			},
			":": [
				{
					"c": "Button",
					"p": {
						"name": "easyCloseBtn",
						"alpha": 0.7000000000000001,
						"tint": 40,
						"disabledAlpha": 1,
						"hotkey": 27,
						"sndClick": "click",
						"sndOver": "over"
					},
					":": [
						{
							"c": "BackDrop",
							"p": {
								"alpha": 0.65,
								"shapeFillColor": 131597
							}
						}
					]
				}
			]
		},
		{
			"c": "MovieClip",
			"p": {
				"name": "main",
				"tint": 0,
				"timeline": {
					"l": {},
					"p": 0.157,
					"d": 0.44,
					"f": [
						{
							"n": "scale.x",
							"t": [
								{
									"v": 0,
									"t": 0
								},
								{
									"v": 1,
									"t": 12
								},
								{
									"v": 1,
									"t": 16,
									"m": 1
								}
							]
						},
						{
							"n": "scale.y",
							"t": [
								{
									"v": 0,
									"t": 0
								},
								{
									"v": 1,
									"t": 12
								},
								{
									"v": 1,
									"t": 16,
									"m": 1
								}
							]
						}
					]
				},
				"__previewFrame": 8
			},
			":": [
				{
					"c": "IsMobileTrigger",
					"p": {
						"name": "popup-body",
						"landscapeScaleX": 1,
						"landscapeScaleY": 1,
						"landscapeAlpha": 1,
						"portraitScaleX": 1.7,
						"portraitScaleY": 1.7,
						"portraitAlpha": 1
					},
					":": [
						{
							"c": "Shape",
							"p": {
								"x": -330,
								"y": -208,
								"interactive": true,
								"shape": 1,
								"width": 660,
								"height": 317,
								"shapeRadius": 282,
								"shapeFillColor": 2
							}
						},
						{
							"c": "Text",
							"p": {
								"name": "title",
								"y": -168,
								"alpha": 0.8,
								"text": "TITLE",
								"style.fontSize": 34,
								"style.fontWeight": "bold",
								"maxWidth": 507
							}
						},
						{
							"c": "MultilineText",
							"p": {
								"name": "message",
								"y": -67,
								"alpha": 0.7,
								"text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
								"style.fontSize": 28,
								"maxWidthLandscape": 508,
								"maxWidthPortrait": 508,
								"maxHeightLandscape": 168,
								"maxHeightPortrait": 168
							}
						},
						{
							"c": "Button",
							"p": {
								"name": "okBtn",
								"x": 100,
								"y": 60,
								"scale.x": 0.666666,
								"scale.y": 0.666666,
								"hoverImage": "EMPTY",
								"pressImage": "EMPTY",
								"sndClick": "click",
								"sndOver": "over"
							},
							":": [
								{
									"c": "Shape",
									"p": {
										"x": -140,
										"y": -33,
										"shape": 1,
										"width": 280,
										"height": 66,
										"shapeRadius": 2533,
										"shapeFillColor": 2039583
									}
								},
								{
									"c": "Trigger",
									"p": {
										"name": "hover",
										"dataPath": "this.parent.isOvered",
										"pow": 1,
										"damp": 0,
										"isApplyInteractivity": false,
										"onEnable": "",
										"onDisable": ""
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"name": "hover",
												"x": -140,
												"y": -33,
												"alpha": 0.1,
												"shape": 1,
												"width": 280,
												"height": 66,
												"shapeRadius": 2533,
												"shapeFillColor": 16776960
											}
										}
									]
								},
								{
									"c": "Text",
									"p": {
										"name": "label",
										"text": "Ok",
										"style.fontSize": 45,
										"maxWidth": 233
									}
								}
							]
						},
						{
							"c": "Button",
							"p": {
								"name": "noBtn",
								"x": -100,
								"y": 60,
								"scale.x": 0.666666,
								"scale.y": 0.666666,
								"hoverImage": "EMPTY",
								"pressImage": "EMPTY",
								"sndClick": "click",
								"sndOver": "over"
							},
							":": [
								{
									"c": "Shape",
									"p": {
										"x": -140,
										"y": -33,
										"shape": 1,
										"width": 280,
										"height": 66,
										"shapeRadius": 2533,
										"shapeFillColor": 2039583
									}
								},
								{
									"c": "Trigger",
									"p": {
										"name": "hover",
										"dataPath": "this.parent.isOvered",
										"pow": 1,
										"damp": 0,
										"isApplyInteractivity": false,
										"onEnable": "",
										"onDisable": ""
									},
									":": [
										{
											"c": "Shape",
											"p": {
												"name": "hover",
												"x": -140,
												"y": -33,
												"alpha": 0.1,
												"shape": 1,
												"width": 280,
												"height": 66,
												"shapeRadius": 2533,
												"shapeFillColor": 16776960
											}
										}
									]
								},
								{
									"c": "Text",
									"p": {
										"name": "label",
										"text": "--",
										"style.fontSize": 45,
										"maxWidth": 163
									}
								}
							]
						}
					]
				}
			]
		}
	]
}
</file>

<file path="src/engine/lib/schema-thing-project.json">
{
	"$schema": "http://json-schema.org/draft-04/schema#",
	"type": "object",
	"properties": {
		"title": {
			"description": "title visible in project list",
			"type": "string",
			"default": "my-project"
		},
		"id": {
			"description": "unique project id used to store local settings",
			"type": "string",
			"default": "my-project.my-website.com"
		},
		"mainScene": {
			"description": "default scene name for game.showScene method",
			"type": "string",
			"default": "main"
		},
		"icon": {
			"description": "path to the image file - which will be displayed as an project`s icon in projects list.",
			"type": "string",
			"default": "assets/bunny.png"
		},
		"__group": {
			"description": "groups projects in the projects list",
			"type": "string",
			"default": "my-projects/cool-projects"
		},
		"screenOrientation": {
			"description": "projects screen orientation",
			"type": "string",
			"enum": [
				"landscape",
				"portrait",
				"auto"
			],
			"default": "landscape"
		},
		"width": {
			"description": "landscape width of project screen",
			"type": "number",
			"default": 1280
		},
		"height": {
			"description": "landscape height of project screen",
			"type": "number",
			"default": 720
		},
		"portraitWidth": {
			"description": "width of project in portrait mode",
			"type": "number",
			"default": 720
		},
		"portraitHeight": {
			"description": "height of project in portrait mode",
			"type": "number",
			"default": 1280
		},
		"renderResolution": {
			"description": "increases quality of render on desktop in cost of performance.",
			"type": "number",
			"default": 1
		},
		"renderResolutionMobile": {
			"description": "increases quality of render on mobile devices in cost of performance.",
			"type": "number",
			"default": 1
		},
		"framesSkipLimit": {
			"description": "on low performance devices allows to update game logic more that once per each frame.",
			"type": "number",
			"default": 4
		},
		"dynamicStageSize": {
			"description": "enables stage resizing regarding of allowed screen space. false - keeps projects screen proportions always fixed.",
			"type": "boolean",
			"default": false
		},
		"preventUpscale": {
			"description": "makes project screen size be equal to all allowed screen area, but not less that defined in 'width' and 'height'",
			"type": "boolean",
			"default": false
		},
		"webfontloader": {
			"description": "allows to preload fonts form google.fonts or from project`s assets folder",
			"type": "object",
			"properties": {
				"google": {
					"description": "list of fonts should be loaded from https://fonts.google.com/",
					"type": "object",
					"properties": {
						"families": {
							"type": "array",
							"items": {
								"type": "string"
							},
							"default": [
								"Fira Sans:300,400,700:cyrillic"
							]
						}
					}
				},
				"custom": {
					"description": "list of fonts should be loaded from project assets.",
					"type": "object",
					"properties": {
						"families": {
							"type": "array",
							"items": {
								"type": "string"
							},
							"default": [
								"Soup Of Justice"
							]
						}
					}
				}
			}
		},
		"defaultFont": {
			"description": "font used for render Text objects with no fontFamily property defined",
			"type": "string",
			"default": "Fira Sans, Arial"
		},
		"jpgQuality": {
			"description": "output build jpg quality 0 - 100",
			"type": "number",
			"default": 80
		},
		"soundFormats": {
			"description": "List of sounds formats which will be generated for project. Required because there is no format all the browsers support. Usually ogg + aac covers all the browsers you need.",
			"type": "array",
			"items": {
				"type": "string"
			},
			"default": [
				"ogg",
				"aac"
			]
		},
		"soundDefaultBitrate": {
			"description": "sounds default bitrate for auto generated ogg and aac files.",
			"type": "number",
			"default": 48,
			"enum": [
				8,
				16,
				24,
				32,
				40,
				48,
				56,
				64,
				80,
				96,
				112,
				128,
				144,
				160,
				192,
				224,
				256
			]
		},
		"fontHolderText": {
			"description": "invisible peace of text added to the web page for each loaded font, to keep web fonts from unloading. Add a few characters of your language if fonts in game look wrong.",
			"type": "string",
			"default": "ЯSфz"
		},
		"__buildConfigDebug": {
			"description": "path to vite config used for debug build.",
			"type": "string",
			"default": "thing-editor/electron-main/build-config.js"
		},
		"__buildConfigRelease": {
			"description": "path to vite config used for release build.",
			"type": "string",
			"default": "thing-editor/electron-main/build-config.js"
		},
		"loadOnDemandSounds": {
			"description": "info about way assets loading in to project. Usually this data generated automatically.",
			"type": "object",
			"default": {}
		},
		"mipmap": {
			"description": "enables mipmap generation for all textures. prevent aliasing effect on small size sprites.",
			"type": "boolean",
			"default": false
		},
		"version": {
			"description": "your project`s version",
			"type": "string",
			"default": "0.0.1"
		},
		"defaultMusVol": {
			"description": "default global volume level for all BgMusic",
			"type": "number",
			"default": 1
		},
		"defaultSoundsVol": {
			"description": "default global volume level for all sounds",
			"type": "number",
			"default": 1
		},
		"embedLocales": {
			"description": "built in all localization data in to projects`s assets.",
			"type": "boolean",
			"default": true
		},
		"__localesNewKeysPrefix": {
			"description": "all new created localization keys will start with this prefix.",
			"type": "string",
			"default": ""
		},
		"__doNotAutoCreateLocalizationFiles": {
			"description": "disable automatic creation of localization files for all languages.",
			"type": "boolean",
			"default": "false"
		},
		"__suspendWarnings": {
			"description": "suspends all warnings with listed codes.",
			"type": "array",
			"items": {
				"type": "number"
			},
			"default": []
		},
		"defaultLanguage": {
			"description": "language will be used if no users language present in localization data",
			"type": "string",
			"default": "en"
		},
		"autoFullScreenDesktop": {
			"description": "go to full-screen mode on desktop, after first user click.",
			"type": "boolean",
			"default": false
		},
		"autoFullScreenMobile": {
			"description": "go to full-screen mode on mobile, after first user click.",
			"type": "boolean",
			"default": true
		},
		"libs": {
			"description": "List of thing-libraries included in project. 'thing-editor/src/engine/lib' system library always included by default.",
			"type": "array",
			"items": {
				"type": "string"
			},
			"default": [
				"my-library"
			]
		}
	},
	"title": "JSON schema for thing-editor configuration files"
}
</file>

<file path="src/engine/lib/thing-lib.json">
{
	"mainScene": "main",
	"defaultFont": "Arial",
	"jpgQuality": 80,
	"screenOrientation": "landscape",
	"width": 1920,
	"height": 1080,
	"portraitWidth": 1080,
	"portraitHeight": 1920,
	"renderResolution": 1,
	"renderResolutionMobile": 1,
	"framesSkipLimit": 4,
	"dynamicStageSize": true,
	"preventUpscale": false,
	"fontHolderText": "ЯSфz",
	"mipmap": false,
	"__buildConfigDebug": "thing-editor/electron-main/build-config.js",
	"__buildConfigRelease": "thing-editor/electron-main/build-config.js",
	"version": "0.0.1",
	"soundFormats": [
		"ogg",
		"aac"
	],
	"soundDefaultBitrate": 48,
	"loadOnDemandSounds": {},
	"soundBitRates": {},
	"loadOnDemandTextures": {
		"common/ui/spin-icon-blur.png": 8,
		"preloader/spin.png": 8
	},
	"defaultLanguage": "en",
	"defaultMusVol": 1,
	"defaultSoundsVol": 1,
	"embedLocales": true,
	"autoFullScreenDesktop": false,
	"autoFullScreenMobile": true,
	"__group": "slots",
	"__suspendWarnings": []
}
</file>

<file path="src/engine/utils/call-by-path.ts">
import type { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';
import game from '../game';
import { pathDebugging_thing_editor_debug_helper, setValueByPath } from './get-value-by-path';

const callByPath = (callbackPath: CallBackPath, this_: Container): any => {
	assert(this_, '\'this\' argument is not provided in to \'callByPath\'.', 10026);
	assert(callbackPath, 'Empty callByPath string.', 10027);

	let data = stringToCallData(callbackPath);
	let path = data.p;
	let c: any;
	let rootName: string = path[0] as string;
	/// #if EDITOR
	pathDebugging_thing_editor_debug_helper(this_, callbackPath); // stopped at editor breakpoint
	/// #endif
	if (rootName === 'this') {
		c = this_;
	} else {
		/// #if EDITOR
		if (!(rootName in game)) {
			game.editor.ui.status.error('Unknown root element name \'' + rootName + '\' in \'' + callbackPath + '\'.', 30025, this_, game.editor.getFieldNameByValue(this_, callbackPath));
			return;
		}
		/// #endif
		c = (game as KeyedObject)[rootName];
	}
	let i = 1;
	let fOwner;
	while (i < path.length) {
		let n = path[i];
		fOwner = c;
		if (typeof n === 'string') {
			//assert(n.indexOf(',') < 0, "Comma ',' character detected in field name in callback`s path: " + callbackPath + '". Use "`" character to separate callback\s parameter block.', 10025); /// 99999 remove error docs 10025
			c = c[n];
		} else {
			c = c.getChildByName(n.c);
		}

		assert(c, 'Can\'t find ' + ((typeof n === 'string') ? 'property \'' + n : 'child \'#' + n.c) + '\' in callback`s path: ' + callbackPath, 10025);

		i++;
	}
	if (data.hasOwnProperty('v')) {
		if (c === setValueByPath) {
			return setValueByPath(data.v![0], data.v![1], this_);
		}
		return c.apply(fOwner, data.v);
	} else {
		/// #if DEBUG
		///@ts-ignore
		callbackPath, this_; // debug watch helpers
		/// #endif
		return c.call(fOwner);
	}
};

const _callsCache: KeyedMap<CallBackParsedData> = {};

const stringToCallData = (s: string): CallBackParsedData => {
	if (_callsCache.hasOwnProperty(s)) {
		return _callsCache[s];
	}
	let a = s.split(',');
	let data: CallBackParsedData = {
		p: a.shift()!.split('.').map(pathPartsMapper),
	};

	if (a.length) {
		data.v = a.map(turnInToNumberIfNumeric);
	}
	_callsCache[s] = data;
	return data;
};

const turnInToNumberIfNumeric = (s: string) => {
	let ret = parseFloat(s);
	if (!isNaN(ret)) {
		return ret;
	}

	ret = parseInt(s);
	if (!isNaN(ret)) {
		return ret;
	}
	if (s === 'true') {
		return true;
	} else if (s === 'false') {
		return false;
	}
	return s;
};

const pathPartsMapper = (s: string) => {
	if (s.charCodeAt(0) === 35) { //'#'
		return { c: s.substring(1) }; // - child name started with '#'
	}
	return s;
};

export default callByPath;
export { stringToCallData };
</file>

<file path="src/engine/utils/deep-freeze.ts">
const deepFreeze = (object: any) => {
	/// #if DEBUG
	/*
	/// #endif
	throw Error('"deepFreeze" is for debug build only. Please wrap "deepFreeze" usage in "///#if DEBUG" statement');
	//*/

	const propNames = Reflect.ownKeys(object);
	for (const name of propNames) {
		const value = object[name];
		if (value && typeof value === 'object') {
			deepFreeze(value);
		}
	}

	return Object.freeze(object);
};

export default deepFreeze;
</file>

<file path="src/engine/utils/full-screen.ts">
import { ButtonOnlyPropertyDesc } from 'thing-editor/src/editor/utils/button-only-selectable-property';
import { addOnClickOnce } from 'thing-editor/src/engine/utils/game-interaction.js';
import game from '../game.js';

const docElement = document.documentElement;

export default class FullScreen {

	static isAvailable = (docElement.requestFullscreen as any as boolean) && !(window as KeyedObject).cordova;

	static get isFullscreen() {
		if (document.fullscreenElement)
			return true;
		return false;
	}

	static open() {
		addOnClickOnce(FullScreen._openInner);
	}

	static _openInner() {
		try {
			if (docElement.requestFullscreen) {
				docElement.requestFullscreen().catch(() => {}).finally(() => {
					try {
						if (game.projectDesc.screenOrientation !== 'auto') {
							(screen.orientation as any).lock(game.projectDesc.screenOrientation);
						}
					} catch (_err) { }
				});
			}
			if (game.projectDesc.screenOrientation !== 'auto') {
				(screen.orientation as any).lock(game.projectDesc.screenOrientation);
			}
		} catch (_err) { }
	}

	static toggle() {
		if (FullScreen.isFullscreen) {
			FullScreen.close();
		} else {
			FullScreen.open();
		}
	}

	static close() {
		addOnClickOnce(FullScreen._closeInner);
		/// #if EDITOR
		/*
		/// #endif
		game.projectDesc.autoFullScreenMobile = game.projectDesc.autoFullScreenDesktop = false;
		//*/
	}

	static _closeInner() {
		if (document.exitFullscreen) {
			document.exitFullscreen();
		}
	}

}


/// #if EDITOR


(FullScreen as SelectableProperty).___EDITOR_isGoodForChooser = true;
(FullScreen.open as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(FullScreen.close as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(FullScreen.toggle as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;

Object.defineProperty(FullScreen, '___EDITOR_isHiddenForChooser', ButtonOnlyPropertyDesc);

/// #endif
</file>

<file path="src/engine/utils/game-interaction.ts">
import type { FederatedPointerEvent } from 'pixi.js';
import { Point } from 'pixi.js';
import game from 'thing-editor/src/engine/game';
import Button from 'thing-editor/src/engine/lib/assets/src/basic/button.c';
import type Scene from 'thing-editor/src/engine/lib/assets/src/basic/scene.c';
import L from 'thing-editor/src/engine/utils/l';
import Sound from 'thing-editor/src/engine/utils/sound';

const globalPoint = new Point();
const stagePoint = new Point();

const mouseHandlerGlobalDown = (ev: PointerEvent) => {
	Sound._unlockSound();
	Sound.fixIosContext();
	game.mouse.gameClick = ev.target === game.pixiApp.view;
	game.mouse.click = ev.buttons || 1;
	mouseHandlerGlobal(ev);
	if (
		/// #if EDITOR
		!game.__EDITOR_mode &&
		!game.__paused &&
		/// #endif
		game.currentContainer && (game.currentContainer as Scene).onMouseDown && game.currentContainer.interactiveChildren) {
		(game.currentContainer as Scene).onMouseDown(game.mouse, ev);
	}
};

const mouseHandlerGlobalUp = (ev: PointerEvent) => {
	game.mouse.click = 0;
	game.mouse.gameClick = false;
	mouseHandlerGlobal(ev);
	if (
		/// #if EDITOR
		!game.__EDITOR_mode &&
		!game.__paused &&
		/// #endif
		game.currentContainer && (game.currentContainer as Scene).onMouseUp && game.currentContainer.interactiveChildren) {
		(game.currentContainer as Scene).onMouseUp(game.mouse, ev);
	}
};

const mouseHandlerGlobalMove = (ev: PointerEvent) => {
	if (ev.buttons === 0) {
		game.mouse.click = 0;
		game.mouse.gameClick = false;
	}
	mouseHandlerGlobal(ev);
	if (
		/// #if EDITOR
		!game.__EDITOR_mode &&
		!game.__paused &&
		/// #endif
		game.currentContainer && (game.currentContainer as Scene).onMouseMove && game.currentContainer.interactiveChildren) {
		(game.currentContainer as Scene).onMouseMove(game.mouse, ev);
	}
};

const mouseHandlerGlobal = (ev: PointerEvent | FederatedPointerEvent) => {
	const canvasBounds = (game.pixiApp.view as HTMLCanvasElement).getBoundingClientRect();


	const canvasScale = (game._isCanvasRotated ? game.H : game.W) / canvasBounds.width;
	globalPoint.x = (ev.clientX - canvasBounds.x) * canvasScale;
	globalPoint.y = (ev.clientY - canvasBounds.y) * canvasScale;

	game.stage.toLocal(globalPoint, game.pixiApp.stage, stagePoint, true);

	let x = Math.round(stagePoint.x);
	let y = Math.round(stagePoint.y);

	/// #if EDITOR
	game.editor.mouseX = ev.clientX;
	game.editor.mouseY = ev.clientY;
	game.__mouse_EDITOR.x = globalPoint.x;
	game.__mouse_EDITOR.y = globalPoint.y;
	game.__mouse_uncropped.x = x;
	game.__mouse_uncropped.y = y;
	/// #endif

	if (x > game.W) {
		x = game.W;
	} else if (x < 0) {
		x = 0;
	}

	if (y > game.H) {
		y = game.H;
	} else if (y < 0) {
		y = 0;
	}
	game.mouse.x = x;
	game.mouse.y = y;
};


if ((window as KeyedObject).cordova) {
	document.addEventListener('backbutton', function () {
		Button._tryToClickByKeycode(27);
	}, false);
	game.exitApp = (enforced = false) => {
		if (enforced) {
			(navigator as any).app.exitApp();
		} else {

			game.showQuestion(L('SUREEXIT_TITLE'), L('SUREEXIT_TEXT'), undefined, () => {
				(game as any).exitApp(true);
			});
		}
	};
}

/// #if DEBUG
/// #if EDITOR
/*
/// #endif
window.addEventListener('error', function (er: ErrorEvent) {
	let txt = er.error.stack || er.error.message;
	game.__showDebugError(txt);
});//*/
/// #endif

let onClickOnceCallbacks: ((ev: PointerEvent) => void)[] = [];

function addOnClickOnce(callback: (ev: PointerEvent) => void) {
	onClickOnceCallbacks.push(callback);
}
/// #if EDITOR
(addOnClickOnce as SelectableProperty).___EDITOR_isHiddenForChooser = true;
/// #endif

export default function initGameInteraction() {
	const clickHandler = (ev: PointerEvent) => { // calls browsers functions which require to be fired in user context event
		while (onClickOnceCallbacks.length > 0) {
			let f = onClickOnceCallbacks.shift();
			(f as (ev: PointerEvent) => void)(ev);
		}
		/// #if EDITOR
		return;
		/// #endif
		if (game.isMobile.any ? game.projectDesc.autoFullScreenMobile : game.projectDesc.autoFullScreenDesktop) {	// eslint-disable-line no-unreachable
			if (game.fullscreen.isAvailable && !game.fullscreen.isFullscreen) {
				game.fullscreen._openInner();
			}
		}
	};

	const canvas = game.pixiApp.view as HTMLCanvasElement;

	canvas.addEventListener('click', clickHandler as any);
	canvas.addEventListener('touchend', clickHandler as any);


	window.addEventListener('pointerdown', mouseHandlerGlobalDown);
	window.addEventListener('pointermove', mouseHandlerGlobalMove);
	window.addEventListener('pointerup', mouseHandlerGlobalUp);
}

export { addOnClickOnce, mouseHandlerGlobal };
</file>

<file path="src/engine/utils/get-value-by-path.ts">
import assert from 'thing-editor/src/engine/debug/assert.js';
import game from '../game.js';

import { Container } from 'pixi.js';
import type { ComponentChild } from 'preact';
import EDITOR_FLAGS from 'thing-editor/src/editor/utils/flags.js';
import { stringToCallData } from './call-by-path.js';
/// #if EDITOR
import R from '../basic-preact-fabrics';
let latestDetectedSceneNode: Container | null;
let latestMethodOwner: any;
/// #endif
const getValueByPath = (valuePath: ValuePath, this_: any
	/// #if EDITOR
	, isLatestNodeGetting = false
	/// #endif
) => {
	assert(this_, '\'this\' argument is not provided in to \'getValueByPath\'', 10028);
	assert(valuePath, 'Empty data source path string.', 10029);
	let data = stringToCallData(valuePath);
	let path = data.p;
	let c: any;
	let rootName: string = path[0] as string;
	/// #if EDITOR
	if (!isLatestNodeGetting) {
		pathDebugging_thing_editor_debug_helper(this_, valuePath); // stopped at editor breakpoint
	}
	/// #endif
	if (rootName === 'this') {
		c = this_;
	} else {
		/// #if EDITOR
		if (!isLatestNodeGetting && !(rootName in game)) {
			game.editor.ui.status.error('Unknown root element name \'' + rootName + '\' in \'' + valuePath + '\'.', 30025, this_, game.editor.getFieldNameByValue(this_, valuePath));
			return;
		}
		/// #endif
		c = (game as KeyedMap<any>)[rootName];
	}
	let i = 1;
	let fOwner;

	/// #if EDITOR
	if (!c && isLatestNodeGetting) {
		return c;
	}
	/// #endif

	while (i < path.length) {
		/// #if EDITOR
		if (c instanceof Container) {
			latestDetectedSceneNode = c;
		}
		/// #endif
		let n = path[i];
		fOwner = c;
		if (typeof n === 'string') {
			c = c[n];
		} else {
			/// #if EDITOR
			if (!(c instanceof Container)) {
				game.editor.ui.status.error('Path contains all.#name but all.name without "#" character expected.', 99999, this_);
				return 'Path syntax error: all.#';
			};
			if (!c.getChildByName) {
				return 'getChildByName for not a Container.';
			}
			/// #endif
			c = c.getChildByName(n.c);
		}
		if (!c) {
			return c;
		}
		/// #if EDITOR
		if (c instanceof Container) {
			latestDetectedSceneNode = c;
		}
		/// #endif
		i++;
	}

	/// #if EDITOR
	if (isLatestNodeGetting) {
		latestMethodOwner = fOwner;
		return c;
	}
	/// #endif

	if (typeof c === 'function') {
		return c.apply(fOwner, data.v);
	}
	return c;
};

const setValueByPath = (valuePath: string, val: any, this_: any) => {
	assert(this_, '\'this\' object is not provided in to \'setValueByPath\'', 10030);
	assert(valuePath, 'Empty setValueByPath string.', 10031);
	let path = stringToCallData(valuePath).p;
	let c;
	let rootName: string = path[0] as string;
	/// #if EDITOR
	pathDebugging_thing_editor_debug_helper(this_, valuePath); // stopped at editor breakpoint
	/// #endif
	if (rootName === 'this') {
		c = this_;
	} else {
		/// #if EDITOR
		if (!(rootName in game)) {
			game.editor.ui.status.error('Unknown root element name \'' + rootName + '\' in \'' + valuePath + '\'.', 32015, this_, game.editor.getFieldNameByValue(this_, valuePath));
			return;
		}
		/// #endif
		c = (game as KeyedMap<any>)[rootName];
	}

	let i = 1;
	while (i < path.length - 1) {
		let n = path[i];
		if (typeof n === 'string') {
			c = c[n];
		} else {
			/// #if EDITOR
			if (!c.getChildByName) {
				return 'getChildByName for not a Container.';
			}
			/// #endif
			c = c.getChildByName(n.c);
		}
		if (!c) {
			return;
		}
		i++;
	}
	let n = path[i] as string;
	if (c[n] !== val) {
		assert(typeof c[n] !== 'function', 'Attempt to override function in setValueByPath', 10069);
		c[n] = val;
	}
};

/// #if EDITOR
(setValueByPath as SelectableProperty).___EDITOR_isGoodForCallbackChooser = true;
(setValueByPath as SelectableProperty).___EDITOR_isHiddenForDataChooser = true;

const getLatestSceneNodeBypath = (path: string, _this: any, suspendWarning = false): Container | null => {
	latestDetectedSceneNode = null;
	EDITOR_FLAGS.rememberTryTime();
	try {
		getValueByPath(path, _this, true);
	} catch (er) {
		if (!suspendWarning) {
			console.warn('path validation exception: (' + path + '): ' + _this.___info + ' ' + ((typeof er) === 'object' ? (er as any).message : er));
		}
	}
	EDITOR_FLAGS.checkTryTime();
	return latestDetectedSceneNode;
};

const getLatestSceneNodesByComplexPath = (path: string, o: Container) => {
	assert(!EDITOR_FLAGS.pathValidationCurrentThis, 'EDITOR_FLAGS.pathValidationCurrentThis is not empty.');
	EDITOR_FLAGS.pathValidationCurrentThis = o;
	let ret = [];
	let pathsParts = path.split(/[,|`]/);
	for (let p of pathsParts) {
		if (!p) {
			ret.push(null);
		} else {
			ret.push(getLatestSceneNodeBypath(p, o));
		}
	}
	if (EDITOR_FLAGS.pathValidationCurrentThis === o) {
		EDITOR_FLAGS.pathValidationCurrentThis = null;
	}
	return ret;
};

const ACTION_ICON_DEFAULT = R.img({ src: '/thing-editor/img/timeline/default.png' });

type SelectablePropertyKeys = keyof SelectableProperty;

export const findMethodDecorator = (decoratorName:SelectablePropertyKeys, owner: any, func: Function) => {
	const methodName = func.name;
	let f = func;
	while (typeof f === 'function') {
		if (decoratorName in f) {
			const ret = (f as SelectableProperty)[decoratorName];
			if (f !== func) {
				(func as SelectableProperty)[decoratorName] = ret;
			}
			return ret;
		}
		f = undefined!;
		while (owner && !f) {
			owner = Object.getPrototypeOf(owner);
			if (owner) {
				f = owner[methodName];
			}
		}
	}
};

export const getCallbackIcon = (path: string, _this: any, suspendWarning = false): ComponentChild | undefined => {
	if (!path) {
		return ACTION_ICON_DEFAULT;
	}
	EDITOR_FLAGS.rememberTryTime();
	let ret:ComponentChild;
	try {
		latestMethodOwner = null;
		let func = getValueByPath(path, _this, true);

		if (typeof func === 'function') {
			ret = findMethodDecorator('___EDITOR_actionIcon', latestMethodOwner, func);
		}
	} catch (er) {
		if (!suspendWarning) {
			console.warn('timeline icon search error: (' + path + '): ' + _this.___info + ' ' + ((typeof er) === 'object' ? (er as any).message : er));
		}
	}
	EDITOR_FLAGS.checkTryTime();
	return ret || ACTION_ICON_DEFAULT;
};

const pathDebugging_thing_editor_debug_helper = (o: Container, path: string) => {
	if (o instanceof Container) {
		if (o.__nodeExtendData.hasOwnProperty('__pathBreakpoint') && o.__nodeExtendData.__pathBreakpoint === path) {
			delete o.__nodeExtendData.__pathBreakpoint;
			debugger;
		}
	}
};


(setValueByPath as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return new Promise((resolve) => {
		import('thing-editor/src/editor/ui/props-editor/props-editors/data-path-editor').then((m) => {
			m.default.choosePath('Enter data path', '').then((enteredText1) => {
				if (enteredText1) {
					game.editor.ui.modal.showPrompt('Enter value', '').then((enteredText2) => {
						resolve([enteredText1, enteredText2]);
					});
				}
			});
		});
	});
};

export {
	getLatestSceneNodeBypath,
	getLatestSceneNodesByComplexPath,
	pathDebugging_thing_editor_debug_helper
};

/// #endif

export default getValueByPath;

export {
	setValueByPath
};
</file>

<file path="src/engine/utils/html-error.html">
<div class="loading-error-wrapper" style="
			position:absolute;
			z-index: 2;
			width:100%;
			height:100%;
			left:0;
			top:0;
			background:rgba(0,0,0,0.7)">
	<div class="loading-error-body" style="
			padding: 5vh;
			box-sizing: border-box;
			margin: 20vh 0;
			width: 100%;
			background: #000000;
			text-align: center;">
		<div class="loading-error-game-title">$TITLE$</div>
		<div class="loading-error-title" style="
			margin: 2vh;
			font-size:200%;">
			LOADING ERROR</div>
		<div class="loading-error-message">(click to reload)</div>
	</div>
</div>
</file>

<file path="src/engine/utils/indexed-db-utils.ts">
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import assert from '../debug/assert';

const IS_SKIN_MODIFIED = '__is-skin-modified';

function message(msg: string) {
	if (game.classes.FlyText) {
		game.classes.FlyText.flyText(msg, game.mouse.x, game.mouse.y);
	} else {
		alert(msg);
	}
}
interface IndexedDBRecord {

	// visible file name which was selected to override sound
	fileName: string;
	// url encodes sound data.
	data: string;
}

interface PackageData {
	data: KeyedObject;
	settings: KeyedObject;
	type: 'indexed-db-utils-dump';
}

let fileInput: HTMLInputElement;
let func: () => void;
function clickElem(elem: HTMLInputElement) {
	const eventMouse = document.createEvent('MouseEvents');
	eventMouse.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	elem.dispatchEvent(eventMouse);
}

export default class IndexedDBUtils {

	static getEntriesList(type: string) {
		type = '::' + type;
		return Object.keys(dataStore).filter(k => k.endsWith(type)).map(k => k.replace(type, ''));
	}

	static save(name: string, type: string, data?: IndexedDBRecord | KeyedObject) {
		const id = name + '::' + type;
		if (JSON.stringify(dataStore[id]) !== JSON.stringify(data)) {
			if (typeof data === 'undefined') {
				delete dataStore[id];
				getTransaction().then(db => db.delete(id));
			} else {
				dataStore[id] = data;
				getTransaction().then(db => db.put({ id, data }));
			}
			game.settings.setItem(IS_SKIN_MODIFIED, true);
		}
	}

	static load(name: string, type: string): IndexedDBRecord | KeyedObject | undefined {
		const id = name + '::' + type;
		return dataStore[id];
	}

	private static clear() {
		Object.keys(game.settings.data).forEach((key) => {
			if (key.startsWith('IDB_')) {
				game.settings.removeItem(key);
			}
		});

		this.resetIsSkinModified();

		return new Promise<void>((resolve) => {
			getTransaction().then((db) => {
				db.clear().onsuccess = () => {
					resolve();
				};
			});
		});
	}

	static export() {

		const a = document.createElement('a');
		const content = this.getRawData();
		if (content) {
			const file = new Blob([content], { type: 'text/plain' });
			a.href = URL.createObjectURL(file) + '#_Export_skin';
			a.download = game.settings.getItem('IDB_skin-name', 'New-skin.json');
			a.click();
			this.resetIsSkinModified();
		}
	}

	static getRawData() {
		if (!Object.keys(dataStore).length) {
			message('no data to export');
			return;
		}
		const settings = {} as KeyedObject;
		Object.keys(game.settings.data).forEach((key) => {
			if (key.startsWith('IDB_')) {
				settings[key] = game.settings.getItem(key);
			}
		});
		return JSON.stringify({
			data: dataStore,
			settings,
			type: 'indexed-db-utils-dump'
		} as PackageData);
	}

	static async import() {
		await this.askAboutUnsavedChanges('Load Anyway');

		const data = (await chooseFile('application/json'))[0];
		this.importRawData(data.data, data.fileName);

	}

	static async importRawData(data: string, fileName?: string) {
		try {
			if (Lib.hasPrefab('final-fader')) {
				game.showModal('final-fader');
			}
			const content = JSON.parse(data) as PackageData;
			if (content.type !== 'indexed-db-utils-dump') {
				message('Wrong file format.');
				return;
			}
			if (fileName) {
				content.settings['IDB_skin-name'] = fileName;
			}
			await this.setFullData(content);
		} catch (er: any) {
			game.hideModal();
			message('import error: ' + er.message);
		}
	}

	private static async setFullData(data: PackageData) {
		await this.clear();
		dataStore = data.data;
		await Promise.all(Object.keys(dataStore).map((id) => {
			return new Promise<void>((resolve) => {
				getTransaction().then(db => db.put({ id, data: dataStore[id] }).onsuccess = () => {
					resolve();
				});
			});
		}));
		for (const key in data.settings) {
			game.settings.setItem(key, data.settings[key]);
		}
		window.location.reload();
	}

	private static async askAboutUnsavedChanges(okMessage: string) {
		return new Promise<void>((resolve) => {
			if (this.isSkinModified()) {
				game.showQuestion('Are you sure?', 'Current skin has unsaved changes.', okMessage, resolve);
			} else {
				resolve();
			}
		});
	}

	static isSkinModified() {
		return game.settings.getItem(IS_SKIN_MODIFIED);
	}

	static resetIsSkinModified() {
		return game.settings.removeItem(IS_SKIN_MODIFIED);
	}

	static async reset() {
		await this.askAboutUnsavedChanges('Reset skin anyway');
		game.settings.removeItem('IDB_skin-name');
		await this.setFullData({ settings: {}, data: {}, type: 'indexed-db-utils-dump' });
	}

	static async openFile(key: string, type = 'sound', accept = 'audio/x-wav', multiple = false, contentParser?:(content: any) => Promise<any>): Promise<IndexedDBRecord[]> {

		const contents = await chooseFile(accept, multiple, contentParser);

		if (contents && key) {
			assert(contents.length === 1, 'key should be empty for multiply files selection');
			IndexedDBUtils.save(
				key,
				type,
				contents[0]
			);
		}
		return contents;
	}
}

async function chooseFile(accept = 'audio/x-wav', multiple = false, contentParser?:(content: any) => Promise<any>): Promise<IndexedDBRecord[]> {
	return new Promise((resolve) => {
		const readFile = (ev: InputEvent) => {
			const files = (ev.target as HTMLInputElement).files;
			if (!files?.length) {
				return;
			}
			const ret = [] as IndexedDBRecord[];

			for (const file of files) {
				const reader = new FileReader();
				reader.onload = async function (e) {
					let contents = e.target!.result as string;

					if (contentParser) {
						contents = await contentParser(contents);
					}

					ret.push({
						fileName: file.name.split(/[\\\/]/).pop()!,
						data: contents
					});
					if (ret.length === files.length) {
						resolve(ret);
					}
				};

				if (file.name.endsWith('.json')) {
					reader.readAsText(file);
				} else {
					reader.readAsDataURL(file);
				}
			}
		};
		if (!fileInput) {
			fileInput = document.createElement('input');
			fileInput.type = 'file';
			fileInput.multiple = multiple;
			document.body.appendChild(fileInput);
			fileInput.style.display = 'none';
		}
		fileInput.value = '';
		fileInput.removeEventListener('change', func);
		func = readFile as any;
		fileInput.addEventListener('change', func);
		fileInput.accept = accept;
		clickElem(fileInput);
	});
}

export { chooseFile };
export type { IndexedDBRecord };

let dataStore: KeyedMap<IndexedDBRecord | KeyedObject | undefined> = {};

let db: IDBDatabase;

function getTransaction(): Promise<IDBObjectStore> {
	return new Promise((resolve) => {
		const transaction = db.transaction('MyObjectStore', 'readwrite');
		resolve(transaction.objectStore('MyObjectStore'));

		/*transaction.oncomplete = function () {
			db.close();
		};*/
	});
}


window.addEventListener('game-will-init', () => {
	game.loadingAdd('indexed-db');
	//@ts-ignore
	let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB as IDBFactory;
	const openDB = indexedDB.open('DB' + game.projectDesc.id, 1);

	openDB.onupgradeneeded = function () {
		openDB.result.createObjectStore('MyObjectStore', { keyPath: 'id' });
	};

	openDB.onblocked = () => {
		throw new Error('indexedDB blocked');
	};

	openDB.onerror = (er) => {
		throw er;
	};

	openDB.onsuccess = () => {
		db = openDB.result;
		getTransaction().then(transaction => {
			const req = transaction.getAllKeys();
			req.onsuccess = () => {
				for (const key of req.result) {
					const getData = transaction.get(key);
					game.loadingAdd(key);
					getData.onsuccess = function () {
						const data = getData.result?.data;
						dataStore[key.toString()] = data;
						game.loadingRemove(key);
					};
				}
				game.loadingRemove('indexed-db');
			};
			req.onerror = (er) => {
				throw er;
			};
		}).catch((er) => { throw er; });
	};
});
</file>

<file path="src/engine/utils/keys.ts">
import game from '../game.js';

let downedKeys: Set<number> = new Set();
const keyUpsToApply: number[] = [];

let w = window;
try {
	while (w) {
		w.addEventListener('keydown', (ev) => {
			downedKeys.add(ev.keyCode);
			if (ev.metaKey) {
				downedKeys.add(17);
			}

			/// #if EDITOR
			return;
			/// #endif
			if (ev.keyCode >= 37 && ev.keyCode <= 40) { //eslint-disable-line no-unreachable
				ev.preventDefault();
			}

			//console.log(ev.keyCode);
		});

		w.addEventListener('keyup', (ev) => {

			/// #if EDITOR
			if (game.__EDITOR_mode) {
				downedKeys.delete(ev.keyCode);
				return;
			}
			/// #endif
			keyUpsToApply.push(ev.keyCode);
			if (ev.metaKey) {
				keyUpsToApply.push(17);
			}
		});

		if (w.parent !== w) {
			w = w.parent as any;
		} else {
			break;
		}
	}
} catch (_e) {
	/// catch parent window access for iframed on another websites
}

export default class Keys {

	static update() {
		while (keyUpsToApply.length > 0) {
			downedKeys.delete(keyUpsToApply.pop() as number);
		}
	}

	static get all() {
		return downedKeys;
	}

	static get up() {
		return downedKeys.has(38) || downedKeys.has(87);
	}

	static set up(val) {
		if (val) {
			downedKeys.add(38);
		} else {
			downedKeys.delete(38);
			downedKeys.delete(87);
		}
	}

	static get down() {
		return downedKeys.has(40) || downedKeys.has(83);
	}

	static set down(val) {
		if (val) {
			downedKeys.add(40);
		} else {
			downedKeys.delete(40);
			downedKeys.delete(83);
		}
	}

	static get shiftKey() {
		return downedKeys.has(16);
	}

	static get altKey() {
		return downedKeys.has(18);
	}

	static get ctrlKey() {
		return downedKeys.has(17);
	}

	static get left() {
		return downedKeys.has(37) || downedKeys.has(65);
	}

	static set left(val) {
		if (val) {
			downedKeys.add(37);
		} else {
			downedKeys.delete(37);
			downedKeys.delete(65);
		}
	}

	static get right() {
		return downedKeys.has(39) || downedKeys.has(68);
	}

	static set right(val) {
		if (val) {
			downedKeys.add(39);
		} else {
			downedKeys.delete(39);
			downedKeys.delete(68);
		}
	}

	static isKeycodePressed(keyCode: number) {
		return downedKeys.has(keyCode);
	}

	static resetAll() {
		downedKeys.clear();
	}
}

/// #if EDITOR
(Keys.resetAll as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Keys.isKeycodePressed as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Keys.update as SelectableProperty).___EDITOR_isHiddenForChooser = true;


/// #endif
</file>

<file path="src/engine/utils/l.ts">
import type { Container } from 'pixi.js';
import type { LocalizationKeys } from 'thing-editor/src/editor/localization-typings';
import R from 'thing-editor/src/editor/preact-fabrics';

import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';

let currentLanguageTable: KeyedMap<string> = {};
/// #if EDITOR
let warnedIds: KeyedMap<true> = {};
/// #endif

let languages: KeyedMap<KeyedMap<string>> = {};
let currentLanguageId = (window.navigator && navigator.language) ? navigator.language.split('-')[0] : 'en';
let isLangDataLoaded = false;

interface TL extends LocalizationKeys {
	(id: string, values?: KeyedObject | number): string;
	setLanguagesAssets: (src: KeyedObject) => void;
	messageProcessor: (text: string, values?: KeyedObject | number) => string;
	has: (id: string) => boolean;
	getData: () => KeyedMap<KeyedMap<string>>;
	setCurrentLanguage: (languageId?: string) => void;
	refreshAllTextEverywhere: () => void;
	getCurrentLanguageId: () => string;
	getLanguagesList: () => string[];
	_deserializeLanguage: (langSrc: KeyedObject) => KeyedMap<string>;
}

const L: TL = ((id: string, values?: KeyedObject | number): string => {
	/// #if EDITOR
	if (!currentLanguageTable.hasOwnProperty(id)) {
		let fieldName: string;
		const tryToFindOwner = () => {
			let owner: Container | undefined;
			game.forAllChildrenEverywhere((o: Container) => {
				if (owner) {
					return;
				}
				let props = (o.constructor as SourceMappedConstructor).__editableProps;
				for (let p of props) {
					if (p.type === 'l10n' && (o as KeyedObject)[p.name] === id) {
						fieldName = p.name;
						owner = o;
						return;
					}
				}
			});
			if (owner) {
				let tryToFixKey = game.editor.projectDesc.__localesNewKeysPrefix + id.split('.').pop();
				if (currentLanguageTable.hasOwnProperty(tryToFixKey)) {
					game.editor.onObjectsPropertyChanged(owner, fieldName, tryToFixKey);
					game.editor.ui.modal.notify('key changed to: ' + tryToFixKey);
				}
				game.editor.ui.sceneTree.selectInTree(owner);
				game.editor.ui.propsEditor.selectField(fieldName);
			} else {
				let txt = R.span(null, 'Do you want to create translatable key ', R.b(null, '"' + id + '"'), '?');
				game.editor.ui.modal.showEditorQuestion(txt, txt, () => {
					game.editor.LanguageView.editKey(id);
				}, 'Create');
			}
		};
		if (!warnedIds.hasOwnProperty(id)) {
			warnedIds[id] = true;
			game.editor.ui.status.warn('Translatable text key \'' + id + '\' is not exists.', 32031, tryToFindOwner);
			window.setTimeout(() => {
				warnedIds = {};
			}, 1000);
		}
	}
	/// #endif

	let ret;
	if (currentLanguageTable.hasOwnProperty(id)) {
		ret = currentLanguageTable[id];
		if (L.messageProcessor) {
			ret = L.messageProcessor(ret, values);
		}
	} else {
		ret = id;
	}
	if (typeof values === 'object') {
		for (let key in values) {
			ret = ret.replace(key, values[key]);
		}

	}
	return ret;
}) as any;

L.has = (id: string) => {
	return currentLanguageTable.hasOwnProperty(id);
};

L.getData = () => {
	return languages;
};

L.setCurrentLanguage = (languageId?: string) => {
	if (!isLangDataLoaded) {
		assert(languageId, 'languageId expected.');
		currentLanguageId = languageId!;
		return;
	}
	if (currentLanguageId !== languageId) {

		if (languageId && languages.hasOwnProperty(languageId)) {
			currentLanguageId = languageId;
			game.settings.setItem('locale', languageId);
		} else {
			currentLanguageId = game.settings?.getItem('locale');
			if (!currentLanguageId) {
				currentLanguageId = game.projectDesc.defaultLanguage;
				if (window.navigator && navigator.languages) {
					for (let l of navigator.languages) {
						l = l.split('-')[0];
						if (languages.hasOwnProperty(l)) {
							currentLanguageId = l;
							break;
						}
					}
				}
			}
		}
		currentLanguageTable = languages[currentLanguageId];
		L.refreshAllTextEverywhere();
	}
};

L.setLanguagesAssets = (_languages: KeyedMap<KeyedMap<string>>) => {
	isLangDataLoaded = true;
	for (let langId in _languages) {
		languages[langId] = Object.assign(languages[langId] || {}, _languages[langId]);
	}
	L.setCurrentLanguage();
};

L.refreshAllTextEverywhere = () => {
	game.forAllChildrenEverywhere(refreshTranslatableText);
};

function refreshTranslatableText(o: any) {
	if (o.onLanguageChanged) {
		o.onLanguageChanged();
	}
}

L.getCurrentLanguageId = () => {
	return currentLanguageId;
};

L.getLanguagesList = () => {
	return Object.keys(languages);
};

L._deserializeLanguage = (langSrc: KeyedObject): KeyedMap<string> => {
	let ret: KeyedMap<string> = {};
	deserializeEntry(langSrc, ret);
	return ret;
};

const deserializeEntry = (src: KeyedObject, output: KeyedMap<string>, path?: string) => {
	for (let key in src) {
		if (src.hasOwnProperty(key)) {
			let val = src[key];
			if ((typeof val) === 'string') {
				if (path) {
					output[path + key] = src[key];
				} else {
					output[key] = src[key];
				}
			} else {
				if (path) {
					deserializeEntry(val, output, path + key + '.');
				} else {
					deserializeEntry(val, output, key + '.');
				}
			}
		}
	}
};

export default L;
</file>

<file path="src/engine/utils/load-dynamic-textures.ts">
const loadDynamicTextures = () => {
	//TODO:
};

export default loadDynamicTextures;
</file>

<file path="src/engine/utils/pool.ts">
import { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';

let pools = new Map();
/// #if EDITOR
let __idCounter = 1;

const onNew = (ret: any) => {
	const editableProps = (ret.constructor as SourceMappedConstructor).__editableProps;
	if (editableProps) {
		for (let prop of editableProps) {
			if (prop.__nullCheckingIsApplied) {
				if (ret.hasOwnProperty(prop.name)) {
					delete ret[prop.name]; //delete own numeric properties to make NaN checking work
					ret[prop.name] = prop.default;
				}
			}
		}
	}
	onTake(ret);
};

const onTake = (ret: any) => {
	if (ret instanceof Container) {
		assert(!(ret as any)._eventsCount, 'Object has unsubscribed events');
		ret.___id = __idCounter++;
		ret.__nodeExtendData = {};
	}
};

/// #endif

export default class Pool {

	static clearAll() {
		/// #if EDITOR
		Pool.__resetIdCounter();
		/// #endif
		pools.clear();
	}

	/// #if EDITOR
	static __resetIdCounter() {
		__idCounter = 1;
	}
	/// #endif

	static create<T>(constructor: new () => T): T {
		if (!pools.has(constructor)) {
			const ret = new constructor();
			/// #if EDITOR
			onNew(ret);
			/// #endif
			return ret;
		}
		let a = pools.get(constructor);
		if (a.length === 0) {
			const ret = new constructor();
			/// #if EDITOR
			onNew(ret);
			/// #endif
			return ret;
		}
		/// #if EDITOR
		let i = Math.floor(Math.random() * a.length);
		let ret = a[i];
		a.splice(i, 1);
		assert(!(ret instanceof Container) || ret.children.length === 0, 'Pool contains ' + (constructor as any as SourceMappedConstructor).__className + ' with non empty children.', 90001);
		onTake(ret);
		return ret;
		/// #endif

		return a.pop(); // eslint-disable-line no-unreachable
	}

	static dispose(obj: any) {
		/// #if EDITOR
		obj.___id = null;
		/// #endif
		let key = obj.constructor;
		if (!pools.has(key)) {
			pools.set(key, []);
		}

		assert(!pools.get(key).includes(obj), 'Object already disposed');

		pools.get(key).push(obj);
	}
}
</file>

<file path="src/engine/utils/re-apply-textures.ts">
import game from 'thing-editor/src/engine/game';

const texturesRefreshSchedulledNames = new Set();
let texturesRefreshSchedulledTimeout = 0;

function reApplyTextures(name: string) {
	if (texturesRefreshSchedulledTimeout) {
		clearTimeout(texturesRefreshSchedulledTimeout);
	}
	texturesRefreshSchedulledTimeout = window.setTimeout(refreshAllTextures, 10);
	texturesRefreshSchedulledNames.add(name);
}

function refreshAllTextures() {
	texturesRefreshSchedulledTimeout = 0;
	game.forAllChildrenEverywhere((o: any) => {
		if (o.image && texturesRefreshSchedulledNames.has(o.image)) {
			let tmp = o.image;
			o.image = 'EMPTY';
			o.image = tmp;
		}
	});
	texturesRefreshSchedulledNames.clear();
}

export default reApplyTextures;
</file>

<file path="src/engine/utils/remove-holder.ts">
import { Container } from 'pixi.js';
import type { DebugStack } from 'thing-editor/src/editor/utils/stack-utils';
import { removeHoldersToCleanup } from 'thing-editor/src/engine/lib';

class RemoveHolder extends Container {
	constructor() {
		super();
		this.visible = false;
	}

	/// #if EDITOR
	stack!: DebugStack;
	/// #endif

	onRemove() {
		super.onRemove();
		let i = removeHoldersToCleanup.indexOf(this);
		if (i >= 0) {
			removeHoldersToCleanup.splice(i, 1);
		}
	}
	update() { /* empty */ }
}

export default RemoveHolder;
</file>

<file path="src/engine/utils/scene-linked-request.ts">
import type { Container } from 'pixi.js';
import assert from 'thing-editor/src/engine/debug/assert';
import SceneLinkedPromise from '../lib/assets/___system/scene-linked-promise.c';
import waitForCondition from '../lib/assets/src/utils/wait-for-condition';

const hooks:SceneLinkedRequestHook[] = [];

export type SceneLinkedRequestHook = (url: string, resultFormat: 'json' | 'text' | 'blob' | 'arrayBuffer', options?: RequestInit) => (Promise<void> | undefined);


let queuedInProgress = false;

export default class SceneLinkedRequest {

	static addHook(hook: SceneLinkedRequestHook) {
		hooks.push(hook);
	}

	static fetch(owner: Container, url: string, resultFormat: ('json' | 'text' | 'blob' | 'arrayBuffer') = 'json', options?: RequestInit, attempts = 1, queued = false) {
		let destroyed = false;
		assert(owner, 'Request\'s owner display object should be provided.', 10062);
		assert(url, 'Request\'s URL should be provided.', 10063);
		let ret = SceneLinkedPromise.promise(async (resolve, reject) => {
			let delay = 0;
			if (hooks.length) {
				await Promise.all(hooks.map(hook => hook(url, resultFormat, options)));
			}

			if (queued) {
				if (queuedInProgress) {
					await waitForCondition(() => {
						if (!queuedInProgress) {
							queuedInProgress = true;
							return true;
						}
					});
				} else {
					queuedInProgress = true;
				}
			}
			while (attempts > 0 && !destroyed) {
				await fetch(url, options)
					.then((response) => (response as any)[resultFormat]())
					.then((res) => {
						attempts = 0;
						resolve(res);
					}).catch((er) => {
						attempts--;
						delay += 1000;
						if (attempts === 0) {
							if (reject) {
								reject(er);
							}
						}
					});
				if (delay) {
					await new Promise((resolve) => { window.setTimeout(resolve, delay); });
				}
			}
			if (queued) {
				queuedInProgress = false;
			}
		}, owner);
		ret.name = 'Request: ' + url;
		ret.finally(() => {
			destroyed = true;
		});
		return ret;
	}
}
</file>

<file path="src/engine/utils/settings.ts">
import fs from 'thing-editor/src/editor/fs';
import game from 'thing-editor/src/engine/game';

class Settings {
	_storageId: string;
	data: KeyedObject;
	__flushInterval = 0;

	static globalOnChanged?: (name: string, val: any) => void;

	constructor(storageId: string) {
		this._storageId = storageId;
		this.data = {};
		try {
			if (typeof (Storage) !== 'undefined') {
				if (localStorage.hasOwnProperty(storageId)) {
					this.data = JSON.parse(localStorage[storageId]);
				}
			}
		} catch (_er) { /* empty */ }
		this.flush = this.flush.bind(this);
		window.addEventListener('beforeunload', () => {
			if (this.__flushInterval) {
				this.flush();
			}
		});
	}

	getItem(name: string, def?: any): any {
		if (this.data.hasOwnProperty(name)) {
			return this.data[name];
		}
		return def;
	}

	setItem(name: string, val: any) {
		if ((val !== this.data[name]) || (typeof (val) === 'object')) {
			this.data[name] = val;
			this.changed();
			if (Settings.globalOnChanged) {
				Settings.globalOnChanged(name, val);
			}
		}
	}

	removeItem(name: string) {
		if (this.data.hasOwnProperty(name)) {
			delete (this.data[name]);
			this.changed();
		}
	}

	changed() {
		if (!this.__flushInterval) {
			/// #if EDITOR
			if (game.__EDITOR_mode) {
				this.flush();
				return;
			}
			/// #endif
			this.__flushInterval = window.setTimeout(this.flush, 10, this);
		}
	}

	clear() {
		this.data = {};
		this.changed();
	}

	flush() {
		if (typeof (Storage) !== 'undefined') {
			this.__flushInterval = 0;

			/// #if EDITOR
			game.editor.LocalStoreView.refresh();

			/// #endif

			try {
				localStorage.setItem(this._storageId, JSON.stringify(this.data,
					/// #if EDITOR
					fs.fieldsFilter
					/// #endif
				));
			} catch (er) {
				/// #if DEBUG
				console.error((er as Error)?.stack);
				debugger; // local store serialization error
				/// #endif
				this.data = this.data || {};
			}
		}
	}
}

export default Settings;

/// #if EDITOR
(Settings.prototype.changed as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Settings.prototype.flush as SelectableProperty).___EDITOR_isHiddenForChooser = true;
(Settings.prototype.getItem as SelectableProperty).___EDITOR_isHiddenForChooser = true;
/// #endif
</file>

<file path="src/engine/utils/sound-debug-panel.css">
.sounds-debug-panel {
	position:fixed;
	right: 0;
	top: 0;
	z-index: 10000;
	color: #ffffff;
	background: rgba(0, 0, 0, 0.8);
	padding: 20px;
	margin: 20px;
	max-height: 90vh;
}

.sounds-debug-panel:HAS(.panel-is-left) {
	left: 0;
	right: unset;
}

.sounds-debug-panel .list-header {
	color: #999999;
}

.sounds-debug-panel .sort-button {
	display: inline-block;
	padding: 4px 10px;
	cursor: pointer;
}

.sounds-debug-panel-body {
	overflow-y: auto;
	max-height: 80vh;
	margin-bottom: 10px;
}

.sounds-debug-panel button {
	padding: 5px;
	cursor: pointer;
	border-radius: 20px;
	border: none;
	background: #333333;
	color: #ffffff;
}

.sounds-debug-panel table {
	margin-bottom: 10px;
}
	
.sounds-debug-panel .close-sounds-button {
	background: #770000;
	position: absolute;
	right: 10px;
}

.sounds-debug-panel .snd-name {
	background: #000;
}

.sounds-debug-panel .snd-name:hover {
	cursor: pointer;
}

.sounds-debug-panel .snd-name-empty::before {
  content: "(?) ";
  color: rgb(68, 142, 185);
}


.sounds-debug-panel tr:hover {
	background: #141414;
}

.sounds-debug-panel td button,
.sounds-debug-panel td {
	padding: 2px 10px;
}

.sounds-debug-panel .snd-clear {
	background: #990000;
}
</file>

<file path="src/engine/utils/sound.ts">
/// #if EDITOR
import { editorEvents } from 'thing-editor/src/editor/utils/editor-events';
import MusicFragment from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music/music-fragment';
import { CTRL_READABLE } from './utils';
/// #endif

/// #if DEBUG
import { render } from 'preact';
import waitForCondition from 'thing-editor/src/engine/lib/assets/src/utils/wait-for-condition';
import IndexedDBUtils from 'thing-editor/src/engine/utils/indexed-db-utils';
import R from '../basic-preact-fabrics';
import FlyText from '../lib/assets/src/basic/fly-text.c';
import debugPanelStyle from './sound-debug-panel.css?raw';
/// #endif

import HowlSound, { rootAudioContext } from 'thing-editor/src/engine/HowlSound';
import assert from 'thing-editor/src/engine/debug/assert';
import game from 'thing-editor/src/engine/game';
import Lib from 'thing-editor/src/engine/lib';
import { MIN_VOL_THRESHOLD } from 'thing-editor/src/engine/lib/assets/src/basic/b-g-music/music-fragment';

export const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');

export const slideAudioParamTo = (param:AudioParam, val:number, duration:number, fromValue = param.value) => {
	param.cancelScheduledValues(rootAudioContext.currentTime);
	if (duration > 0 && !isFirefox) {
		param.setValueCurveAtTime([fromValue, val], rootAudioContext.currentTime, duration);
	} else {
		param.setValueAtTime(val, rootAudioContext.currentTime);
	}
};

/// #if DEBUG
let EMPTY_SOUND:HowlSound;
/// #endif

export default class Sound {

	static outputs = {} as{
		MUSIC: GainNode;
		FX: GainNode;
		[key: string]: GainNode;
	};

	/** volume is quadratic. 0.1 - sound off. 1.0 - max vol */
	static get soundsVol() {
		/// #if EDITOR
		if (game.__EDITOR_mode) {
			return 1;
		}
		/// #endif
		return soundsVol;
	}

	static set soundsVol(v) {
		assert(!isNaN(v), 'invalid value for \'soundsVol\'. Valid number value expected.', 10001);
		v = Math.max(0, Math.min(1, v));
		slideAudioParamTo(Sound.outputs.FX.gain, v * v, 0.1, (soundsVol * soundsVol) || 0);
		soundsVol = v;
		game.settings.setItem('soundsVol', soundsVol);
	}

	static setSoundsVol(v: number) {
		Sound.soundsVol = v;
	}

	static setMusicVol(v: number) {
		Sound.musicVol = v;
	}

	static fixIosContext() {
		try {
			if (game.isMobile.apple.device && (rootAudioContext.state === 'suspended')) {
				rootAudioContext.resume();
			}
		} catch (_er) {};
	}

	static _onVisibilityChange(visible: boolean) {
		/// #if EDITOR
		return;
		/// #endif
		Sound.fixIosContext();
		for (let key in Sound.outputs) {
			const node = Sound.outputs[key];
			const vol = (key === 'MUSIC') ? musicVol : soundsVol;
			slideAudioParamTo(node.gain, visible ? vol * vol : 0, 0.1);
		}
	}

	/** volume is quadratic. 0.1 - sound off. 1.0 - max vol */

	static get musicVol() {
		return musicVol;
	}

	static set musicVol(v) {
		assert(!isNaN(v), 'invalid value for \'musicVol\'. Valid number value expected.', 10001);
		v = Math.max(0, Math.min(1, v));
		slideAudioParamTo(Sound.outputs.MUSIC.gain, v * v, 0.1, musicVol * musicVol || 0);
		musicVol = v;
		game.settings.setItem('musicVol', musicVol);
	}

	static get fullVol() {
		return Math.max(soundsVol, musicVol);
	}

	static set fullVol(v) {
		let a = game.settings.getItem('musicEnabled', true);
		let b = game.settings.getItem('soundEnabled', true);
		if (!a && !b) {
			a = b = true;
		}
		if (a) {
			Sound.musicVol = v;
		} else {
			game.settings.setItem('musicVolEnabling', v);
		}
		if (b) {
			Sound.soundsVol = v;
		} else {
			game.settings.setItem('soundsVolEnabling', v);
		}
	}

	static get musicEnabled() {
		return musicVol >= MIN_VOL_THRESHOLD;
	}

	static set musicEnabled(val) {
		if (Sound.musicEnabled !== val) {
			if (val) {
				Sound.musicVol = game.settings.getItem('musicVolEnabling', game.projectDesc.defaultMusVol);
			} else {
				game.settings.setItem('musicVolEnabling', musicVol);
				Sound.musicVol = 0;
			}
			Sound.rememberEnableLevels();
		}
	}

	static rememberEnableLevels() {
		if (!enablingSaveTimeout) {
			enablingSaveTimeout = window.setTimeout(_rememberEnableLevels, 10);
		}
	}

	static toggleMusic() {
		Sound.musicEnabled = !Sound.musicEnabled;
	}

	static get soundEnabled() {
		return soundsVol > MIN_VOL_THRESHOLD;
	}

	static set soundEnabled(val) {
		if (Sound.soundEnabled !== val) {
			if (val) {
				Sound.soundsVol = game.settings.getItem('soundsVolEnabling', game.projectDesc.defaultSoundsVol);
			} else {
				game.settings.setItem('soundsVolEnabling', soundsVol);
				Sound.soundsVol = 0;
			}
			Sound.rememberEnableLevels();
		}
	}

	static toggleSounds() {
		Sound.soundEnabled = !Sound.soundEnabled;
	}

	static toggleFullSound() {
		if (Sound.soundEnabled || Sound.musicEnabled) {
			Sound.soundEnabled = false;
			Sound.musicEnabled = false;
		} else {
			Sound.musicEnabled = game.settings.getItem('musicEnabled', true);
			Sound.soundEnabled = game.settings.getItem('soundEnabled', true);
		}
	}

	static get isFullSoundEnabled() {
		return Sound.soundEnabled || Sound.musicEnabled;
	}

	static init() {
		Sound.soundsVol = game.settings.getItem('soundsVol', game.projectDesc.defaultSoundsVol);
		Sound.musicVol = game.settings.getItem('musicVol', game.projectDesc.defaultMusVol);
	}

	/// #if EDITOR
	static __resetSounds() {
		MusicFragment.__stopAll();
		for (let soundName in Lib.__soundsList) {
			let snd = Lib.getSound(soundName);
			snd.stop();
			snd.lastPlayStartFrame = 0;
		}
		pitches = {};
		pitchedPlayTimeouts = {};
	}
	/// #endif

	static addMasterNode(node: AudioNode) {
		const allOutputs = new Set<GainNode>();
		for (let key in this.outputs) {
			allOutputs.add(this.outputs[key]);
		}
		allOutputs.forEach((output) => {
			output.disconnect();
			output.connect(node);
		});
		node.connect(masterNodes[0]);
		masterNodes.unshift(node);
	}

	static isSoundsLockedByBrowser = true;

	static play(soundId: string, volume = 1.0, rate = 1.0, seek = 0.0) {
		/// #if DEBUG

		rate = rate * game.pixiApp.ticker.speed;
		/// #endif
		if (Sound.isSoundsLockedByBrowser) {
			return;
		}
		let s = Lib.getSound(soundId);

		/// #if DEBUG
		/*
		/// #endif
		if(!s) {
			let er = new Error('Attempt to play unknown sound "' + soundId + '"');
			window.setTimeout(() => {
				throw er;
			});
			return;
		}
		//*/

		if (s.lastPlayStartFrame < game.time
			/// #if EDITOR
			|| game.__EDITOR_mode
		/// #endif
		) {
			/// #if DEBUG
			Sound.__highlightPlayedSound(soundId);
			/// #endif


			volume = volume * Sound.soundsVol * Sound.soundsVol;
			if (volume > MIN_VOL_THRESHOLD
			/// #if DEBUG
			&& (s !== EMPTY_SOUND)
			/// #endif
			) {
				try {
					s.play(volume, rate, seek);
					s.lastPlayStartFrame = game.time + 2;
					/// #if DEBUG
					refreshSndDebugger();
					/// #endif

					/// #if EDITOR
					editorEvents.emit('soundPlay', soundId, volume);
					/// #endif
				} catch (_er) { }
			}
		}
	}

	static playPitched(soundId: string, resetTimeout = 200, pitchStep = 1.0594630943592953, pitchLimit = 3) {
		let prevTime = pitchedPlayTimeouts[soundId];
		let d = game.time - prevTime;
		if (d < 2) {
			return;
		}

		let pitch;
		if (d < resetTimeout) {
			pitch = Math.min(pitches[soundId] * pitchStep, pitchLimit);
		} else {
			pitch = 1;
		}
		pitches[soundId] = pitch;
		pitchedPlayTimeouts[soundId] = game.time;
		Sound.play(soundId, 1, pitch, 0);
	}

	static _unlockSound() {
		if (Sound.isSoundsLockedByBrowser) {
			Sound.isSoundsLockedByBrowser = false;
			game.classes?.BgMusic?._recalculateMusic();
		}
	}

	/// #if DEBUG
	static __loadSoundOverrides() {
		__loadSoundOverrides();
	}

	static __refreshDebugger() {
		if (sndDebuggerShowed) {
			showSndDebugger();
		}
	}

	static __toggleDebugger() {
		if (sndDebuggerShowed) {
			hideSndDebugger();
			return;
		}
		showSndDebugger();
	}

	static __highlightPlayedSound(soundId: string) {
		LAST_HIT_TIME.set(soundId, Date.now());
		if (sndDebuggerShowed) {
			if (!Lib.hasSound(soundId)) {
				Lib.__soundsList[soundId] = EMPTY_SOUND;
				if (sndDebuggerShowed) {
					setTimeout(() => Sound.__highlightPlayedSound(soundId), 20);
				}
			}
			if (!game.__EDITOR_mode) {
				let soundTitle: HTMLDivElement = document.querySelector('.sounds-debug-panel .' + cleanupClassName(soundId))!;
				if (soundTitle) {
					soundTitle.style.color = 'rgb(0,150,0)';
					if (!__animatedSoundItems.includes(soundTitle)) {
						__animatedSoundItems.push(soundTitle);
					}
				}
			}
			refreshSndDebugger();
		}
	}

	/// #endif

	/// #if EDITOR
	static __stop() {
		if (game.__EDITOR_mode) {
			for (let soundName in Lib.__soundsList) {
				Lib.getSound(soundName).stop();
			}
		}
	}
	/// #endif
}

/// #if DEBUG
const initEmptySound = async () => {
	EMPTY_SOUND = new HowlSound('data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU2LjM2LjEwMAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU2LjQxAAAAAAAAAAAAAAAAJAAAAAAAAAAAASDs90hvAAAAAAAAAAAAAAAAAAAA//MUZAAAAAGkAAAAAAAAA0gAAAAATEFN//MUZAMAAAGkAAAAAAAAA0gAAAAARTMu//MUZAYAAAGkAAAAAAAAA0gAAAAAOTku//MUZAkAAAGkAAAAAAAAA0gAAAAANVVV');
	EMPTY_SOUND.__isEmptySound = true;
};

const __animatedSoundItems = [] as HTMLDivElement[];
const __onUpdate = () => {
	for (let i = __animatedSoundItems.length - 1; i >= 0; i--) {
		const e = __animatedSoundItems[i];
		const color = e.style.color.split(/\(|\)|,/gm);
		let RB = parseInt(color[1]);
		let G = parseInt(color[2]);
		if (G < 255) {
			G++;
		}
		if (RB < 255) {
			RB ++;
		}
		e.style.color = 'rgb(' + RB + ',' + G + ',' + RB + ')';
		if (RB === 255) {
			__animatedSoundItems.splice(i, 1);
		}
	}
};

setTimeout(() => {
	/// #if EDITOR
	editorEvents.on('projectDidOpen', () => {
		game.on('updated', __onUpdate);
	});
	return;
	/// #endif
	game.on('updated', __onUpdate);
}, 10);

setTimeout(initEmptySound, 0);
/// #endif

/* playPitched - increases pitch each time until timeout*/
let pitches: KeyedMap<number> = {};
let pitchedPlayTimeouts: KeyedMap<number> = {};

let enablingSaveTimeout = 0;
function _rememberEnableLevels() {
	enablingSaveTimeout = 0;
	if (Sound.soundEnabled || Sound.musicEnabled) {
		game.settings.setItem('soundEnabled', Sound.soundEnabled);
		game.settings.setItem('musicEnabled', Sound.musicEnabled);
	}
}

let soundsVol: number;
let musicVol: number;

/// #if DEBUG
const LAST_HIT_TIME = new Map() as Map<string, number>;
/// #endif


/// #if EDITOR
(Sound.play as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.play as SelectableProperty).___EDITOR_callbackParameterChooserFunction = () => {
	return game.editor.chooseSound('Choose sound to play:');
};

(Sound.playPitched as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.setSoundsVol as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.setMusicVol as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.toggleMusic as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.toggleSounds as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.toggleFullSound as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound as SelectableProperty).___EDITOR_isGoodForChooser = true;
(Sound.init as SelectableProperty).___EDITOR_isHiddenForChooser = true;

/// #endif

/// #if DEBUG

// ==============================================
// ===== SOUND DEBUG PANEL ======================
// ==============================================

const classesCache = new Map() as Map<string, string>;
const cleanupClassName = (soundId:string) => {
	if (!classesCache.has(soundId)) {
		classesCache.set(soundId, 'snd-name-' + soundId.replace(/\//gm, '_s_'));
	}
	return classesCache.get(soundId);
};

const defaultSoundsUrls: KeyedMap<string> = {};

function overrideSound(name: string, src?: string) {

	if (!defaultSoundsUrls[name] && (Lib.hasSound(name) && !Lib.getSound(name).__isEmptySound) && src) {
		defaultSoundsUrls[name] = (Lib.getSound(name) as any)._src;
		assert(defaultSoundsUrls[name], 'Howler is changed');
	}
	let url = src || defaultSoundsUrls[name];
	Lib.__overrideSound(name, url || EMPTY_SOUND); //@ts-ignore
}


function toggleSoundsPanelLeft() {
	(game.editor || game).settings.setItem('__sounds-panel-is-left', !(game.editor || game).settings.getItem('__sounds-panel-is-left'));
	showSndDebugger();
}

let sndDebugger: HTMLDivElement;
let sndDebuggerShowed = false;

setTimeout(() => {
	if ((game.editor || game).settings?.getItem('_sound-debugger-shown')) {
		showSndDebugger();
	}
}, 10);

function hideSndDebugger() {
	sndDebugger.style.display = 'none';
	sndDebuggerShowed = false;
	(game.editor || game).settings.setItem('_sound-debugger-shown', false);
}

let libSounds: KeyedMap<HowlSound>;
async function __loadSoundOverrides() {
	if (!libSounds) {
		libSounds = Lib.sounds;

		await waitForCondition(() => {
			return game.loadingProgress === 100;
		});

		const overrides = IndexedDBUtils.getEntriesList('sound');
		for (let sndName of overrides) {
			const data = IndexedDBUtils.load(sndName, 'sound');
			if (data) {
				overrideSound(sndName, data.data);
			}
		}
	}
}

let showSndDebuggerTimeOut = 0;
function showSndDebugger() {
	if (!showSndDebuggerTimeOut) {
		sndDebuggerShowed = true;
		showSndDebuggerTimeOut = window.setTimeout(showSndDebuggerInner, 0);
	}
}

function refreshSndDebugger() {
	if (sndDebugger && sndDebuggerShowed) {
		showSndDebugger();
	}
}

function renderSoundPanelItem(soundName:string) {
	const overrideData = IndexedDBUtils.load(soundName, 'sound')!;
	let info;
	if (overrideData) {
		info = R.fragment(' UPLOADED (' + overrideData!.fileName + ')', R.button({ className: 'snd-clear', onClick: () => {
			IndexedDBUtils.save(soundName, 'sound');
			showSndDebugger();
			overrideSound(soundName);
		}
		}, '×'));
	} else {
		info = '-';
	}

	return R.tr({key: soundName},
		R.td({
			className: (Lib.getSound(soundName) === EMPTY_SOUND) ? 'snd-name snd-name-empty ' + cleanupClassName(soundName) : 'snd-name ' + cleanupClassName(soundName),
			onClick: (ev: MouseEvent) => {
				if (ev.ctrlKey || ev.metaKey) {
					const txt = soundName.split('/').pop()!;
					navigator.clipboard.writeText(txt);
					/// #if EDITOR
					game.editor.copyToClipboard(txt);
					return;
					/// #endif
					FlyText.flyText('Copied to clipboard: ' + txt, 200, 200);
				} else {
					const s = Lib.getSound(soundName);
					s.lastPlayStartFrame = -1;
					s.play();
					if (timeouts[soundName]) {
						clearTimeout(timeouts[soundName]);
						delete timeouts[soundName];
					}
					timeouts[soundName] = window.setTimeout(() => {
						if (Lib.hasSound(soundName)) {
							Lib.getSound(soundName).stop();
						}
					}, 2000);
				}
			}
		}, soundName.startsWith('snd/') ? soundName.substring(4) : soundName),
		R.td(null, R.button({ className: 'snd-override', onClick: async () => {
			const sndData = await IndexedDBUtils.openFile(soundName);
			let a = new Audio(sndData[0].data);
			a.play();
			window.setTimeout(() => {
				a.pause();
			}, 2000);
			overrideSound(soundName, sndData[0].data);
			showSndDebugger();
		}
		}, 'Choose...')),
		R.td(null, info)
	);
}

function renderSoundsPanel() {
	const items = [];

	let list: string[] | undefined;
	const sortByTime = (game.editor || game).settings.getItem('__sounds-panel-sort-by-time', -1);
	const sortByName = (game.editor || game).settings.getItem('__sounds-panel-sort-by-name', 0);
	if (sortByTime) {
		list = Object.keys(Lib.__soundsList);
		if (sortByTime > 0) {
			list.sort((a, b) => {
				return (LAST_HIT_TIME.get(a) || 0) - (LAST_HIT_TIME.get(b) || 0);
			});
		} else {
			list.sort((b, a) => {
				return (LAST_HIT_TIME.get(a) || 0) - (LAST_HIT_TIME.get(b) || 0);
			});
		}
	} else if (sortByName) {
		list = Object.keys(Lib.__soundsList);
		if (sortByName > 0) {
			list.sort((a, b) => {
				return (a > b) ? -1 : 1;
			});
		} else {
			list.sort((b, a) => {
				return (a > b) ? -1 : 1;
			});
		}
	}

	if (list) {
		for (const soundId of list) {
			items.push(renderSoundPanelItem(soundId));
		}
	} else {
		for (const soundId in Lib.__soundsList) {
			items.push(renderSoundPanelItem(soundId));
		}
	}

	return R.fragment(
		(game.editor || game).settings.getItem('__sounds-panel-is-left') ? R.span({className: 'panel-is-left'}) : undefined,
		R.button({
			className: 'close-sounds-button',
			onClick: Sound.__toggleDebugger
		}, '×'),
		R.button({
			onClick: toggleSoundsPanelLeft
		}, '< >'),
		R.div({className: 'list-header'}, 'Sort by: ',
			R.span({className: 'sort-button', onClick: () => {
				if (sortByName > 0) {
					(game.editor || game).settings.setItem('__sounds-panel-sort-by-name', -1);
				} else {
					(game.editor || game).settings.setItem('__sounds-panel-sort-by-name', 1);
				}
				(game.editor || game).settings.removeItem('__sounds-panel-sort-by-time');
				showSndDebugger();
			}
			}, 'name ', sortByName ? ((sortByName > 0) ? '⮟' : '⮝') : '\u00A0'),

			R.span({className: 'sort-button', onClick: () => {
				if (sortByTime > 0) {
					(game.editor || game).settings.setItem('__sounds-panel-sort-by-time', -1);
				} else {
					(game.editor || game).settings.setItem('__sounds-panel-sort-by-time', 1);
				}
				(game.editor || game).settings.removeItem('__sounds-panel-sort-by-name');
				showSndDebugger();
			}
			}, 'play-time ', sortByTime ? ((sortByTime > 0) ? '⮟' : '⮝') : '\u00A0')
		),
		R.div({
			className: 'sounds-debug-panel-body',
			/// #if EDITOR
			title: CTRL_READABLE + ' + click to copy sound\'s name'
			/*
			/// #endif
			title: 'ctrl + click to copy sound\'s name'
			//*/

		},
		R.table({border: 0, cellspacing: 0, cellpadding: 0},
			items
		)
		),
		/*R.button({onClick: () => {
			// TODO:
		}}, 'Download sounds...'),*/
		R.button({onClick: async () => {
			const files = await IndexedDBUtils.openFile('', undefined, undefined, true);
			for (const fileData of files) {
				let soundName = fileData.fileName.replace(/.wav$/, '');
				if (!Lib.hasSound(soundName)) {
					soundName = 'snd/' + soundName;
				}
				Lib.__overrideSound(soundName, fileData.data);
				IndexedDBUtils.save(soundName, 'sound', fileData);
			}
			showSndDebugger();
		}}, 'Upload sounds...'),
		R.button({
			className: 'close-sounds-button',
			onClick: () => {
				const ids = Object.keys(Lib.sounds);
				for (const id of ids) {
					if (Lib.sounds[id].__isEmptySound) {
						delete Lib.sounds[id];
					}
				}
				showSndDebugger();
			}
		}, 'Clear optionals')

	);
}

async function showSndDebuggerInner() {
	showSndDebuggerTimeOut = 0;
	if (!sndDebuggerShowed) {
		return;
	}
	/// #if EDITOR
	//return;
	/// #endif

	if (!sndDebugger) { // eslint-disable-line no-unreachable

		game.applyCSS(debugPanelStyle);
		sndDebugger = document.createElement('div');
		sndDebugger.classList.add('sounds-debug-panel');
		window.document.body.appendChild(sndDebugger);
		await __loadSoundOverrides();
	}

	(game.editor || game).settings.setItem('_sound-debugger-shown', true);
	render(renderSoundsPanel(), sndDebugger);
	sndDebugger.style.display = 'block';
}

const timeouts: KeyedMap<number> = {};

window.addEventListener('keydown', (ev) => {
	/// #if EDITOR
	//return;
	/// #endif
	if (ev.keyCode === 115) {
		Sound.__toggleDebugger();
	}
});

/// #if EDITOR
export const ACTION_ICON_SOUND = R.img({ src: '/thing-editor/img/timeline/sound.png' });
(Sound.play as SelectableProperty).___EDITOR_actionIcon = ACTION_ICON_SOUND;
/// #endif


/// #endif

/// #if EDITOR
editorEvents.on('playToggle', () => {
	while (__animatedSoundItems.length) {
		__animatedSoundItems.pop()!.style.color = 'rgb(255,255,255)';
	}
});

/// #endif

let masterNodes = [rootAudioContext.destination] as AudioNode[];

Sound.outputs['Sound.soundsVol'] = Sound.outputs.FX = rootAudioContext.createGain();
Sound.outputs.MUSIC = rootAudioContext.createGain();
Sound.outputs.FX.connect(rootAudioContext.destination);
Sound.outputs.MUSIC.connect(rootAudioContext.destination);
slideAudioParamTo(Sound.outputs.FX.gain, 0, 0);
slideAudioParamTo(Sound.outputs.MUSIC.gain, 0, 0);
</file>

<file path="src/engine/utils/sure-question.ts">
import type { Container, Text } from 'pixi.js';
import game from 'thing-editor/src/engine/game';
import type Button from 'thing-editor/src/engine/lib/assets/src/basic/button.c';
import callByPath from 'thing-editor/src/engine/utils/call-by-path';
import L from 'thing-editor/src/engine/utils/l';

/** thing-editor internal */
const sureQuestionInit = (container: Container, title: string, message: string, yesLabel?: string, onYes?: (() => void) | string, noLabel?: string, onNo?: (() => void) | string, easyClose = true) => {

	const onYesHandler = () => {
		game.hideModal(container);
		if (onYes) {
			if (typeof onYes === 'string') {
				callByPath(onYes, container);
			} else {
				onYes();
			}
		}
	};
	const onNoHandler = () => {
		game.hideModal(container);
		if (onNo) {
			if (typeof onNo === 'string') {
				callByPath(onNo, container);
			} else {
				onNo();
			}
		}
	};

	let btn = container.findChildByName('easyCloseBtn') as Button;
	if (btn) {
		if (!easyClose) {
			btn.disable();
		} else {
			btn.onClickCallback = onNoHandler;
		}
	}

	if ((typeof title) === 'string') {
		let tf = container.findChildByName('title') as Text;
		if (tf) {
			tf.text = title;
		}
	}
	if ((typeof message) === 'string') {
		let tf = container.findChildByName('message') as Text;
		if (tf) {
			tf.text = message;
		}
	}

	let okBtn = container.findChildByName('okBtn') as Button;
	if (okBtn) {
		if (yesLabel) {
			let tf = okBtn.findChildByName('label') as Text;
			if (tf) {
				if (L.has(yesLabel)) {
					tf.translatableText = yesLabel;
				} else {
					tf.translatableText = null;
					tf.text = yesLabel;
				}
			}
		}
		okBtn.onClickCallback = onYesHandler;
	}

	let noBtn = container.findChildByName('noBtn') as Button;
	if (noBtn) {
		if (noLabel) {
			let tf = noBtn.findChildByName('label') as Text;
			if (tf) {
				if (L.has(noLabel)) {
					tf.translatableText = noLabel;
				} else {
					tf.translatableText = null;
					tf.text = noLabel;
				}
			}
		}

		if (noLabel || (onNo && !easyClose)) {
			noBtn.onClickCallback = onNoHandler;
		} else {
			noBtn.visible = false;
			okBtn.x = (okBtn.x + noBtn.x) / 2; //Centralize ok button
		}
	}
};

export default sureQuestionInit;
</file>

<file path="src/engine/utils/utils.ts">
import { electron_ThingEditorServer } from 'thing-editor/src/editor/utils/flags';
import assert from 'thing-editor/src/engine/debug/assert';

const PI2 = Math.PI * 2;
/// #if EDITOR
const CTRL_READABLE = (electron_ThingEditorServer.versions.platform == 'darwin') ? '⌘' : 'Ctrl';
/// #endif

const stepTo = (val: number, to: number, step: number) => {
	assert(!isNaN(val), 'stepTo val, valid number expected.');
	assert(!isNaN(to), 'stepTo to, valid number expected.');
	assert(!isNaN(step), 'stepTo step, valid number expected.');
	if (Math.abs(val - to) <= step) return to;
	if (val > to) {
		return val - step;
	}
	return val + step;
};

const stepToR = (val: number, target: number, step: number) => {
	assert(!isNaN(val), 'stepToR val, valid number expected.');
	assert(!isNaN(target), 'stepToR to, valid number expected.');
	assert(!isNaN(step), 'stepToR step, valid number expected.');
	if ((target - val) > Math.PI) {
		val += PI2;
	} else if ((target - val) < -Math.PI) {
		val -= PI2;
	}
	if (Math.abs(val - target) <= step) {
		return target;
	}
	if (val < target) {
		return val + step;
	}
	return val - step;
};

export {
	/// #if EDITOR
	CTRL_READABLE,
	/// #endif
	PI2, stepTo, stepToR
};
</file>

</files>
